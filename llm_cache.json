{"\nFor the project `flutter`:\n\nCodebase Context:\n--- File Index 0: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\n\n\nAnalyze the codebase context.\nIdentify the top 5-10 core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n- 0 # packages/flutter/lib/src/widgets/navigator.dart\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization\n  description: |\n    Another core concept, similar to a blueprint for objects.\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to 10 abstractions\n```": "```yaml\n- name: |\n    Navigator\n  description: |\n    Think of a Navigator like a stack of cards, where each card represents a different screen or page in your app. The Navigator lets you add new cards to the top of the stack (`push`), remove the top card (`pop`), and rearrange the stack. This is how users move between different parts of your application. You can manage the stack using lists of `Page` objects or by calling methods like `push` and `pop`.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    Route\n  description: |\n    A Route is an abstraction for an entry managed by the Navigator. It's like a single card in the Navigator's deck. A Route defines what appears on the screen and how it interacts with the Navigator, including how it animates when entering or exiting, whether it can be popped, and what value it might return when popped.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    RouteSettings\n  description: |\n    RouteSettings are like the information written on the back of a Route card. They hold details about the route, such as its name (like `/settings`) and any arguments passed to it (like data needed to build the screen). Navigators use these settings to generate or find the correct Route to display.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    Page\n  description: |\n    A Page is a specific type of RouteSettings used when managing the Navigator with a list of pages instead of imperative method calls. Pages are a more declarative way to describe the Navigator's history. Think of them as blueprints for the Route cards that the Navigator will build. When you update the list of Pages, the Navigator determines what needs to change in its Route stack.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    NavigatorObserver\n  description: |\n    A NavigatorObserver is like a spy watching the Navigator's actions. It gets notified whenever something happens to the Navigator's history stack, such as a route being pushed, popped, or replaced. This is useful for tracking navigation events, for logging, or for triggering side effects based on navigation changes.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    TransitionDelegate\n  description: |\n    The TransitionDelegate is the decision-maker for how Pages animate when entering or exiting the screen. When you update the list of Pages, the Navigator consults the TransitionDelegate to figure out which Pages should animate (push, pop) and which should just appear or disappear without animation (add, remove, complete).\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    RestorableRouteFuture\n  description: |\n    This abstraction helps restore routes and their return values after your app restarts. Think of it like a sticky note you attach to a button that opens a new screen. When the screen closes and gives back a result, the sticky note remembers it. Even if your app restarts, the sticky note (RestorableRouteFuture) helps you get back the right screen and its result when it's re-opened.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    RoutePredicate\n  description: |\n    A RoutePredicate is a function that checks if a given Route meets certain criteria. It's like telling the Navigator, \"Keep popping routes until you find one that matches this condition.\" This is commonly used with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear part of the navigation history.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n- name: |\n    RoutePopDisposition\n  description: |\n    RoutePopDisposition determines what should happen when a user tries to pop a route (e.g., by pressing the back button). It's like setting a rule for how a specific screen should react to being dismissed. The options are to allow the pop (`pop`), ignore it (`doNotPop`), or let the operating system handle it (`bubble`).\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/navigator.dart\n```", "\nBased on the following abstractions and relevant code snippets from the project `flutter`:\n\nList of Abstraction Indices and Names:\n0 # Navigator\n\n1 # Route\n\n2 # RouteSettings\n\n3 # Page\n\n4 # NavigatorObserver\n\n5 # TransitionDelegate\n\n6 # RestorableRouteFuture\n\n7 # RoutePredicate\n\n8 # RoutePopDisposition\n\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\\n- Index 0: Navigator\n (Relevant file indices: [0])\\n  Description: Think of a Navigator like a stack of cards, where each card represents a different screen or page in your app. The Navigator lets you add new cards to the top of the stack (`push`), remove the top card (`pop`), and rearrange the stack. This is how users move between different parts of your application. You can manage the stack using lists of `Page` objects or by calling methods like `push` and `pop`.\n\\n- Index 1: Route\n (Relevant file indices: [0])\\n  Description: A Route is an abstraction for an entry managed by the Navigator. It's like a single card in the Navigator's deck. A Route defines what appears on the screen and how it interacts with the Navigator, including how it animates when entering or exiting, whether it can be popped, and what value it might return when popped.\n\\n- Index 2: RouteSettings\n (Relevant file indices: [0])\\n  Description: RouteSettings are like the information written on the back of a Route card. They hold details about the route, such as its name (like `/settings`) and any arguments passed to it (like data needed to build the screen). Navigators use these settings to generate or find the correct Route to display.\n\\n- Index 3: Page\n (Relevant file indices: [0])\\n  Description: A Page is a specific type of RouteSettings used when managing the Navigator with a list of pages instead of imperative method calls. Pages are a more declarative way to describe the Navigator's history. Think of them as blueprints for the Route cards that the Navigator will build. When you update the list of Pages, the Navigator determines what needs to change in its Route stack.\n\\n- Index 4: NavigatorObserver\n (Relevant file indices: [0])\\n  Description: A NavigatorObserver is like a spy watching the Navigator's actions. It gets notified whenever something happens to the Navigator's history stack, such as a route being pushed, popped, or replaced. This is useful for tracking navigation events, for logging, or for triggering side effects based on navigation changes.\n\\n- Index 5: TransitionDelegate\n (Relevant file indices: [0])\\n  Description: The TransitionDelegate is the decision-maker for how Pages animate when entering or exiting the screen. When you update the list of Pages, the Navigator consults the TransitionDelegate to figure out which Pages should animate (push, pop) and which should just appear or disappear without animation (add, remove, complete).\n\\n- Index 6: RestorableRouteFuture\n (Relevant file indices: [0])\\n  Description: This abstraction helps restore routes and their return values after your app restarts. Think of it like a sticky note you attach to a button that opens a new screen. When the screen closes and gives back a result, the sticky note remembers it. Even if your app restarts, the sticky note (RestorableRouteFuture) helps you get back the right screen and its result when it's re-opened.\n\\n- Index 7: RoutePredicate\n (Relevant file indices: [0])\\n  Description: A RoutePredicate is a function that checks if a given Route meets certain criteria. It's like telling the Navigator, \"Keep popping routes until you find one that matches this condition.\" This is commonly used with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear part of the navigation history.\n\\n- Index 8: RoutePopDisposition\n (Relevant file indices: [0])\\n  Description: RoutePopDisposition determines what should happen when a user tries to pop a route (e.g., by pressing the back button). It's like setting a rule for how a specific screen should react to being dismissed. The options are to allow the pop (`pop`), ignore it (`doNotPop`), or let the operating system handle it (`bubble`).\n\\n\\nRelevant File Snippets (Referenced by Index and Path):\\n--- File: 0 # packages/flutter/lib/src/widgets/navigator.dart ---\\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project.\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\"\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\"\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  This Flutter project provides a system for managing the flow and structure of screens within an application. The core idea revolves around a **Navigator**, which acts like a stack of *Routes* (individual screens). Users can *push* new routes onto the stack to move forward or *pop* routes off the stack to go back. This system allows for organized navigation, passing data between screens (*RouteSettings*), observing navigation events (*NavigatorObserver*), and even handling animated transitions (*TransitionDelegate*).\nrelationships:\n  - from_abstraction: 0 # Navigator\n    to_abstraction: 1 # Route\n    label: \"Manages stack of\"\n  - from_abstraction: 1 # Route\n    to_abstraction: 2 # RouteSettings\n    label: \"Has\"\n  - from_abstraction: 2 # RouteSettings\n    to_abstraction: 0 # Navigator\n    label: \"Used by\"\n  - from_abstraction: 3 # Page\n    to_abstraction: 2 # RouteSettings\n    label: \"Extends\"\n  - from_abstraction: 0 # Navigator\n    to_abstraction: 4 # NavigatorObserver\n    label: \"Notifies\"\n  - from_abstraction: 0 # Navigator\n    to_abstraction: 5 # TransitionDelegate\n    label: \"Uses to animate\"\n  - from_abstraction: 6 # RestorableRouteFuture\n    to_abstraction: 0 # Navigator\n    label: \"Presents route on\"\n  - from_abstraction: 7 # RoutePredicate\n    to_abstraction: 0 # Navigator\n    label: \"Used to filter routes\"\n  - from_abstraction: 1 # Route\n    to_abstraction: 8 # RoutePopDisposition\n    label: \"Determines pop behavior\"\n  - from_abstraction: 0 # Navigator\n    to_abstraction: 3 # Page\n    label: \"Can be configured with\"\n  - from_abstraction: 6 # RestorableRouteFuture\n    to_abstraction: 1 # Route\n    label: \"Provides access to\"\n```", "\nGiven the following project abstractions and their relationships for the project ```` flutter ````:\n\nAbstractions (Index # Name):\n- 0 # Navigator\n\n- 1 # Route\n\n- 2 # RouteSettings\n\n- 3 # Page\n\n- 4 # NavigatorObserver\n\n- 5 # TransitionDelegate\n\n- 6 # RestorableRouteFuture\n\n- 7 # RoutePredicate\n\n- 8 # RoutePopDisposition\n\n\nContext about relationships and project summary:\nProject Summary:\nThis Flutter project provides a system for managing the flow and structure of screens within an application. The core idea revolves around a **Navigator**, which acts like a stack of *Routes* (individual screens). Users can *push* new routes onto the stack to move forward or *pop* routes off the stack to go back. This system allows for organized navigation, passing data between screens (*RouteSettings*), observing navigation events (*NavigatorObserver*), and even handling animated transitions (*TransitionDelegate*).\n\n\nRelationships (Indices refer to abstractions above):\n- From 0 (Navigator\n) to 1 (Route\n): Manages stack of\n- From 1 (Route\n) to 2 (RouteSettings\n): Has\n- From 2 (RouteSettings\n) to 0 (Navigator\n): Used by\n- From 3 (Page\n) to 2 (RouteSettings\n): Extends\n- From 0 (Navigator\n) to 4 (NavigatorObserver\n): Notifies\n- From 0 (Navigator\n) to 5 (TransitionDelegate\n): Uses to animate\n- From 6 (RestorableRouteFuture\n) to 0 (Navigator\n): Presents route on\n- From 7 (RoutePredicate\n) to 0 (Navigator\n): Used to filter routes\n- From 1 (Route\n) to 8 (RoutePopDisposition\n): Determines pop behavior\n- From 0 (Navigator\n) to 3 (Page\n): Can be configured with\n- From 6 (RestorableRouteFuture\n) to 1 (Route\n): Provides access to\n\n\nIf you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 0 # Navigator\n- 1 # Route\n- 2 # RouteSettings\n- 3 # Page\n- 7 # RoutePredicate\n- 8 # RoutePopDisposition\n- 4 # NavigatorObserver\n- 5 # TransitionDelegate\n- 6 # RestorableRouteFuture\n```", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Navigator\n\". This is Chapter 1.\n\nConcept Details:\n- Name: Navigator\n\n- Description:\nThink of a Navigator like a stack of cards, where each card represents a different screen or page in your app. The Navigator lets you add new cards to the top of the stack (`push`), remove the top card (`pop`), and rearrange the stack. This is how users move between different parts of your application. You can manage the stack using lists of `Page` objects or by calling methods like `push` and `pop`.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: Navigator\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Route\n\". This is Chapter 2.\n\nConcept Details:\n- Name: Route\n\n- Description:\nA Route is an abstraction for an entry managed by the Navigator. It's like a single card in the Navigator's deck. A Route defines what appears on the screen and how it interacts with the Navigator, including how it animates when entering or exiting, whether it can be popped, and what value it might return when popped.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2: Route\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteSettings\n\". This is Chapter 3.\n\nConcept Details:\n- Name: RouteSettings\n\n- Description:\nRouteSettings are like the information written on the back of a Route card. They hold details about the route, such as its name (like `/settings`) and any arguments passed to it (like data needed to build the screen). Navigators use these settings to generate or find the correct Route to display.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3: RouteSettings\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Page\n\". This is Chapter 4.\n\nConcept Details:\n- Name: Page\n\n- Description:\nA Page is a specific type of RouteSettings used when managing the Navigator with a list of pages instead of imperative method calls. Pages are a more declarative way to describe the Navigator's history. Think of them as blueprints for the Route cards that the Navigator will build. When you update the list of Pages, the Navigator determines what needs to change in its Route stack.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4: Page\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RoutePredicate\n\". This is Chapter 5.\n\nConcept Details:\n- Name: RoutePredicate\n\n- Description:\nA RoutePredicate is a function that checks if a given Route meets certain criteria. It's like telling the Navigator, \"Keep popping routes until you find one that matches this condition.\" This is commonly used with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear part of the navigation history.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n---\n# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5: RoutePredicate\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5: RoutePredicate\n\nWelcome back, future Flutter navigators! In our previous chapters, we explored the [Navigator](01_navigator_.md) (the screen manager), the [Route](02_route_.md) (the screen recipe), [RouteSettings](03_routesettings_.md) (names and arguments), and the [Page](04_page_.md) (a blueprint for routes).\n\nToday, we're looking at another useful tool in the Navigator's kit: the **RoutePredicate**. While `push` adds routes and `pop` removes the top one, sometimes you need more control over *which* routes get removed from the stack. That's where a `RoutePredicate` comes in!\n\n## What is a RoutePredicate?\n\nA `RoutePredicate` is essentially a **function** that helps the [Navigator](01_navigator_.md) decide if a specific [Route](02_route_.md) meets certain criteria. Think of it like a filter or a test you can apply to each [Route](02_route_.md) in the [Navigator's](01_navigator_.md) history stack.\n\nThe [Navigator](01_navigator_.md) can use these predicates with methods like `popUntil` and `pushNamedAndRemoveUntil` to perform actions on multiple routes until a route that matches the predicate is found.\n\n## The Use Case: Clearing Navigation History\n\nImagine you have an app with a navigation flow like this:\n\nHome -> List -> Detail -> Edit -> Confirmation -> Home\n\nIf you are on the \"Confirmation\" screen and tap a button that says \"Finish,\" you probably want to go all the way back to the \"Home\" screen, removing \"Confirmation,\" \"Edit,\" and \"Detail\" from the history.\n\nUsing just `pop` wouldn't work easily; you'd have to call `pop` three times, only if you knew exactly how many screens were above the Home screen. This isn't flexible.\n\nA `RoutePredicate` allows you to say, \"Keep popping routes off the stack *until* you find the 'Home' route.\"\n\n## Using RoutePredicate with `popUntil`\n\nThe primary method where you'll use a `RoutePredicate` is `Navigator.popUntil`. This method traverses backwards through the [Navigator's](01_navigator_.md) history stack and pops routes until the provided predicate returns `true` for a route. The route that satisfies the predicate is *not* popped itself.\n\nLet's set up a simple example to demonstrate this. We'll have three screens: Home, Screen A, and Screen B. We'll navigate from Home -> Screen A -> Screen B, and then use `popUntil` from Screen B to go back to Home.\n\nFirst, let's define our screens with unique names in their `RouteSettings`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenA');\n          },\n          child: const Text('Go to Screen A'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Screen A\nclass ScreenA extends StatelessWidget {\n  const ScreenA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen A')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenB');\n          },\n          child: const Text('Go to Screen B'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 3: Screen B\nclass ScreenB extends StatelessWidget {\n  const ScreenB({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen B')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This is where we use popUntil!\n            Navigator.popUntil(context, (route) {\n              // Our predicate: check if the route is the Home Screen route ('/')\n              return route.settings.name == '/';\n            });\n          },\n          child: const Text('Go back to Home'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nNow, let's set up our `MaterialApp` with named routes:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Assuming screens.dart contains the screen widgets above\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Pop Until Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/screenA': (context) => const ScreenA(),\n      '/screenB': (context) => const ScreenB(),\n    },\n  ));\n}\n```\n\nIn this example:\n\n1.  We start on `/` (HomeScreen).\n2.  Tapping the button on `HomeScreen` pushes `/screenA`.\n3.  Tapping the button on `ScreenA` pushes `/screenB`.\n4.  Now the navigation stack is conceptually `[/, /screenA, /screenB]`.\n5.  On `ScreenB`, when the button is tapped, `Navigator.popUntil(context, (route) { return route.settings.name == '/'; });` is called.\n6.  The [Navigator](01_navigator_.md) looks at `/screenB`. Does its name equal '/'? No. It is popped.\n7.  The [Navigator](01_navigator_.md) looks at `/screenA`. Does its name equal '/'? No. It is popped.\n8.  The [Navigator](01_navigator_.md) looks at `/`. Does its name equal '/'? Yes! The predicate returns true. The popping stops.\n9.  The user is now back on the `HomeScreen`.\n\nThe `RoutePredicate` itself is this part:\n\n```dart\n(route) {\n  return route.settings.name == '/';\n}\n```\n\nIt's a function that takes one argument: a `Route<dynamic>` object. Inside the function, we check if the `settings.name` of that route is equal to '/'.\n\n## Common RoutePredicates\n\nWhile you can write any predicate function you need, Flutter provides some handy ones:\n\n*   **`(Route<dynamic> route) => false`**: This predicate always returns false. If used with `popUntil`, it would pop *all* routes until the last one (which won't be popped). If used with `pushNamedAndRemoveUntil`, it would remove *all* routes currently in the stack before pushing the new one.\n*   **`ModalRoute.withName('/someName')`**: This is a very common predicate. It returns a function that checks if a route is a `ModalRoute` (which most full-screen routes are) and if its `settings.name` matches the provided string. This is exactly what we used in our example with `ModalRoute.withName('/')`.\n\nLet's rewrite our `ScreenB` code using `ModalRoute.withName`:\n\n```dart\n// Inside Screen B's ElevatedButton onPressed:\nonPressed: () {\n  Navigator.popUntil(context, ModalRoute.withName('/'));\n},\n```\n\nThis is functionally identical to our previous code and is more concise. `ModalRoute.withName('/')` *returns* the predicate function we need.\n\n## Using RoutePredicate with `pushNamedAndRemoveUntil`\n\nAnother method that uses `RoutePredicate` is `Navigator.pushNamedAndRemoveUntil`. This method first pushes a new named route onto the stack and *then* removes all the routes below the new route until the predicate returns true.\n\nThe \"Confirmation -> Home\" example from earlier is a perfect fit for this. If the \"Finish\" button on \"Confirmation\" pushes the \"Home\" route and removes everything until the \"Home\" route is found *again* (the original one at the bottom of the stack).\n\nAssume we have a `ConfirmationScreen` widget and `/confirmation` route:\n\n```dart\n// Inside ConfirmationScreen's ElevatedButton onPressed:\nonPressed: () {\n  // Push the Home screen route and remove everything until we find\n  // the original Home screen route ('/')\n  Navigator.pushNamedAndRemoveUntil(\n    context,\n    '/', // The name of the new route to push\n    ModalRoute.withName('/') // The predicate: stop removing when we find '/'\n  );\n},\n```\n\nIn this scenario:\n\n1.  The stack is `[ /, /list, /detail, /edit, /confirmation ]`.\n2.  `pushNamedAndRemoveUntil` first prepares to push `/`.\n3.  It looks at `/confirmation`. Does it match `ModalRoute.withName('/')`? No. It's marked for removal.\n4.  It looks at `/edit`. Does it match? No. Marked for removal.\n5.  It looks at `/detail`. Does it match? No. Marked for removal.\n6.  It looks at `/list`. Does it match? No. Marked for removal.\n7.  It looks at `/`. Does it match? Yes! The predicate returns true. The process of identifying routes to remove stops.\n8.  The new route (`/`) is pushed, and simultaneously, the routes marked for removal (`/confirmation`, `/edit`, `/detail`, `/list`) are disposed of.\n9.  The stack is now just `[ / ]`.\n\nThis allows you to effectively \"reset\" part of the navigation stack or jump back to a known point while removing everything above it.\n\n## RoutePredicate Under the Hood (Simplified)\n\nA `RoutePredicate` is just a function signature. Looking at the Flutter code (`navigator.dart`):\n\n```dart\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n```\n\nThis tells us it's a function that accepts a `Route<dynamic>` as input and returns a `bool`. `true` means the predicate is satisfied, `false` means it's not.\n\nHow does the `NavigatorState` use this predicate internally? Let's focus on the `popUntil` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified)\nvoid popUntil(RoutePredicate predicate) {\n  assert(!_debugLocked);\n  assert(() { _debugLocked = true; return true; }());\n\n  // Find the last route that is current or has state that handles pops internally.\n  // We stop there.\n  _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  // Iterate backwards through the history\n  // We use candidate.route.willHandlePopInternally to handle routes that\n  // manage their own pop behavior (like nested navigators or forms).\n  // If a route handles pop internally (willHandlePopInternally is true),\n  // we try to pop it internally first (candidate.route.didPop(null)).\n  // If it still satisfies the predicate after internal pop, we stop.\n  // If not, or if it didn't handle it internally, we continue popping.\n  while (candidate != null) {\n    // Check if the current route candidate satisfies the predicate\n    if (predicate(candidate.route)) {\n      assert(() { _debugLocked = false; return true; }());\n      return; // Predicate returned true, stop popping\n    }\n\n    // If the candidate wants to handle pops internally, try that first\n    if (candidate.route.willHandlePopInternally) {\n        // Try to pop internally. If it returns false, it means\n        // it handled something, but doesn't want to be removed from the stack yet.\n        final bool poppedInternally = candidate.route.didPop(null);\n        assert(!poppedInternally); // didPop returning false means it's handled internally\n        // After internal pop, does it *now* satisfy the predicate?\n        if (predicate(candidate.route)) {\n             assert(() { _debugLocked = false; return true; }());\n            return; // Predicate returned true after internal pop, stop\n        }\n        // If it didn't satisfy the predicate even after internal pop,\n        // continue the while loop check\n    } else {\n         // If the route doesn't handle pop internally, just pop it off the stack.\n         pop(); // This calls _history[index of candidate].pop(null) and leads to _flushHistoryUpdates removing it\n    }\n\n    // After potentially popping the current candidate, revisit the list\n    // to find the new top candidate.\n    candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n  }\n\n  // If the loop finishes, it means the predicate never returned true\n  // before the stack was (almost) empty.\n  assert(() { _debugLocked = false; return true; }());\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ScreenBWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant RouteBEntry\n    participant RouteAEntry\n    participant RouteHomeEntry\n\n    User->>ScreenBWidget: Tap \"Go back to Home\"\n    ScreenBWidget->>NavigatorState: Navigator.popUntil(context, predicate = '/' name check)\n    loop Pop Routes\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteBEntry)\n        NavigatorState->>predicate: Call predicate(RouteBEntry.route)\n        predicate->>NavigatorState: Return false ('/screenB' != '/')\n        NavigatorState->>RouteBEntry: route.didPop(null) (starts animation)\n        RouteBEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteBEntry\n        NavigatorState->>Overlay: Remove RouteB's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteAEntry)\n        NavigatorState->>predicate: Call predicate(RouteAEntry.route)\n        predicate->>NavigatorState: Return false ('/screenA' != '/')\n        NavigatorState->>RouteAEntry: route.didPop(null) (starts animation)\n        RouteAEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteAEntry\n        NavigatorState->>Overlay: Remove RouteA's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteHomeEntry)\n        NavigatorState->>predicate: Call predicate(RouteHomeEntry.route)\n        predicate->>NavigatorState: Return true ('/' == '/')\n        NavigatorState->>NavigatorState: Stop popping\n    end\nalt Loop ends before predicate returns true\n        NavigatorState->>NavigatorState: Stack is nearly empty. Stop looping.\nend\n```\n\nThis simplified diagram shows `popUntil` iterating backwards, applying the predicate to each route it encounters (represented by `_RouteEntry.route`), and if the predicate is false, it removes that route before checking the next one. The loop stops *before* removing the route that satisfies the predicate.\n\n## Conclusion\n\nA `RoutePredicate` is a powerful function that allows you to define criteria for selecting routes within the [Navigator's](01_navigator_.md) history stack. This is particularly useful with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear multiple routes efficiently based on their properties, most commonly their name. By using predicates like `ModalRoute.withName`, you can create flexible navigation flows that aren't tied to knowing the exact number of screens in the stack.\n\nNow that we understand how to identify and manage groups of routes using predicates, we'll move on to discuss `RoutePopDisposition`, which determines whether a route *can* be popped and how a pop request should be handled.\n\n[Chapter 6: RoutePopDisposition](06_routepopdisposition_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RoutePopDisposition\n\". This is Chapter 6.\n\nConcept Details:\n- Name: RoutePopDisposition\n\n- Description:\nRoutePopDisposition determines what should happen when a user tries to pop a route (e.g., by pressing the back button). It's like setting a rule for how a specific screen should react to being dismissed. The options are to allow the pop (`pop`), ignore it (`doNotPop`), or let the operating system handle it (`bubble`).\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n---\n# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)\n---\n# Chapter 5: RoutePredicate\n\nWelcome back, future Flutter navigators! In our previous chapters, we explored the [Navigator](01_navigator_.md) (the screen manager), the [Route](02_route_.md) (the screen recipe), [RouteSettings](03_routesettings_.md) (names and arguments), and the [Page](04_page_.md) (a blueprint for routes).\n\nToday, we're looking at another useful tool in the Navigator's kit: the **RoutePredicate**. While `push` adds routes and `pop` removes the top one, sometimes you need more control over *which* routes get removed from the stack. That's where a `RoutePredicate` comes in!\n\n## What is a RoutePredicate?\n\nA `RoutePredicate` is essentially a **function** that helps the [Navigator](01_navigator_.md) decide if a specific [Route](02_route_.md) meets certain criteria. Think of it like a filter or a test you can apply to each [Route](02_route_.md) in the [Navigator's](01_navigator_.md) history stack.\n\nThe [Navigator](01_navigator_.md) can use these predicates with methods like `popUntil` and `pushNamedAndRemoveUntil` to perform actions on multiple routes until a route that matches the predicate is found.\n\n## The Use Case: Clearing Navigation History\n\nImagine you have an app with a navigation flow like this:\n\nHome -> List -> Detail -> Edit -> Confirmation -> Home\n\nIf you are on the \"Confirmation\" screen and tap a button that says \"Finish,\" you probably want to go all the way back to the \"Home\" screen, removing \"Confirmation,\" \"Edit,\" and \"Detail\" from the history.\n\nUsing just `pop` wouldn't work easily; you'd have to call `pop` three times, only if you knew exactly how many screens were above the Home screen. This isn't flexible.\n\nA `RoutePredicate` allows you to say, \"Keep popping routes off the stack *until* you find the 'Home' route.\"\n\n## Using RoutePredicate with `popUntil`\n\nThe primary method where you'll use a `RoutePredicate` is `Navigator.popUntil`. This method traverses backwards through the [Navigator's](01_navigator_.md) history stack and pops routes until the provided predicate returns `true` for a route. The route that satisfies the predicate is *not* popped itself.\n\nLet's set up a simple example to demonstrate this. We'll have three screens: Home, Screen A, and Screen B. We'll navigate from Home -> Screen A -> Screen B, and then use `popUntil` from Screen B to go back to Home.\n\nFirst, let's define our screens with unique names in their `RouteSettings`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenA');\n          },\n          child: const Text('Go to Screen A'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Screen A\nclass ScreenA extends StatelessWidget {\n  const ScreenA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen A')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenB');\n          },\n          child: const Text('Go to Screen B'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 3: Screen B\nclass ScreenB extends StatelessWidget {\n  const ScreenB({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen B')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This is where we use popUntil!\n            Navigator.popUntil(context, (route) {\n              // Our predicate: check if the route is the Home Screen route ('/')\n              return route.settings.name == '/';\n            });\n          },\n          child: const Text('Go back to Home'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nNow, let's set up our `MaterialApp` with named routes:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Assuming screens.dart contains the screen widgets above\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Pop Until Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/screenA': (context) => const ScreenA(),\n      '/screenB': (context) => const ScreenB(),\n    },\n  ));\n}\n```\n\nIn this example:\n\n1.  We start on `/` (HomeScreen).\n2.  Tapping the button on `HomeScreen` pushes `/screenA`.\n3.  Tapping the button on `ScreenA` pushes `/screenB`.\n4.  Now the navigation stack is conceptually `[/, /screenA, /screenB]`.\n5.  On `ScreenB`, when the button is tapped, `Navigator.popUntil(context, (route) { return route.settings.name == '/'; });` is called.\n6.  The [Navigator](01_navigator_.md) looks at `/screenB`. Does its name equal '/'? No. It is popped.\n7.  The [Navigator](01_navigator_.md) looks at `/screenA`. Does its name equal '/'? No. It is popped.\n8.  The [Navigator](01_navigator_.md) looks at `/`. Does its name equal '/'? Yes! The predicate returns true. The popping stops.\n9.  The user is now back on the `HomeScreen`.\n\nThe `RoutePredicate` itself is this part:\n\n```dart\n(route) {\n  return route.settings.name == '/';\n}\n```\n\nIt's a function that takes one argument: a `Route<dynamic>` object. Inside the function, we check if the `settings.name` of that route is equal to '/'.\n\n## Common RoutePredicates\n\nWhile you can write any predicate function you need, Flutter provides some handy ones:\n\n*   **`(Route<dynamic> route) => false`**: This predicate always returns false. If used with `popUntil`, it would pop *all* routes until the last one (which won't be popped). If used with `pushNamedAndRemoveUntil`, it would remove *all* routes currently in the stack before pushing the new one.\n*   **`ModalRoute.withName('/someName')`**: This is a very common predicate. It returns a function that checks if a route is a `ModalRoute` (which most full-screen routes are) and if its `settings.name` matches the provided string. This is exactly what we used in our example with `ModalRoute.withName('/')`.\n\nLet's rewrite our `ScreenB` code using `ModalRoute.withName`:\n\n```dart\n// Inside Screen B's ElevatedButton onPressed:\nonPressed: () {\n  Navigator.popUntil(context, ModalRoute.withName('/'));\n},\n```\n\nThis is functionally identical to our previous code and is more concise. `ModalRoute.withName('/')` *returns* the predicate function we need.\n\n## Using RoutePredicate with `pushNamedAndRemoveUntil`\n\nAnother method that uses `RoutePredicate` is `Navigator.pushNamedAndRemoveUntil`. This method first pushes a new named route onto the stack and *then* removes all the routes below the new route until the predicate returns true.\n\nThe \"Confirmation -> Home\" example from earlier is a perfect fit for this. If the \"Finish\" button on \"Confirmation\" pushes the \"Home\" route and removes everything until the \"Home\" route is found *again* (the original one at the bottom of the stack).\n\nAssume we have a `ConfirmationScreen` widget and `/confirmation` route:\n\n```dart\n// Inside ConfirmationScreen's ElevatedButton onPressed:\nonPressed: () {\n  // Push the Home screen route and remove everything until we find\n  // the original Home screen route ('/')\n  Navigator.pushNamedAndRemoveUntil(\n    context,\n    '/', // The name of the new route to push\n    ModalRoute.withName('/') // The predicate: stop removing when we find '/'\n  );\n},\n```\n\nIn this scenario:\n\n1.  The stack is `[ /, /list, /detail, /edit, /confirmation ]`.\n2.  `pushNamedAndRemoveUntil` first prepares to push `/`.\n3.  It looks at `/confirmation`. Does it match `ModalRoute.withName('/')`? No. It's marked for removal.\n4.  It looks at `/edit`. Does it match? No. Marked for removal.\n5.  It looks at `/detail`. Does it match? No. Marked for removal.\n6.  It looks at `/list`. Does it match? No. Marked for removal.\n7.  It looks at `/`. Does it match? Yes! The predicate returns true. The process of identifying routes to remove stops.\n8.  The new route (`/`) is pushed, and simultaneously, the routes marked for removal (`/confirmation`, `/edit`, `/detail`, `/list`) are disposed of.\n9.  The stack is now just `[ / ]`.\n\nThis allows you to effectively \"reset\" part of the navigation stack or jump back to a known point while removing everything above it.\n\n## RoutePredicate Under the Hood (Simplified)\n\nA `RoutePredicate` is just a function signature. Looking at the Flutter code (`navigator.dart`):\n\n```dart\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n```\n\nThis tells us it's a function that accepts a `Route<dynamic>` as input and returns a `bool`. `true` means the predicate is satisfied, `false` means it's not.\n\nHow does the `NavigatorState` use this predicate internally? Let's focus on the `popUntil` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified)\nvoid popUntil(RoutePredicate predicate) {\n  assert(!_debugLocked);\n  assert(() { _debugLocked = true; return true; }());\n\n  // Find the last route that is current or has state that handles pops internally.\n  // We stop there.\n  _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  // Iterate backwards through the history\n  // We use candidate.route.willHandlePopInternally to handle routes that\n  // manage their own pop behavior (like nested navigators or forms).\n  // If a route handles pop internally (willHandlePopInternally is true),\n  // we try to pop it internally first (candidate.route.didPop(null)).\n  // If it still satisfies the predicate after internal pop, we stop.\n  // If not, or if it didn't handle it internally, we continue popping.\n  while (candidate != null) {\n    // Check if the current route candidate satisfies the predicate\n    if (predicate(candidate.route)) {\n      assert(() { _debugLocked = false; return true; }());\n      return; // Predicate returned true, stop popping\n    }\n\n    // If the candidate wants to handle pops internally, try that first\n    if (candidate.route.willHandlePopInternally) {\n        // Try to pop internally. If it returns false, it means\n        // it handled something, but doesn't want to be removed from the stack yet.\n        final bool poppedInternally = candidate.route.didPop(null);\n        assert(!poppedInternally); // didPop returning false means it's handled internally\n        // After internal pop, does it *now* satisfy the predicate?\n        if (predicate(candidate.route)) {\n             assert(() { _debugLocked = false; return true; }());\n            return; // Predicate returned true after internal pop, stop\n        }\n        // If it didn't satisfy the predicate even after internal pop,\n        // continue the while loop check\n    } else {\n         // If the route doesn't handle pop internally, just pop it off the stack.\n         pop(); // This calls _history[index of candidate].pop(null) and leads to _flushHistoryUpdates removing it\n    }\n\n    // After potentially popping the current candidate, revisit the list\n    // to find the new top candidate.\n    candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n  }\n\n  // If the loop finishes, it means the predicate never returned true\n  // before the stack was (almost) empty.\n  assert(() { _debugLocked = false; return true; }());\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ScreenBWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant RouteBEntry\n    participant RouteAEntry\n    participant RouteHomeEntry\n\n    User->>ScreenBWidget: Tap \"Go back to Home\"\n    ScreenBWidget->>NavigatorState: Navigator.popUntil(context, predicate = '/' name check)\n    loop Pop Routes\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteBEntry)\n        NavigatorState->>predicate: Call predicate(RouteBEntry.route)\n        predicate->>NavigatorState: Return false ('/screenB' != '/')\n        NavigatorState->>RouteBEntry: route.didPop(null) (starts animation)\n        RouteBEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteBEntry\n        NavigatorState->>Overlay: Remove RouteB's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteAEntry)\n        NavigatorState->>predicate: Call predicate(RouteAEntry.route)\n        predicate->>NavigatorState: Return false ('/screenA' != '/')\n        NavigatorState->>RouteAEntry: route.didPop(null) (starts animation)\n        RouteAEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteAEntry\n        NavigatorState->>Overlay: Remove RouteA's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteHomeEntry)\n        NavigatorState->>predicate: Call predicate(RouteHomeEntry.route)\n        predicate->>NavigatorState: Return true ('/' == '/')\n        NavigatorState->>NavigatorState: Stop popping\n    end\nalt Loop ends before predicate returns true\n        NavigatorState->>NavigatorState: Stack is nearly empty. Stop looping.\nend\n```\n\nThis simplified diagram shows `popUntil` iterating backwards, applying the predicate to each route it encounters (represented by `_RouteEntry.route`), and if the predicate is false, it removes that route before checking the next one. The loop stops *before* removing the route that satisfies the predicate.\n\n## Conclusion\n\nA `RoutePredicate` is a powerful function that allows you to define criteria for selecting routes within the [Navigator's](01_navigator_.md) history stack. This is particularly useful with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear multiple routes efficiently based on their properties, most commonly their name. By using predicates like `ModalRoute.withName`, you can create flexible navigation flows that aren't tied to knowing the exact number of screens in the stack.\n\nNow that we understand how to identify and manage groups of routes using predicates, we'll move on to discuss `RoutePopDisposition`, which determines whether a route *can* be popped and how a pop request should be handled.\n\n[Chapter 6: RoutePopDisposition](06_routepopdisposition_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6: RoutePopDisposition\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6: RoutePopDisposition\n\nWelcome back, aspiring Flutter developers! In our previous chapter, [Chapter 5: RoutePredicate](05_routepredicate_.md), we learned how `RoutePredicate` helps the [Navigator](01_navigator_.md) decide which routes to interact with, especially when using `popUntil` or `pushNamedAndRemoveUntil`.\n\nToday, we're going to look at a concept that's closely related to *whether* a single [Route](02_route_.md) can be popped at all and how it should behave when a pop is attempted: **RoutePopDisposition**.\n\nThink of `RoutePopDisposition` as a rule that a specific screen ([Route](02_route_.md)) sets for itself about how it responds to being asked to close or \"pop.\" It's like a door deciding if it should open when someone tries to go back through it.\n\n## Why do we need RoutePopDisposition?\n\nMost of the time, when you push a new screen, it's expected that hitting the back button or calling `Navigator.pop` will dismiss that screen and take you back. `MaterialPageRoute` (which we used in earlier chapters) provides this behavior automatically.\n\nHowever, there are cases where you might *not* want a screen to be easily dismissed by the back button:\n\n1.  **Forms with unsaved changes:** If a user is filling out a form and accidentally hits the back button, you might want to show a confirmation dialog (\"Discard changes?\") instead of just closing the screen immediately. The screen needs a way to say, \"Hold on, let me handle this pop request first.\"\n2.  **Blocking navigation:** Sometimes, a screen represents a crucial step that the user *must* complete before going back. You might want to completely ignore back button presses until a specific action is taken on that screen.\n3.  **Top-level app exit:** When the very first screen of your app is visible, hitting the back button shouldn't usually navigate *back* within your app (because there's nowhere to go!). Instead, it should allow the operating system (like Android) to handle it, potentially closing the app or sending it to the background.\n\n`RoutePopDisposition` helps a [Route](02_route_.md) communicate its preference for how the [Navigator](01_navigator_.md) should handle a pop request targeted at it.\n\n## Understanding the Options\n\n`RoutePopDisposition` is an `enum` (a set of predefined values) with three possible options:\n\n*   **`RoutePopDisposition.pop`**: This is the default behavior for most routes that aren't the very first one. It means, \"Yes, go ahead and pop me off the stack.\" The [Navigator](01_navigator_.md) will proceed with the standard pop operation (exit animation, disposal, etc.).\n*   **`RoutePopDisposition.doNotPop`**: This means, \"No, don't pop me. Ignore this pop request.\" The [Navigator](01_navigator_.md) will stop the pop process, and the screen will remain visible. This is useful for completely blocking back navigation.\n*   **`RoutePopDisposition.bubble`**: This is the default behavior for the very first route ([Route.isFirst](02_route_.md) is true). It means, \"I can't be popped internally. Pass this pop request up to the next level,\" which is typically the operating system. This allows the system to handle the \"back\" action (e.g., minimizing the app).\n\n## How is RoutePopDisposition Used?\n\nThe [Navigator](01_navigator_.md) checks the `RoutePopDisposition` when the `Navigator.maybePop` method is called. `maybePop` is internally called when the system back button is pressed (on platforms that have one) or when a `PopScope` widget allows a pop. It's the polite way to attempt a pop, giving the current [Route](02_route_.md) a chance to respond. The standard `Navigator.pop` method, however, is an imperative command that bypasses this check and force-pops the route (unless the route has internal pop handling that *does* check the disposition, like `ModalRoute`).\n\n`Route` objects have a getter `popDisposition` (and a deprecated `willPop` future) that return one of these `RoutePopDisposition` values.\n\nLet's create a simple screen that prevents itself from being popped using `doNotPop`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A screen that resists popping!\nclass ResistPopScreen extends ModalRoute<void> {\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300);\n\n  @override\n  bool get opaque => true;\n\n  @override\n  bool get barrierDismissible => false; // Cannot dismiss by tapping barrier\n\n  @override\n  Color get barrierColor => Colors.black54; // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => null;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Material(\n      type: MaterialType.transparency,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.white,\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              const Text(\n                'You cannot pop this screen with the back button!',\n                textAlign: TextAlign.center,\n                style: TextStyle(fontSize: 18),\n              ),\n              const SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: () {\n                  // We use Navigator.pop here, which is an imperative command\n                  // and bypasses the RoutePopDisposition check.\n                  // This button *will* dismiss the screen.\n                  Navigator.pop(context);\n                },\n                child: const Text('Dismiss Anyway (using pop)'),\n              ),\n               ElevatedButton(\n                onPressed: () {\n                  // This tries to maybePop, which will consult\n                  // RoutePopDisposition and be ignored.\n                  Navigator.maybePop(context);\n                },\n                child: const Text('Try to Pop Politely (won\\'t work)'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Override popDisposition to prevent popping via maybePop (like back button)\n  @override\n  RoutePopDisposition get popDisposition {\n      print('ResistPopScreen: Deciding pop disposition...');\n      return RoutePopDisposition.doNotPop;\n  }\n}\n\n// Our HomeScreen to push the ResistPopScreen\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push our ResistPopScreen\n            Navigator.push(context, ResistPopScreen());\n          },\n          child: const Text('Go to Resist Pop Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Add this to your main MaterialApp routes if using named routes,\n// or push it directly as shown above.\n/*\nroutes: {\n  '/': (context) => const HomeScreen(),\n  // We push the route directly in this example, not via named routes.\n  // If you wanted a named route:\n  // '/resistPop': (context) => ResistPopScreen(), // Need a different way to build ModalRoute often\n},\n*/\n```\n\nIn this example:\n\n*   We created a custom [Route](02_route_.md) by extending `ModalRoute`. `ModalRoute`s are good for overlays like dialogs or custom screens that block interaction with the previous screen.\n*   We overrode the `buildPage` method to provide the visual content of our screen (a simple box with text and buttons).\n*   **Crucially**, we overrode the `popDisposition` getter to return `RoutePopDisposition.doNotPop`.\n*   When you run this, navigate to the `ResistPopScreen`. Hitting the system back button (which calls `maybePop`) will do nothing. The `print` statement in `popDisposition` confirms it was checked.\n*   Tapping the \"Try to Pop Politely\" button (which also calls `maybePop`) will also do nothing. The `popDisposition` prevents it.\n*   Tapping the \"Dismiss Anyway (using pop)\" button works because it calls `Navigator.pop`, which is a direct command to the [Navigator](01_navigator_.md) to remove the route, regardless of its `popDisposition`.\n\nThis demonstrates how `doNotPop` gives a route control over whether it responds to \"polite\" pop requests like the system back button.\n\nFor a forms-with-unsaved-changes scenario, you might initially return `RoutePopDisposition.pop` but use a `PopScope` widget (or the older `WillPopScope`) within the route's content. This widget would intercept the pop and show a dialog *before* the route's `popDisposition` is even consulted (or sometimes trigger a change that causes `popDisposition` to become `doNotPop` if necessary).\n\n## RoutePopDisposition Under the Hood (Simplified)\n\nLet's look at where `RoutePopDisposition` is defined and how it's used in the `NavigatorState`.\n\nThe `RoutePopDisposition` enum is simply:\n\n```dart\n/// Indicates whether the current route should be popped.\nenum RoutePopDisposition {\n  /// Pop the route.\n  pop,\n\n  /// Do not pop the route.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  bubble,\n}\n```\n\nThe core logic for using this enum lives in the `NavigatorState.maybePop` method (simplified, focusing on `popDisposition`):\n\n```dart\n// Inside NavigatorState class (simplified maybePop)\n@optionalTypeArgs\nFuture<bool> maybePop<T extends Object?>([T? result]) async {\n  // Find the current top-most route that is \"present\" (visible or animating)\n  final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  if (lastEntry == null) {\n    return false; // Nothing to pop\n  }\n  assert(lastEntry.route._navigator == this);\n\n  // Check the route's pop disposition\n  switch (lastEntry.route.popDisposition) {\n    case RoutePopDisposition.bubble:\n      // Route says let someone else handle it (e.g., OS)\n      return false; // Indicate that *this* navigator didn't handle it\n\n    case RoutePopDisposition.pop:\n      // Route says it's okay to pop.\n      pop(result); // Call our internal pop method\n      return true; // Indicate that we handled the pop\n\n    case RoutePopDisposition.doNotPop:\n      // Route says don't pop it, ignore the request.\n      // We still call onPopInvokedWithResult to notify the route that a pop\n      // was attempted but canceled.\n      lastEntry.route.onPopInvokedWithResult(false, result);\n      return true; // Indicate that we handled the pop (by ignoring it)\n  }\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant OperatingSystem\n    participant NavigatorState\n    participant CurrentRouteEntry\n\n    User->>OperatingSystem: Back button pressed\n    OperatingSystem->>NavigatorState: Call maybePop(null)\n    NavigatorState->>CurrentRouteEntry: Get current route's RoutePopDisposition\n    alt RoutePopDisposition is bubble\n        CurrentRouteEntry->>NavigatorState: Return bubble\n        NavigatorState-->>OperatingSystem: Return false (not handled)\n    else RoutePopDisposition is pop\n        CurrentRouteEntry->>NavigatorState: Return pop\n        NavigatorState->>NavigatorState: Call pop(null)\n         NavigatorState-->>OperatingSystem: Return true (handled)\n    else RoutePopDisposition is doNotPop\n        CurrentRouteEntry->>NavigatorState: Return doNotPop\n        NavigatorState->>CurrentRouteEntry: route.onPopInvokedWithResult(false, null)\n        NavigatorState-->>OperatingSystem: Return true (handled)\n    end\n```\n\nThis simplified flow shows that `maybePop` is the gatekeeper that respects the `RoutePopDisposition`. It gets the disposition from the current route and then follows the rule: return `false` for `bubble` (let the caller handle it, usually means exiting the app scope), or return `true` for `pop` or `doNotPop` (meaning this `Navigator` \"handled\" the request, either by performing the pop or deliberately ignoring it).\n\nRoutes built with `MaterialPageRoute` and `CupertinoPageRoute` automatically implement `popDisposition` to return `bubble` if `isFirst` is true and `pop` otherwise. Custom routes can override this logic to implement behaviors like our `ResistPopScreen`.\n\n## Conclusion\n\n`RoutePopDisposition` is a simple but effective enum that allows individual [Route](02_route_.md)s to control how they respond to requests to be popped, particularly via `Navigator.maybePop` (triggered by system back buttons). By returning `pop`, `doNotPop`, or `bubble`, a route signals its intention, enabling scenarios like preventing accidental data loss or controlling app exit behavior. While `Navigator.pop` provides a way to imperatively dismiss a route, `maybePop` and `RoutePopDisposition` offer a cooperative mechanism for handling navigation changes requested by the system or other widgets like `PopScope`.\n\nIn the next chapter, we'll explore `NavigatorObserver`, which allows you to listen to and react to various navigation events happening within a [Navigator].\n\n[Chapter 7: NavigatorObserver](07_navigatorobserver_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"NavigatorObserver\n\". This is Chapter 7.\n\nConcept Details:\n- Name: NavigatorObserver\n\n- Description:\nA NavigatorObserver is like a spy watching the Navigator's actions. It gets notified whenever something happens to the Navigator's history stack, such as a route being pushed, popped, or replaced. This is useful for tracking navigation events, for logging, or for triggering side effects based on navigation changes.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n---\n# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)\n---\n# Chapter 5: RoutePredicate\n\nWelcome back, future Flutter navigators! In our previous chapters, we explored the [Navigator](01_navigator_.md) (the screen manager), the [Route](02_route_.md) (the screen recipe), [RouteSettings](03_routesettings_.md) (names and arguments), and the [Page](04_page_.md) (a blueprint for routes).\n\nToday, we're looking at another useful tool in the Navigator's kit: the **RoutePredicate**. While `push` adds routes and `pop` removes the top one, sometimes you need more control over *which* routes get removed from the stack. That's where a `RoutePredicate` comes in!\n\n## What is a RoutePredicate?\n\nA `RoutePredicate` is essentially a **function** that helps the [Navigator](01_navigator_.md) decide if a specific [Route](02_route_.md) meets certain criteria. Think of it like a filter or a test you can apply to each [Route](02_route_.md) in the [Navigator's](01_navigator_.md) history stack.\n\nThe [Navigator](01_navigator_.md) can use these predicates with methods like `popUntil` and `pushNamedAndRemoveUntil` to perform actions on multiple routes until a route that matches the predicate is found.\n\n## The Use Case: Clearing Navigation History\n\nImagine you have an app with a navigation flow like this:\n\nHome -> List -> Detail -> Edit -> Confirmation -> Home\n\nIf you are on the \"Confirmation\" screen and tap a button that says \"Finish,\" you probably want to go all the way back to the \"Home\" screen, removing \"Confirmation,\" \"Edit,\" and \"Detail\" from the history.\n\nUsing just `pop` wouldn't work easily; you'd have to call `pop` three times, only if you knew exactly how many screens were above the Home screen. This isn't flexible.\n\nA `RoutePredicate` allows you to say, \"Keep popping routes off the stack *until* you find the 'Home' route.\"\n\n## Using RoutePredicate with `popUntil`\n\nThe primary method where you'll use a `RoutePredicate` is `Navigator.popUntil`. This method traverses backwards through the [Navigator's](01_navigator_.md) history stack and pops routes until the provided predicate returns `true` for a route. The route that satisfies the predicate is *not* popped itself.\n\nLet's set up a simple example to demonstrate this. We'll have three screens: Home, Screen A, and Screen B. We'll navigate from Home -> Screen A -> Screen B, and then use `popUntil` from Screen B to go back to Home.\n\nFirst, let's define our screens with unique names in their `RouteSettings`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenA');\n          },\n          child: const Text('Go to Screen A'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Screen A\nclass ScreenA extends StatelessWidget {\n  const ScreenA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen A')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenB');\n          },\n          child: const Text('Go to Screen B'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 3: Screen B\nclass ScreenB extends StatelessWidget {\n  const ScreenB({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen B')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This is where we use popUntil!\n            Navigator.popUntil(context, (route) {\n              // Our predicate: check if the route is the Home Screen route ('/')\n              return route.settings.name == '/';\n            });\n          },\n          child: const Text('Go back to Home'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nNow, let's set up our `MaterialApp` with named routes:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Assuming screens.dart contains the screen widgets above\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Pop Until Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/screenA': (context) => const ScreenA(),\n      '/screenB': (context) => const ScreenB(),\n    },\n  ));\n}\n```\n\nIn this example:\n\n1.  We start on `/` (HomeScreen).\n2.  Tapping the button on `HomeScreen` pushes `/screenA`.\n3.  Tapping the button on `ScreenA` pushes `/screenB`.\n4.  Now the navigation stack is conceptually `[/, /screenA, /screenB]`.\n5.  On `ScreenB`, when the button is tapped, `Navigator.popUntil(context, (route) { return route.settings.name == '/'; });` is called.\n6.  The [Navigator](01_navigator_.md) looks at `/screenB`. Does its name equal '/'? No. It is popped.\n7.  The [Navigator](01_navigator_.md) looks at `/screenA`. Does its name equal '/'? No. It is popped.\n8.  The [Navigator](01_navigator_.md) looks at `/`. Does its name equal '/'? Yes! The predicate returns true. The popping stops.\n9.  The user is now back on the `HomeScreen`.\n\nThe `RoutePredicate` itself is this part:\n\n```dart\n(route) {\n  return route.settings.name == '/';\n}\n```\n\nIt's a function that takes one argument: a `Route<dynamic>` object. Inside the function, we check if the `settings.name` of that route is equal to '/'.\n\n## Common RoutePredicates\n\nWhile you can write any predicate function you need, Flutter provides some handy ones:\n\n*   **`(Route<dynamic> route) => false`**: This predicate always returns false. If used with `popUntil`, it would pop *all* routes until the last one (which won't be popped). If used with `pushNamedAndRemoveUntil`, it would remove *all* routes currently in the stack before pushing the new one.\n*   **`ModalRoute.withName('/someName')`**: This is a very common predicate. It returns a function that checks if a route is a `ModalRoute` (which most full-screen routes are) and if its `settings.name` matches the provided string. This is exactly what we used in our example with `ModalRoute.withName('/')`.\n\nLet's rewrite our `ScreenB` code using `ModalRoute.withName`:\n\n```dart\n// Inside Screen B's ElevatedButton onPressed:\nonPressed: () {\n  Navigator.popUntil(context, ModalRoute.withName('/'));\n},\n```\n\nThis is functionally identical to our previous code and is more concise. `ModalRoute.withName('/')` *returns* the predicate function we need.\n\n## Using RoutePredicate with `pushNamedAndRemoveUntil`\n\nAnother method that uses `RoutePredicate` is `Navigator.pushNamedAndRemoveUntil`. This method first pushes a new named route onto the stack and *then* removes all the routes below the new route until the predicate returns true.\n\nThe \"Confirmation -> Home\" example from earlier is a perfect fit for this. If the \"Finish\" button on \"Confirmation\" pushes the \"Home\" route and removes everything until the \"Home\" route is found *again* (the original one at the bottom of the stack).\n\nAssume we have a `ConfirmationScreen` widget and `/confirmation` route:\n\n```dart\n// Inside ConfirmationScreen's ElevatedButton onPressed:\nonPressed: () {\n  // Push the Home screen route and remove everything until we find\n  // the original Home screen route ('/')\n  Navigator.pushNamedAndRemoveUntil(\n    context,\n    '/', // The name of the new route to push\n    ModalRoute.withName('/') // The predicate: stop removing when we find '/'\n  );\n},\n```\n\nIn this scenario:\n\n1.  The stack is `[ /, /list, /detail, /edit, /confirmation ]`.\n2.  `pushNamedAndRemoveUntil` first prepares to push `/`.\n3.  It looks at `/confirmation`. Does it match `ModalRoute.withName('/')`? No. It's marked for removal.\n4.  It looks at `/edit`. Does it match? No. Marked for removal.\n5.  It looks at `/detail`. Does it match? No. Marked for removal.\n6.  It looks at `/list`. Does it match? No. Marked for removal.\n7.  It looks at `/`. Does it match? Yes! The predicate returns true. The process of identifying routes to remove stops.\n8.  The new route (`/`) is pushed, and simultaneously, the routes marked for removal (`/confirmation`, `/edit`, `/detail`, `/list`) are disposed of.\n9.  The stack is now just `[ / ]`.\n\nThis allows you to effectively \"reset\" part of the navigation stack or jump back to a known point while removing everything above it.\n\n## RoutePredicate Under the Hood (Simplified)\n\nA `RoutePredicate` is just a function signature. Looking at the Flutter code (`navigator.dart`):\n\n```dart\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n```\n\nThis tells us it's a function that accepts a `Route<dynamic>` as input and returns a `bool`. `true` means the predicate is satisfied, `false` means it's not.\n\nHow does the `NavigatorState` use this predicate internally? Let's focus on the `popUntil` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified)\nvoid popUntil(RoutePredicate predicate) {\n  assert(!_debugLocked);\n  assert(() { _debugLocked = true; return true; }());\n\n  // Find the last route that is current or has state that handles pops internally.\n  // We stop there.\n  _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  // Iterate backwards through the history\n  // We use candidate.route.willHandlePopInternally to handle routes that\n  // manage their own pop behavior (like nested navigators or forms).\n  // If a route handles pop internally (willHandlePopInternally is true),\n  // we try to pop it internally first (candidate.route.didPop(null)).\n  // If it still satisfies the predicate after internal pop, we stop.\n  // If not, or if it didn't handle it internally, we continue popping.\n  while (candidate != null) {\n    // Check if the current route candidate satisfies the predicate\n    if (predicate(candidate.route)) {\n      assert(() { _debugLocked = false; return true; }());\n      return; // Predicate returned true, stop popping\n    }\n\n    // If the candidate wants to handle pops internally, try that first\n    if (candidate.route.willHandlePopInternally) {\n        // Try to pop internally. If it returns false, it means\n        // it handled something, but doesn't want to be removed from the stack yet.\n        final bool poppedInternally = candidate.route.didPop(null);\n        assert(!poppedInternally); // didPop returning false means it's handled internally\n        // After internal pop, does it *now* satisfy the predicate?\n        if (predicate(candidate.route)) {\n             assert(() { _debugLocked = false; return true; }());\n            return; // Predicate returned true after internal pop, stop\n        }\n        // If it didn't satisfy the predicate even after internal pop,\n        // continue the while loop check\n    } else {\n         // If the route doesn't handle pop internally, just pop it off the stack.\n         pop(); // This calls _history[index of candidate].pop(null) and leads to _flushHistoryUpdates removing it\n    }\n\n    // After potentially popping the current candidate, revisit the list\n    // to find the new top candidate.\n    candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n  }\n\n  // If the loop finishes, it means the predicate never returned true\n  // before the stack was (almost) empty.\n  assert(() { _debugLocked = false; return true; }());\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ScreenBWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant RouteBEntry\n    participant RouteAEntry\n    participant RouteHomeEntry\n\n    User->>ScreenBWidget: Tap \"Go back to Home\"\n    ScreenBWidget->>NavigatorState: Navigator.popUntil(context, predicate = '/' name check)\n    loop Pop Routes\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteBEntry)\n        NavigatorState->>predicate: Call predicate(RouteBEntry.route)\n        predicate->>NavigatorState: Return false ('/screenB' != '/')\n        NavigatorState->>RouteBEntry: route.didPop(null) (starts animation)\n        RouteBEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteBEntry\n        NavigatorState->>Overlay: Remove RouteB's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteAEntry)\n        NavigatorState->>predicate: Call predicate(RouteAEntry.route)\n        predicate->>NavigatorState: Return false ('/screenA' != '/')\n        NavigatorState->>RouteAEntry: route.didPop(null) (starts animation)\n        RouteAEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteAEntry\n        NavigatorState->>Overlay: Remove RouteA's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteHomeEntry)\n        NavigatorState->>predicate: Call predicate(RouteHomeEntry.route)\n        predicate->>NavigatorState: Return true ('/' == '/')\n        NavigatorState->>NavigatorState: Stop popping\n    end\nalt Loop ends before predicate returns true\n        NavigatorState->>NavigatorState: Stack is nearly empty. Stop looping.\nend\n```\n\nThis simplified diagram shows `popUntil` iterating backwards, applying the predicate to each route it encounters (represented by `_RouteEntry.route`), and if the predicate is false, it removes that route before checking the next one. The loop stops *before* removing the route that satisfies the predicate.\n\n## Conclusion\n\nA `RoutePredicate` is a powerful function that allows you to define criteria for selecting routes within the [Navigator's](01_navigator_.md) history stack. This is particularly useful with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear multiple routes efficiently based on their properties, most commonly their name. By using predicates like `ModalRoute.withName`, you can create flexible navigation flows that aren't tied to knowing the exact number of screens in the stack.\n\nNow that we understand how to identify and manage groups of routes using predicates, we'll move on to discuss `RoutePopDisposition`, which determines whether a route *can* be popped and how a pop request should be handled.\n\n[Chapter 6: RoutePopDisposition](06_routepopdisposition_.md)\n---\n# Chapter 6: RoutePopDisposition\n\nWelcome back, aspiring Flutter developers! In our previous chapter, [Chapter 5: RoutePredicate](05_routepredicate_.md), we learned how `RoutePredicate` helps the [Navigator](01_navigator_.md) decide which routes to interact with, especially when using `popUntil` or `pushNamedAndRemoveUntil`.\n\nToday, we're going to look at a concept that's closely related to *whether* a single [Route](02_route_.md) can be popped at all and how it should behave when a pop is attempted: **RoutePopDisposition**.\n\nThink of `RoutePopDisposition` as a rule that a specific screen ([Route](02_route_.md)) sets for itself about how it responds to being asked to close or \"pop.\" It's like a door deciding if it should open when someone tries to go back through it.\n\n## Why do we need RoutePopDisposition?\n\nMost of the time, when you push a new screen, it's expected that hitting the back button or calling `Navigator.pop` will dismiss that screen and take you back. `MaterialPageRoute` (which we used in earlier chapters) provides this behavior automatically.\n\nHowever, there are cases where you might *not* want a screen to be easily dismissed by the back button:\n\n1.  **Forms with unsaved changes:** If a user is filling out a form and accidentally hits the back button, you might want to show a confirmation dialog (\"Discard changes?\") instead of just closing the screen immediately. The screen needs a way to say, \"Hold on, let me handle this pop request first.\"\n2.  **Blocking navigation:** Sometimes, a screen represents a crucial step that the user *must* complete before going back. You might want to completely ignore back button presses until a specific action is taken on that screen.\n3.  **Top-level app exit:** When the very first screen of your app is visible, hitting the back button shouldn't usually navigate *back* within your app (because there's nowhere to go!). Instead, it should allow the operating system (like Android) to handle it, potentially closing the app or sending it to the background.\n\n`RoutePopDisposition` helps a [Route](02_route_.md) communicate its preference for how the [Navigator](01_navigator_.md) should handle a pop request targeted at it.\n\n## Understanding the Options\n\n`RoutePopDisposition` is an `enum` (a set of predefined values) with three possible options:\n\n*   **`RoutePopDisposition.pop`**: This is the default behavior for most routes that aren't the very first one. It means, \"Yes, go ahead and pop me off the stack.\" The [Navigator](01_navigator_.md) will proceed with the standard pop operation (exit animation, disposal, etc.).\n*   **`RoutePopDisposition.doNotPop`**: This means, \"No, don't pop me. Ignore this pop request.\" The [Navigator](01_navigator_.md) will stop the pop process, and the screen will remain visible. This is useful for completely blocking back navigation.\n*   **`RoutePopDisposition.bubble`**: This is the default behavior for the very first route ([Route.isFirst](02_route_.md) is true). It means, \"I can't be popped internally. Pass this pop request up to the next level,\" which is typically the operating system. This allows the system to handle the \"back\" action (e.g., minimizing the app).\n\n## How is RoutePopDisposition Used?\n\nThe [Navigator](01_navigator_.md) checks the `RoutePopDisposition` when the `Navigator.maybePop` method is called. `maybePop` is internally called when the system back button is pressed (on platforms that have one) or when a `PopScope` widget allows a pop. It's the polite way to attempt a pop, giving the current [Route](02_route_.md) a chance to respond. The standard `Navigator.pop` method, however, is an imperative command that bypasses this check and force-pops the route (unless the route has internal pop handling that *does* check the disposition, like `ModalRoute`).\n\n`Route` objects have a getter `popDisposition` (and a deprecated `willPop` future) that return one of these `RoutePopDisposition` values.\n\nLet's create a simple screen that prevents itself from being popped using `doNotPop`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A screen that resists popping!\nclass ResistPopScreen extends ModalRoute<void> {\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300);\n\n  @override\n  bool get opaque => true;\n\n  @override\n  bool get barrierDismissible => false; // Cannot dismiss by tapping barrier\n\n  @override\n  Color get barrierColor => Colors.black54; // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => null;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Material(\n      type: MaterialType.transparency,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.white,\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              const Text(\n                'You cannot pop this screen with the back button!',\n                textAlign: TextAlign.center,\n                style: TextStyle(fontSize: 18),\n              ),\n              const SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: () {\n                  // We use Navigator.pop here, which is an imperative command\n                  // and bypasses the RoutePopDisposition check.\n                  // This button *will* dismiss the screen.\n                  Navigator.pop(context);\n                },\n                child: const Text('Dismiss Anyway (using pop)'),\n              ),\n               ElevatedButton(\n                onPressed: () {\n                  // This tries to maybePop, which will consult\n                  // RoutePopDisposition and be ignored.\n                  Navigator.maybePop(context);\n                },\n                child: const Text('Try to Pop Politely (won\\'t work)'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Override popDisposition to prevent popping via maybePop (like back button)\n  @override\n  RoutePopDisposition get popDisposition {\n      print('ResistPopScreen: Deciding pop disposition...');\n      return RoutePopDisposition.doNotPop;\n  }\n}\n\n// Our HomeScreen to push the ResistPopScreen\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push our ResistPopScreen\n            Navigator.push(context, ResistPopScreen());\n          },\n          child: const Text('Go to Resist Pop Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Add this to your main MaterialApp routes if using named routes,\n// or push it directly as shown above.\n/*\nroutes: {\n  '/': (context) => const HomeScreen(),\n  // We push the route directly in this example, not via named routes.\n  // If you wanted a named route:\n  // '/resistPop': (context) => ResistPopScreen(), // Need a different way to build ModalRoute often\n},\n*/\n```\n\nIn this example:\n\n*   We created a custom [Route](02_route_.md) by extending `ModalRoute`. `ModalRoute`s are good for overlays like dialogs or custom screens that block interaction with the previous screen.\n*   We overrode the `buildPage` method to provide the visual content of our screen (a simple box with text and buttons).\n*   **Crucially**, we overrode the `popDisposition` getter to return `RoutePopDisposition.doNotPop`.\n*   When you run this, navigate to the `ResistPopScreen`. Hitting the system back button (which calls `maybePop`) will do nothing. The `print` statement in `popDisposition` confirms it was checked.\n*   Tapping the \"Try to Pop Politely\" button (which also calls `maybePop`) will also do nothing. The `popDisposition` prevents it.\n*   Tapping the \"Dismiss Anyway (using pop)\" button works because it calls `Navigator.pop`, which is a direct command to the [Navigator](01_navigator_.md) to remove the route, regardless of its `popDisposition`.\n\nThis demonstrates how `doNotPop` gives a route control over whether it responds to \"polite\" pop requests like the system back button.\n\nFor a forms-with-unsaved-changes scenario, you might initially return `RoutePopDisposition.pop` but use a `PopScope` widget (or the older `WillPopScope`) within the route's content. This widget would intercept the pop and show a dialog *before* the route's `popDisposition` is even consulted (or sometimes trigger a change that causes `popDisposition` to become `doNotPop` if necessary).\n\n## RoutePopDisposition Under the Hood (Simplified)\n\nLet's look at where `RoutePopDisposition` is defined and how it's used in the `NavigatorState`.\n\nThe `RoutePopDisposition` enum is simply:\n\n```dart\n/// Indicates whether the current route should be popped.\nenum RoutePopDisposition {\n  /// Pop the route.\n  pop,\n\n  /// Do not pop the route.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  bubble,\n}\n```\n\nThe core logic for using this enum lives in the `NavigatorState.maybePop` method (simplified, focusing on `popDisposition`):\n\n```dart\n// Inside NavigatorState class (simplified maybePop)\n@optionalTypeArgs\nFuture<bool> maybePop<T extends Object?>([T? result]) async {\n  // Find the current top-most route that is \"present\" (visible or animating)\n  final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  if (lastEntry == null) {\n    return false; // Nothing to pop\n  }\n  assert(lastEntry.route._navigator == this);\n\n  // Check the route's pop disposition\n  switch (lastEntry.route.popDisposition) {\n    case RoutePopDisposition.bubble:\n      // Route says let someone else handle it (e.g., OS)\n      return false; // Indicate that *this* navigator didn't handle it\n\n    case RoutePopDisposition.pop:\n      // Route says it's okay to pop.\n      pop(result); // Call our internal pop method\n      return true; // Indicate that we handled the pop\n\n    case RoutePopDisposition.doNotPop:\n      // Route says don't pop it, ignore the request.\n      // We still call onPopInvokedWithResult to notify the route that a pop\n      // was attempted but canceled.\n      lastEntry.route.onPopInvokedWithResult(false, result);\n      return true; // Indicate that we handled the pop (by ignoring it)\n  }\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant OperatingSystem\n    participant NavigatorState\n    participant CurrentRouteEntry\n\n    User->>OperatingSystem: Back button pressed\n    OperatingSystem->>NavigatorState: Call maybePop(null)\n    NavigatorState->>CurrentRouteEntry: Get current route's RoutePopDisposition\n    alt RoutePopDisposition is bubble\n        CurrentRouteEntry->>NavigatorState: Return bubble\n        NavigatorState-->>OperatingSystem: Return false (not handled)\n    else RoutePopDisposition is pop\n        CurrentRouteEntry->>NavigatorState: Return pop\n        NavigatorState->>NavigatorState: Call pop(null)\n         NavigatorState-->>OperatingSystem: Return true (handled)\n    else RoutePopDisposition is doNotPop\n        CurrentRouteEntry->>NavigatorState: Return doNotPop\n        NavigatorState->>CurrentRouteEntry: route.onPopInvokedWithResult(false, null)\n        NavigatorState-->>OperatingSystem: Return true (handled)\n    end\n```\n\nThis simplified flow shows that `maybePop` is the gatekeeper that respects the `RoutePopDisposition`. It gets the disposition from the current route and then follows the rule: return `false` for `bubble` (let the caller handle it, usually means exiting the app scope), or return `true` for `pop` or `doNotPop` (meaning this `Navigator` \"handled\" the request, either by performing the pop or deliberately ignoring it).\n\nRoutes built with `MaterialPageRoute` and `CupertinoPageRoute` automatically implement `popDisposition` to return `bubble` if `isFirst` is true and `pop` otherwise. Custom routes can override this logic to implement behaviors like our `ResistPopScreen`.\n\n## Conclusion\n\n`RoutePopDisposition` is a simple but effective enum that allows individual [Route](02_route_.md)s to control how they respond to requests to be popped, particularly via `Navigator.maybePop` (triggered by system back buttons). By returning `pop`, `doNotPop`, or `bubble`, a route signals its intention, enabling scenarios like preventing accidental data loss or controlling app exit behavior. While `Navigator.pop` provides a way to imperatively dismiss a route, `maybePop` and `RoutePopDisposition` offer a cooperative mechanism for handling navigation changes requested by the system or other widgets like `PopScope`.\n\nIn the next chapter, we'll explore `NavigatorObserver`, which allows you to listen to and react to various navigation events happening within a [Navigator].\n\n[Chapter 7: NavigatorObserver](07_navigatorobserver_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7: NavigatorObserver\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7: NavigatorObserver\n\nWelcome back, Flutter enthusiasts! In our journey through Flutter navigation, we've learned about the [Navigator](01_navigator_.md) managing the route stack, [Route](02_route_.md)s as screen recipes, [RouteSettings](03_routesettings_.md) for details, [Page](04_page_.md)s for declarative navigation, [RoutePredicate](05_routepredicate_.md)s for advanced route selection, and [RoutePopDisposition](06_routepopdisposition_.md) for controlling pop behavior.\n\nToday, we're adding a tool that lets us *watch* all of this navigation magic happen: the **NavigatorObserver**.\n\nThink of a **NavigatorObserver** as a silent spy or a detective that keeps an eye on everything the [Navigator](01_navigator_.md) is doing. Whenever a route is pushed, popped, replaced, or even removed, the `NavigatorObserver` gets a notification.\n\n## Why do we need a NavigatorObserver?\n\nWhy would you want to watch the [Navigator](01_navigator_.md)? Here are a few common reasons:\n\n1.  **Logging:** You might want to track which screens the user visits and in what order for analytics or debugging. A `NavigatorObserver` can simply print a message every time a route changes.\n2.  **Analytics:** Similar to logging, you can send navigation events to an analytics service (like Google Analytics or Firebase Analytics) to understand user flow within your app.\n3.  **External Updates:** Maybe some part of your app needs to react whenever a specific screen is shown or dismissed. An observer can trigger actions outside of the screen itself.\n4.  **Custom Behaviors:** In advanced scenarios, you might use an observer to implement custom global behaviors related to navigation, like managing certain background tasks.\n\nThe core idea is that the `NavigatorObserver` allows you to react *globally* to changes in the [Navigator's](01_navigator_.md) state without needing to add logic to *every single screen's* navigation calls (`push`, `pop`, etc.).\n\n## Using NavigatorObserver to Log Navigation Events\n\nLet's dive into our main use case: logging every time a screen is pushed or popped.\n\nTo use a `NavigatorObserver`, you need to:\n\n1.  Create a class that extends `NavigatorObserver`.\n2.  Override the methods that correspond to the events you want to listen to (like `didPush` and `didPop`).\n3.  Provide an instance of your observer class to the `observers` list of your `Navigator` (or usually, your `MaterialApp` or `WidgetsApp`, which creates the main [Navigator]).\n\nHere's our simple logging observer:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Our custom observer that extends NavigatorObserver\nclass MyNavigatorObserver extends NavigatorObserver {\n  // Called when a route is pushed (a new screen is added)\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Pushed route: ${route.settings.name}');\n    print('NavigatorObserver: Previous route: ${previousRoute?.settings.name}');\n  }\n\n  // Called when a route is popped (a screen is removed)\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Popped route: ${route.settings.name}');\n    print('NavigatorObserver: New current route: ${previousRoute?.settings.name}');\n  }\n\n  // You can override other methods too, like didReplace, didRemove, etc.\n}\n```\n\nThis class is pretty straightforward. It just overrides `didPush` and `didPop` to print messages showing the name of the route involved in the event and the route below it.\n\nNow, let's integrate this into our simple navigation setup with a Home Screen and Second Screen using named routes, similar to what we did in [Chapter 3: RouteSettings](03_routesettings_.md).\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Second Screen\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Second Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd here's how we provide our observer to the `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Contains HomeScreen and SecondScreen\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Create an instance of our observer\nfinal MyNavigatorObserver myObserver = MyNavigatorObserver();\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Navigator Observer Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/secondScreen': (context) => const SecondScreen(),\n    },\n    // Provide our observer here!\n    observers: [\n      myObserver, // Add our observer to the list\n    ],\n  ));\n}\n```\n\nWhen you run this code and navigate between the screens, you'll see the `print` statements from `MyNavigatorObserver` appear in your console every time a `push` or `pop` happens.\n\n**Expected Console Output (walking through the simple flow):**\n\n1.  App starts (HomeScreen is the initial route, often added without a `push` notification by default setup): No observer notification yet.\n2.  Tap \"Go to Second Screen\" button:\n    ```\n    NavigatorObserver: Pushed route: /secondScreen\n    NavigatorObserver: Previous route: /\n    ```\n3.  Tap \"Go Back!\" button:\n    ```\n    NavigatorObserver: Popped route: /secondScreen\n    NavigatorObserver: New current route: /\n    ```\n\nThis is a minimal example, but it shows the power of listening to navigation events centrally.\n\n## Other Methods to Observe\n\nBesides `didPush` and `didPop`, `NavigatorObserver` also offers other methods you can override:\n\n*   `didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute})`: Called when one route is replaced by another (e.g., using `Navigator.pushReplacement`).\n*   `didRemove(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a route is removed from the stack without being popped (e.g., using `Navigator.removeRoute`).\n*   `didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute)`: Called whenever the top-most route on the navigator changes, regardless of how it changed (push, pop, replace affecting top).\n*   `didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a user starts a gesture associated with navigation (like the iOS back swipe).\n*   `didStopUserGesture()`: Called when a user gesture associated with navigation ends.\n\nOverriding these methods lets your observer react to the full spectrum of navigation changes.\n\n## NavigatorObserver Under the Hood (Simplified)\n\nHow does the `NavigatorObserver` get its notifications?\n\nThe `NavigatorState` (the actual state object that manages the routes, discussed in [Chapter 1: Navigator](01_navigator_.md)) holds a list of `NavigatorObserver` instances provided to it via the `Navigator` widget's `observers` property. Whenever the `NavigatorState` performs a navigation operation (like adding or removing a route from its internal stack), it iterates through its list of observers and calls the corresponding notification method on each one.\n\nImagine the `NavigatorState`'s `push` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified push)\n@optionalTypeArgs\nFuture<T?> push<T extends Object?>(Route<T> route) {\n  // ... (internal logic to add route entry to _history) ...\n\n  // After the internal state is updated...\n  // Notify observers about the push event!\n  // _effectiveObservers is the list of observers including the hero controller\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPush(route, previousRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic, animations, etc.) ...\n\n  return route.popped; // Return the future\n}\n```\n\nSimilarly, the `pop` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified pop)\n@optionalTypeArgs\nvoid pop<T extends Object?>([T? result]) {\n  // ... (internal logic to remove route entry from _history) ...\n\n  // After the internal state changes...\n  // Notify observers about the pop event!\n  // _effectiveObservers is the list of observers\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPop(poppedRoute, newTopRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic) ...\n}\n```\n\nAnd how about our logging example flow with the observer?\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MyNavigatorObserver\n    participant SecondScreenRoute\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/secondScreen')\n    NavigatorState->>NavigatorState: Look up route for /secondScreen\n    NavigatorState->>SecondScreenRoute: Create route for /secondScreen\n    NavigatorState->>NavigatorState: Add SecondScreenRoute to _history\n    NavigatorState->>MyNavigatorObserver: observer.didPush(SecondScreenRoute, HomeScreenRoute)\n    MyNavigatorObserver->>Console: Print \"Pushed route: /secondScreen\", etc.\n    NavigatorState->>Overlay: Display SecondScreenRoute content\n```\n\nThis simple diagram shows that when `Navigator.pushNamed` (which internally calls the `push` method in `NavigatorState`) is executed, the `NavigatorState` makes a call to the `didPush` method on your `MyNavigatorObserver` instance, allowing it to react to the event.\n\n## Conclusion\n\nThe `NavigatorObserver` is a powerful, yet simple abstraction that allows you to listen to and react to events happening within a [Navigator]. By creating a custom observer and providing it to your application's main [Navigator], you can centralize logic for tasks like logging, analytics, or triggering side effects based on navigation changes. It provides a clean way to decouple these global concerns from the individual screen widgets and navigation calls.\n\nIn the next chapter, we'll explore another advanced concept for customizing behavior within the [Navigator]: the `TransitionDelegate`, which influences how pages animate when the `Navigator.pages` list changes.\n\n[Chapter 8: TransitionDelegate](08_transitiondelegate_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"TransitionDelegate\n\". This is Chapter 8.\n\nConcept Details:\n- Name: TransitionDelegate\n\n- Description:\nThe TransitionDelegate is the decision-maker for how Pages animate when entering or exiting the screen. When you update the list of Pages, the Navigator consults the TransitionDelegate to figure out which Pages should animate (push, pop) and which should just appear or disappear without animation (add, remove, complete).\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n---\n# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)\n---\n# Chapter 5: RoutePredicate\n\nWelcome back, future Flutter navigators! In our previous chapters, we explored the [Navigator](01_navigator_.md) (the screen manager), the [Route](02_route_.md) (the screen recipe), [RouteSettings](03_routesettings_.md) (names and arguments), and the [Page](04_page_.md) (a blueprint for routes).\n\nToday, we're looking at another useful tool in the Navigator's kit: the **RoutePredicate**. While `push` adds routes and `pop` removes the top one, sometimes you need more control over *which* routes get removed from the stack. That's where a `RoutePredicate` comes in!\n\n## What is a RoutePredicate?\n\nA `RoutePredicate` is essentially a **function** that helps the [Navigator](01_navigator_.md) decide if a specific [Route](02_route_.md) meets certain criteria. Think of it like a filter or a test you can apply to each [Route](02_route_.md) in the [Navigator's](01_navigator_.md) history stack.\n\nThe [Navigator](01_navigator_.md) can use these predicates with methods like `popUntil` and `pushNamedAndRemoveUntil` to perform actions on multiple routes until a route that matches the predicate is found.\n\n## The Use Case: Clearing Navigation History\n\nImagine you have an app with a navigation flow like this:\n\nHome -> List -> Detail -> Edit -> Confirmation -> Home\n\nIf you are on the \"Confirmation\" screen and tap a button that says \"Finish,\" you probably want to go all the way back to the \"Home\" screen, removing \"Confirmation,\" \"Edit,\" and \"Detail\" from the history.\n\nUsing just `pop` wouldn't work easily; you'd have to call `pop` three times, only if you knew exactly how many screens were above the Home screen. This isn't flexible.\n\nA `RoutePredicate` allows you to say, \"Keep popping routes off the stack *until* you find the 'Home' route.\"\n\n## Using RoutePredicate with `popUntil`\n\nThe primary method where you'll use a `RoutePredicate` is `Navigator.popUntil`. This method traverses backwards through the [Navigator's](01_navigator_.md) history stack and pops routes until the provided predicate returns `true` for a route. The route that satisfies the predicate is *not* popped itself.\n\nLet's set up a simple example to demonstrate this. We'll have three screens: Home, Screen A, and Screen B. We'll navigate from Home -> Screen A -> Screen B, and then use `popUntil` from Screen B to go back to Home.\n\nFirst, let's define our screens with unique names in their `RouteSettings`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenA');\n          },\n          child: const Text('Go to Screen A'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Screen A\nclass ScreenA extends StatelessWidget {\n  const ScreenA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen A')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenB');\n          },\n          child: const Text('Go to Screen B'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 3: Screen B\nclass ScreenB extends StatelessWidget {\n  const ScreenB({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen B')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This is where we use popUntil!\n            Navigator.popUntil(context, (route) {\n              // Our predicate: check if the route is the Home Screen route ('/')\n              return route.settings.name == '/';\n            });\n          },\n          child: const Text('Go back to Home'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nNow, let's set up our `MaterialApp` with named routes:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Assuming screens.dart contains the screen widgets above\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Pop Until Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/screenA': (context) => const ScreenA(),\n      '/screenB': (context) => const ScreenB(),\n    },\n  ));\n}\n```\n\nIn this example:\n\n1.  We start on `/` (HomeScreen).\n2.  Tapping the button on `HomeScreen` pushes `/screenA`.\n3.  Tapping the button on `ScreenA` pushes `/screenB`.\n4.  Now the navigation stack is conceptually `[/, /screenA, /screenB]`.\n5.  On `ScreenB`, when the button is tapped, `Navigator.popUntil(context, (route) { return route.settings.name == '/'; });` is called.\n6.  The [Navigator](01_navigator_.md) looks at `/screenB`. Does its name equal '/'? No. It is popped.\n7.  The [Navigator](01_navigator_.md) looks at `/screenA`. Does its name equal '/'? No. It is popped.\n8.  The [Navigator](01_navigator_.md) looks at `/`. Does its name equal '/'? Yes! The predicate returns true. The popping stops.\n9.  The user is now back on the `HomeScreen`.\n\nThe `RoutePredicate` itself is this part:\n\n```dart\n(route) {\n  return route.settings.name == '/';\n}\n```\n\nIt's a function that takes one argument: a `Route<dynamic>` object. Inside the function, we check if the `settings.name` of that route is equal to '/'.\n\n## Common RoutePredicates\n\nWhile you can write any predicate function you need, Flutter provides some handy ones:\n\n*   **`(Route<dynamic> route) => false`**: This predicate always returns false. If used with `popUntil`, it would pop *all* routes until the last one (which won't be popped). If used with `pushNamedAndRemoveUntil`, it would remove *all* routes currently in the stack before pushing the new one.\n*   **`ModalRoute.withName('/someName')`**: This is a very common predicate. It returns a function that checks if a route is a `ModalRoute` (which most full-screen routes are) and if its `settings.name` matches the provided string. This is exactly what we used in our example with `ModalRoute.withName('/')`.\n\nLet's rewrite our `ScreenB` code using `ModalRoute.withName`:\n\n```dart\n// Inside Screen B's ElevatedButton onPressed:\nonPressed: () {\n  Navigator.popUntil(context, ModalRoute.withName('/'));\n},\n```\n\nThis is functionally identical to our previous code and is more concise. `ModalRoute.withName('/')` *returns* the predicate function we need.\n\n## Using RoutePredicate with `pushNamedAndRemoveUntil`\n\nAnother method that uses `RoutePredicate` is `Navigator.pushNamedAndRemoveUntil`. This method first pushes a new named route onto the stack and *then* removes all the routes below the new route until the predicate returns true.\n\nThe \"Confirmation -> Home\" example from earlier is a perfect fit for this. If the \"Finish\" button on \"Confirmation\" pushes the \"Home\" route and removes everything until the \"Home\" route is found *again* (the original one at the bottom of the stack).\n\nAssume we have a `ConfirmationScreen` widget and `/confirmation` route:\n\n```dart\n// Inside ConfirmationScreen's ElevatedButton onPressed:\nonPressed: () {\n  // Push the Home screen route and remove everything until we find\n  // the original Home screen route ('/')\n  Navigator.pushNamedAndRemoveUntil(\n    context,\n    '/', // The name of the new route to push\n    ModalRoute.withName('/') // The predicate: stop removing when we find '/'\n  );\n},\n```\n\nIn this scenario:\n\n1.  The stack is `[ /, /list, /detail, /edit, /confirmation ]`.\n2.  `pushNamedAndRemoveUntil` first prepares to push `/`.\n3.  It looks at `/confirmation`. Does it match `ModalRoute.withName('/')`? No. It's marked for removal.\n4.  It looks at `/edit`. Does it match? No. Marked for removal.\n5.  It looks at `/detail`. Does it match? No. Marked for removal.\n6.  It looks at `/list`. Does it match? No. Marked for removal.\n7.  It looks at `/`. Does it match? Yes! The predicate returns true. The process of identifying routes to remove stops.\n8.  The new route (`/`) is pushed, and simultaneously, the routes marked for removal (`/confirmation`, `/edit`, `/detail`, `/list`) are disposed of.\n9.  The stack is now just `[ / ]`.\n\nThis allows you to effectively \"reset\" part of the navigation stack or jump back to a known point while removing everything above it.\n\n## RoutePredicate Under the Hood (Simplified)\n\nA `RoutePredicate` is just a function signature. Looking at the Flutter code (`navigator.dart`):\n\n```dart\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n```\n\nThis tells us it's a function that accepts a `Route<dynamic>` as input and returns a `bool`. `true` means the predicate is satisfied, `false` means it's not.\n\nHow does the `NavigatorState` use this predicate internally? Let's focus on the `popUntil` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified)\nvoid popUntil(RoutePredicate predicate) {\n  assert(!_debugLocked);\n  assert(() { _debugLocked = true; return true; }());\n\n  // Find the last route that is current or has state that handles pops internally.\n  // We stop there.\n  _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  // Iterate backwards through the history\n  // We use candidate.route.willHandlePopInternally to handle routes that\n  // manage their own pop behavior (like nested navigators or forms).\n  // If a route handles pop internally (willHandlePopInternally is true),\n  // we try to pop it internally first (candidate.route.didPop(null)).\n  // If it still satisfies the predicate after internal pop, we stop.\n  // If not, or if it didn't handle it internally, we continue popping.\n  while (candidate != null) {\n    // Check if the current route candidate satisfies the predicate\n    if (predicate(candidate.route)) {\n      assert(() { _debugLocked = false; return true; }());\n      return; // Predicate returned true, stop popping\n    }\n\n    // If the candidate wants to handle pops internally, try that first\n    if (candidate.route.willHandlePopInternally) {\n        // Try to pop internally. If it returns false, it means\n        // it handled something, but doesn't want to be removed from the stack yet.\n        final bool poppedInternally = candidate.route.didPop(null);\n        assert(!poppedInternally); // didPop returning false means it's handled internally\n        // After internal pop, does it *now* satisfy the predicate?\n        if (predicate(candidate.route)) {\n             assert(() { _debugLocked = false; return true; }());\n            return; // Predicate returned true after internal pop, stop\n        }\n        // If it didn't satisfy the predicate even after internal pop,\n        // continue the while loop check\n    } else {\n         // If the route doesn't handle pop internally, just pop it off the stack.\n         pop(); // This calls _history[index of candidate].pop(null) and leads to _flushHistoryUpdates removing it\n    }\n\n    // After potentially popping the current candidate, revisit the list\n    // to find the new top candidate.\n    candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n  }\n\n  // If the loop finishes, it means the predicate never returned true\n  // before the stack was (almost) empty.\n  assert(() { _debugLocked = false; return true; }());\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ScreenBWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant RouteBEntry\n    participant RouteAEntry\n    participant RouteHomeEntry\n\n    User->>ScreenBWidget: Tap \"Go back to Home\"\n    ScreenBWidget->>NavigatorState: Navigator.popUntil(context, predicate = '/' name check)\n    loop Pop Routes\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteBEntry)\n        NavigatorState->>predicate: Call predicate(RouteBEntry.route)\n        predicate->>NavigatorState: Return false ('/screenB' != '/')\n        NavigatorState->>RouteBEntry: route.didPop(null) (starts animation)\n        RouteBEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteBEntry\n        NavigatorState->>Overlay: Remove RouteB's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteAEntry)\n        NavigatorState->>predicate: Call predicate(RouteAEntry.route)\n        predicate->>NavigatorState: Return false ('/screenA' != '/')\n        NavigatorState->>RouteAEntry: route.didPop(null) (starts animation)\n        RouteAEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteAEntry\n        NavigatorState->>Overlay: Remove RouteA's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteHomeEntry)\n        NavigatorState->>predicate: Call predicate(RouteHomeEntry.route)\n        predicate->>NavigatorState: Return true ('/' == '/')\n        NavigatorState->>NavigatorState: Stop popping\n    end\nalt Loop ends before predicate returns true\n        NavigatorState->>NavigatorState: Stack is nearly empty. Stop looping.\nend\n```\n\nThis simplified diagram shows `popUntil` iterating backwards, applying the predicate to each route it encounters (represented by `_RouteEntry.route`), and if the predicate is false, it removes that route before checking the next one. The loop stops *before* removing the route that satisfies the predicate.\n\n## Conclusion\n\nA `RoutePredicate` is a powerful function that allows you to define criteria for selecting routes within the [Navigator's](01_navigator_.md) history stack. This is particularly useful with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear multiple routes efficiently based on their properties, most commonly their name. By using predicates like `ModalRoute.withName`, you can create flexible navigation flows that aren't tied to knowing the exact number of screens in the stack.\n\nNow that we understand how to identify and manage groups of routes using predicates, we'll move on to discuss `RoutePopDisposition`, which determines whether a route *can* be popped and how a pop request should be handled.\n\n[Chapter 6: RoutePopDisposition](06_routepopdisposition_.md)\n---\n# Chapter 6: RoutePopDisposition\n\nWelcome back, aspiring Flutter developers! In our previous chapter, [Chapter 5: RoutePredicate](05_routepredicate_.md), we learned how `RoutePredicate` helps the [Navigator](01_navigator_.md) decide which routes to interact with, especially when using `popUntil` or `pushNamedAndRemoveUntil`.\n\nToday, we're going to look at a concept that's closely related to *whether* a single [Route](02_route_.md) can be popped at all and how it should behave when a pop is attempted: **RoutePopDisposition**.\n\nThink of `RoutePopDisposition` as a rule that a specific screen ([Route](02_route_.md)) sets for itself about how it responds to being asked to close or \"pop.\" It's like a door deciding if it should open when someone tries to go back through it.\n\n## Why do we need RoutePopDisposition?\n\nMost of the time, when you push a new screen, it's expected that hitting the back button or calling `Navigator.pop` will dismiss that screen and take you back. `MaterialPageRoute` (which we used in earlier chapters) provides this behavior automatically.\n\nHowever, there are cases where you might *not* want a screen to be easily dismissed by the back button:\n\n1.  **Forms with unsaved changes:** If a user is filling out a form and accidentally hits the back button, you might want to show a confirmation dialog (\"Discard changes?\") instead of just closing the screen immediately. The screen needs a way to say, \"Hold on, let me handle this pop request first.\"\n2.  **Blocking navigation:** Sometimes, a screen represents a crucial step that the user *must* complete before going back. You might want to completely ignore back button presses until a specific action is taken on that screen.\n3.  **Top-level app exit:** When the very first screen of your app is visible, hitting the back button shouldn't usually navigate *back* within your app (because there's nowhere to go!). Instead, it should allow the operating system (like Android) to handle it, potentially closing the app or sending it to the background.\n\n`RoutePopDisposition` helps a [Route](02_route_.md) communicate its preference for how the [Navigator](01_navigator_.md) should handle a pop request targeted at it.\n\n## Understanding the Options\n\n`RoutePopDisposition` is an `enum` (a set of predefined values) with three possible options:\n\n*   **`RoutePopDisposition.pop`**: This is the default behavior for most routes that aren't the very first one. It means, \"Yes, go ahead and pop me off the stack.\" The [Navigator](01_navigator_.md) will proceed with the standard pop operation (exit animation, disposal, etc.).\n*   **`RoutePopDisposition.doNotPop`**: This means, \"No, don't pop me. Ignore this pop request.\" The [Navigator](01_navigator_.md) will stop the pop process, and the screen will remain visible. This is useful for completely blocking back navigation.\n*   **`RoutePopDisposition.bubble`**: This is the default behavior for the very first route ([Route.isFirst](02_route_.md) is true). It means, \"I can't be popped internally. Pass this pop request up to the next level,\" which is typically the operating system. This allows the system to handle the \"back\" action (e.g., minimizing the app).\n\n## How is RoutePopDisposition Used?\n\nThe [Navigator](01_navigator_.md) checks the `RoutePopDisposition` when the `Navigator.maybePop` method is called. `maybePop` is internally called when the system back button is pressed (on platforms that have one) or when a `PopScope` widget allows a pop. It's the polite way to attempt a pop, giving the current [Route](02_route_.md) a chance to respond. The standard `Navigator.pop` method, however, is an imperative command that bypasses this check and force-pops the route (unless the route has internal pop handling that *does* check the disposition, like `ModalRoute`).\n\n`Route` objects have a getter `popDisposition` (and a deprecated `willPop` future) that return one of these `RoutePopDisposition` values.\n\nLet's create a simple screen that prevents itself from being popped using `doNotPop`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A screen that resists popping!\nclass ResistPopScreen extends ModalRoute<void> {\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300);\n\n  @override\n  bool get opaque => true;\n\n  @override\n  bool get barrierDismissible => false; // Cannot dismiss by tapping barrier\n\n  @override\n  Color get barrierColor => Colors.black54; // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => null;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Material(\n      type: MaterialType.transparency,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.white,\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              const Text(\n                'You cannot pop this screen with the back button!',\n                textAlign: TextAlign.center,\n                style: TextStyle(fontSize: 18),\n              ),\n              const SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: () {\n                  // We use Navigator.pop here, which is an imperative command\n                  // and bypasses the RoutePopDisposition check.\n                  // This button *will* dismiss the screen.\n                  Navigator.pop(context);\n                },\n                child: const Text('Dismiss Anyway (using pop)'),\n              ),\n               ElevatedButton(\n                onPressed: () {\n                  // This tries to maybePop, which will consult\n                  // RoutePopDisposition and be ignored.\n                  Navigator.maybePop(context);\n                },\n                child: const Text('Try to Pop Politely (won\\'t work)'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Override popDisposition to prevent popping via maybePop (like back button)\n  @override\n  RoutePopDisposition get popDisposition {\n      print('ResistPopScreen: Deciding pop disposition...');\n      return RoutePopDisposition.doNotPop;\n  }\n}\n\n// Our HomeScreen to push the ResistPopScreen\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push our ResistPopScreen\n            Navigator.push(context, ResistPopScreen());\n          },\n          child: const Text('Go to Resist Pop Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Add this to your main MaterialApp routes if using named routes,\n// or push it directly as shown above.\n/*\nroutes: {\n  '/': (context) => const HomeScreen(),\n  // We push the route directly in this example, not via named routes.\n  // If you wanted a named route:\n  // '/resistPop': (context) => ResistPopScreen(), // Need a different way to build ModalRoute often\n},\n*/\n```\n\nIn this example:\n\n*   We created a custom [Route](02_route_.md) by extending `ModalRoute`. `ModalRoute`s are good for overlays like dialogs or custom screens that block interaction with the previous screen.\n*   We overrode the `buildPage` method to provide the visual content of our screen (a simple box with text and buttons).\n*   **Crucially**, we overrode the `popDisposition` getter to return `RoutePopDisposition.doNotPop`.\n*   When you run this, navigate to the `ResistPopScreen`. Hitting the system back button (which calls `maybePop`) will do nothing. The `print` statement in `popDisposition` confirms it was checked.\n*   Tapping the \"Try to Pop Politely\" button (which also calls `maybePop`) will also do nothing. The `popDisposition` prevents it.\n*   Tapping the \"Dismiss Anyway (using pop)\" button works because it calls `Navigator.pop`, which is a direct command to the [Navigator](01_navigator_.md) to remove the route, regardless of its `popDisposition`.\n\nThis demonstrates how `doNotPop` gives a route control over whether it responds to \"polite\" pop requests like the system back button.\n\nFor a forms-with-unsaved-changes scenario, you might initially return `RoutePopDisposition.pop` but use a `PopScope` widget (or the older `WillPopScope`) within the route's content. This widget would intercept the pop and show a dialog *before* the route's `popDisposition` is even consulted (or sometimes trigger a change that causes `popDisposition` to become `doNotPop` if necessary).\n\n## RoutePopDisposition Under the Hood (Simplified)\n\nLet's look at where `RoutePopDisposition` is defined and how it's used in the `NavigatorState`.\n\nThe `RoutePopDisposition` enum is simply:\n\n```dart\n/// Indicates whether the current route should be popped.\nenum RoutePopDisposition {\n  /// Pop the route.\n  pop,\n\n  /// Do not pop the route.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  bubble,\n}\n```\n\nThe core logic for using this enum lives in the `NavigatorState.maybePop` method (simplified, focusing on `popDisposition`):\n\n```dart\n// Inside NavigatorState class (simplified maybePop)\n@optionalTypeArgs\nFuture<bool> maybePop<T extends Object?>([T? result]) async {\n  // Find the current top-most route that is \"present\" (visible or animating)\n  final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  if (lastEntry == null) {\n    return false; // Nothing to pop\n  }\n  assert(lastEntry.route._navigator == this);\n\n  // Check the route's pop disposition\n  switch (lastEntry.route.popDisposition) {\n    case RoutePopDisposition.bubble:\n      // Route says let someone else handle it (e.g., OS)\n      return false; // Indicate that *this* navigator didn't handle it\n\n    case RoutePopDisposition.pop:\n      // Route says it's okay to pop.\n      pop(result); // Call our internal pop method\n      return true; // Indicate that we handled the pop\n\n    case RoutePopDisposition.doNotPop:\n      // Route says don't pop it, ignore the request.\n      // We still call onPopInvokedWithResult to notify the route that a pop\n      // was attempted but canceled.\n      lastEntry.route.onPopInvokedWithResult(false, result);\n      return true; // Indicate that we handled the pop (by ignoring it)\n  }\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant OperatingSystem\n    participant NavigatorState\n    participant CurrentRouteEntry\n\n    User->>OperatingSystem: Back button pressed\n    OperatingSystem->>NavigatorState: Call maybePop(null)\n    NavigatorState->>CurrentRouteEntry: Get current route's RoutePopDisposition\n    alt RoutePopDisposition is bubble\n        CurrentRouteEntry->>NavigatorState: Return bubble\n        NavigatorState-->>OperatingSystem: Return false (not handled)\n    else RoutePopDisposition is pop\n        CurrentRouteEntry->>NavigatorState: Return pop\n        NavigatorState->>NavigatorState: Call pop(null)\n         NavigatorState-->>OperatingSystem: Return true (handled)\n    else RoutePopDisposition is doNotPop\n        CurrentRouteEntry->>NavigatorState: Return doNotPop\n        NavigatorState->>CurrentRouteEntry: route.onPopInvokedWithResult(false, null)\n        NavigatorState-->>OperatingSystem: Return true (handled)\n    end\n```\n\nThis simplified flow shows that `maybePop` is the gatekeeper that respects the `RoutePopDisposition`. It gets the disposition from the current route and then follows the rule: return `false` for `bubble` (let the caller handle it, usually means exiting the app scope), or return `true` for `pop` or `doNotPop` (meaning this `Navigator` \"handled\" the request, either by performing the pop or deliberately ignoring it).\n\nRoutes built with `MaterialPageRoute` and `CupertinoPageRoute` automatically implement `popDisposition` to return `bubble` if `isFirst` is true and `pop` otherwise. Custom routes can override this logic to implement behaviors like our `ResistPopScreen`.\n\n## Conclusion\n\n`RoutePopDisposition` is a simple but effective enum that allows individual [Route](02_route_.md)s to control how they respond to requests to be popped, particularly via `Navigator.maybePop` (triggered by system back buttons). By returning `pop`, `doNotPop`, or `bubble`, a route signals its intention, enabling scenarios like preventing accidental data loss or controlling app exit behavior. While `Navigator.pop` provides a way to imperatively dismiss a route, `maybePop` and `RoutePopDisposition` offer a cooperative mechanism for handling navigation changes requested by the system or other widgets like `PopScope`.\n\nIn the next chapter, we'll explore `NavigatorObserver`, which allows you to listen to and react to various navigation events happening within a [Navigator].\n\n[Chapter 7: NavigatorObserver](07_navigatorobserver_.md)\n---\n# Chapter 7: NavigatorObserver\n\nWelcome back, Flutter enthusiasts! In our journey through Flutter navigation, we've learned about the [Navigator](01_navigator_.md) managing the route stack, [Route](02_route_.md)s as screen recipes, [RouteSettings](03_routesettings_.md) for details, [Page](04_page_.md)s for declarative navigation, [RoutePredicate](05_routepredicate_.md)s for advanced route selection, and [RoutePopDisposition](06_routepopdisposition_.md) for controlling pop behavior.\n\nToday, we're adding a tool that lets us *watch* all of this navigation magic happen: the **NavigatorObserver**.\n\nThink of a **NavigatorObserver** as a silent spy or a detective that keeps an eye on everything the [Navigator](01_navigator_.md) is doing. Whenever a route is pushed, popped, replaced, or even removed, the `NavigatorObserver` gets a notification.\n\n## Why do we need a NavigatorObserver?\n\nWhy would you want to watch the [Navigator](01_navigator_.md)? Here are a few common reasons:\n\n1.  **Logging:** You might want to track which screens the user visits and in what order for analytics or debugging. A `NavigatorObserver` can simply print a message every time a route changes.\n2.  **Analytics:** Similar to logging, you can send navigation events to an analytics service (like Google Analytics or Firebase Analytics) to understand user flow within your app.\n3.  **External Updates:** Maybe some part of your app needs to react whenever a specific screen is shown or dismissed. An observer can trigger actions outside of the screen itself.\n4.  **Custom Behaviors:** In advanced scenarios, you might use an observer to implement custom global behaviors related to navigation, like managing certain background tasks.\n\nThe core idea is that the `NavigatorObserver` allows you to react *globally* to changes in the [Navigator's](01_navigator_.md) state without needing to add logic to *every single screen's* navigation calls (`push`, `pop`, etc.).\n\n## Using NavigatorObserver to Log Navigation Events\n\nLet's dive into our main use case: logging every time a screen is pushed or popped.\n\nTo use a `NavigatorObserver`, you need to:\n\n1.  Create a class that extends `NavigatorObserver`.\n2.  Override the methods that correspond to the events you want to listen to (like `didPush` and `didPop`).\n3.  Provide an instance of your observer class to the `observers` list of your `Navigator` (or usually, your `MaterialApp` or `WidgetsApp`, which creates the main [Navigator]).\n\nHere's our simple logging observer:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Our custom observer that extends NavigatorObserver\nclass MyNavigatorObserver extends NavigatorObserver {\n  // Called when a route is pushed (a new screen is added)\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Pushed route: ${route.settings.name}');\n    print('NavigatorObserver: Previous route: ${previousRoute?.settings.name}');\n  }\n\n  // Called when a route is popped (a screen is removed)\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Popped route: ${route.settings.name}');\n    print('NavigatorObserver: New current route: ${previousRoute?.settings.name}');\n  }\n\n  // You can override other methods too, like didReplace, didRemove, etc.\n}\n```\n\nThis class is pretty straightforward. It just overrides `didPush` and `didPop` to print messages showing the name of the route involved in the event and the route below it.\n\nNow, let's integrate this into our simple navigation setup with a Home Screen and Second Screen using named routes, similar to what we did in [Chapter 3: RouteSettings](03_routesettings_.md).\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Second Screen\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Second Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd here's how we provide our observer to the `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Contains HomeScreen and SecondScreen\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Create an instance of our observer\nfinal MyNavigatorObserver myObserver = MyNavigatorObserver();\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Navigator Observer Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/secondScreen': (context) => const SecondScreen(),\n    },\n    // Provide our observer here!\n    observers: [\n      myObserver, // Add our observer to the list\n    ],\n  ));\n}\n```\n\nWhen you run this code and navigate between the screens, you'll see the `print` statements from `MyNavigatorObserver` appear in your console every time a `push` or `pop` happens.\n\n**Expected Console Output (walking through the simple flow):**\n\n1.  App starts (HomeScreen is the initial route, often added without a `push` notification by default setup): No observer notification yet.\n2.  Tap \"Go to Second Screen\" button:\n    ```\n    NavigatorObserver: Pushed route: /secondScreen\n    NavigatorObserver: Previous route: /\n    ```\n3.  Tap \"Go Back!\" button:\n    ```\n    NavigatorObserver: Popped route: /secondScreen\n    NavigatorObserver: New current route: /\n    ```\n\nThis is a minimal example, but it shows the power of listening to navigation events centrally.\n\n## Other Methods to Observe\n\nBesides `didPush` and `didPop`, `NavigatorObserver` also offers other methods you can override:\n\n*   `didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute})`: Called when one route is replaced by another (e.g., using `Navigator.pushReplacement`).\n*   `didRemove(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a route is removed from the stack without being popped (e.g., using `Navigator.removeRoute`).\n*   `didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute)`: Called whenever the top-most route on the navigator changes, regardless of how it changed (push, pop, replace affecting top).\n*   `didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a user starts a gesture associated with navigation (like the iOS back swipe).\n*   `didStopUserGesture()`: Called when a user gesture associated with navigation ends.\n\nOverriding these methods lets your observer react to the full spectrum of navigation changes.\n\n## NavigatorObserver Under the Hood (Simplified)\n\nHow does the `NavigatorObserver` get its notifications?\n\nThe `NavigatorState` (the actual state object that manages the routes, discussed in [Chapter 1: Navigator](01_navigator_.md)) holds a list of `NavigatorObserver` instances provided to it via the `Navigator` widget's `observers` property. Whenever the `NavigatorState` performs a navigation operation (like adding or removing a route from its internal stack), it iterates through its list of observers and calls the corresponding notification method on each one.\n\nImagine the `NavigatorState`'s `push` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified push)\n@optionalTypeArgs\nFuture<T?> push<T extends Object?>(Route<T> route) {\n  // ... (internal logic to add route entry to _history) ...\n\n  // After the internal state is updated...\n  // Notify observers about the push event!\n  // _effectiveObservers is the list of observers including the hero controller\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPush(route, previousRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic, animations, etc.) ...\n\n  return route.popped; // Return the future\n}\n```\n\nSimilarly, the `pop` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified pop)\n@optionalTypeArgs\nvoid pop<T extends Object?>([T? result]) {\n  // ... (internal logic to remove route entry from _history) ...\n\n  // After the internal state changes...\n  // Notify observers about the pop event!\n  // _effectiveObservers is the list of observers\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPop(poppedRoute, newTopRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic) ...\n}\n```\n\nAnd how about our logging example flow with the observer?\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MyNavigatorObserver\n    participant SecondScreenRoute\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/secondScreen')\n    NavigatorState->>NavigatorState: Look up route for /secondScreen\n    NavigatorState->>SecondScreenRoute: Create route for /secondScreen\n    NavigatorState->>NavigatorState: Add SecondScreenRoute to _history\n    NavigatorState->>MyNavigatorObserver: observer.didPush(SecondScreenRoute, HomeScreenRoute)\n    MyNavigatorObserver->>Console: Print \"Pushed route: /secondScreen\", etc.\n    NavigatorState->>Overlay: Display SecondScreenRoute content\n```\n\nThis simple diagram shows that when `Navigator.pushNamed` (which internally calls the `push` method in `NavigatorState`) is executed, the `NavigatorState` makes a call to the `didPush` method on your `MyNavigatorObserver` instance, allowing it to react to the event.\n\n## Conclusion\n\nThe `NavigatorObserver` is a powerful, yet simple abstraction that allows you to listen to and react to events happening within a [Navigator]. By creating a custom observer and providing it to your application's main [Navigator], you can centralize logic for tasks like logging, analytics, or triggering side effects based on navigation changes. It provides a clean way to decouple these global concerns from the individual screen widgets and navigation calls.\n\nIn the next chapter, we'll explore another advanced concept for customizing behavior within the [Navigator]: the `TransitionDelegate`, which influences how pages animate when the `Navigator.pages` list changes.\n\n[Chapter 8: TransitionDelegate](08_transitiondelegate_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 8: TransitionDelegate\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 8: TransitionDelegate\n\nWelcome back, future Flutter navigators! In our previous chapter, [Chapter 7: NavigatorObserver](07_navigatorobserver_.md), we learned how `NavigatorObserver` lets us watch and react to navigation events like routes being pushed or popped.\n\nToday, we're diving into a concept that\u2019s specifically relevant when you're using the Page-based navigation API ([Chapter 4: Page](04_page_.md)), and it helps the [Navigator](01_navigator_.md) decide *how* screens should animate when the list of [Page](04_page_.md)s changes: the **TransitionDelegate**.\n\nThink of the **TransitionDelegate** as the choreographer for the Page-based [Navigator](01_navigator_.md). When you change the list of [Page](04_page_.md)s you provide to the [Navigator](01_navigator_.md), the `TransitionDelegate` is consulted to decide exactly which pages need to animate (slide in or out) and which ones can just appear or disappear instantly.\n\n## Why do we need a TransitionDelegate?\n\nWhen you use the `Navigator.pages` property (as introduced in [Chapter 4: Page](04_page_.md)), the [Navigator](01_navigator_.md) compares the *new* list of [Page](04_page_.md)s you give it with the *old* list it was managing. Based on this comparison, it figures out which pages are:\n\n*   **New:** These need to enter the screen.\n*   **Missing:** These need to exit the screen.\n*   **Existing:** These stay on the screen (though their position relative to others might change).\n\nFor the \"New\" and \"Missing\" pages, the [Navigator](01_navigator_.md) needs to know how to handle them:\n\n*   Should a \"New\" page slide in with a push animation? Or should it just appear instantly (like adding it without an animation)?\n*   Should a \"Missing\" page slide out with a pop animation? Or should it just disappear instantly (like removing it without an animation)?\n\nThe **TransitionDelegate** is the object that makes these decisions. It looks at the state of all pages (entering, exiting, or remaining) and *tells* the [Navigator](01_navigator_.md) what actions to take (push, add, pop, remove, complete) for each route, corresponding to the page.\n\nThis delegate-based approach is flexible because you can customize the animation behavior based on your app's needs, especially when navigating complex or non-linear flows using the Page-based API.\n\n## How TransitionDelegate Works\n\nWhen you update the `pages` list on a [Navigator](01_navigator_.md), the [Navigator](01_navigator_.md) does some internal work to figure out which pages are entering and which are exiting. It represents these changes as a list of `RouteTransitionRecord` objects. Each `RouteTransitionRecord` wraps a [Route](02_route_.md) and indicates if that route is \"waiting for an entering decision\" or \"waiting for an exiting decision.\"\n\nThe [Navigator](01_navigator_.md) then passes these records to the `TransitionDelegate`'s `resolve` method.\n\nThe `resolve` method receives three pieces of information:\n\n1.  `newPageRouteHistory`: A list of `RouteTransitionRecord`s for pages that will be in the history *after* the update. Some of these might be new and need an \"entering decision.\"\n2.  `locationToExitingPageRoute`: A map showing which pages are exiting, keyed by the page below them (or null if they were the bottom-most exiting page). Some of these might need an \"exiting decision.\"\n3.  `pageRouteToPagelessRoutes`: A map showing any [Route](02_route_.md)s that were pushed imperatively ([Chapter 1: Navigator](01_navigator_.md)) *on top of* page-based routes. If a page they were on top of is exiting, these pageless routes also need \"exiting decisions.\"\n\nYour `TransitionDelegate.resolve` method must then iterate through these records and make decisions. For records needing a decision:\n\n*   If `isWaitingForEnteringDecision` is true, you call `markForPush()` or `markForAdd()` on the record.\n*   If `isWaitingForExitingDecision` is true, you call `markForPop()`, `markForComplete()`, or `markForRemove()` on the record.\n\nAfter making *all* necessary decisions, `resolve` must return an `Iterable<RouteTransitionRecord>` containing *all* the records from `newPageRouteHistory` and *all* the records from `locationToExitingPageRoute` (and their associated pageless routes), merged into a single list representing the final desired order of routes in the history. The relative order of pages from `newPageRouteHistory` must be preserved in the result.\n\nIt sounds a bit complex, but the core idea is: the delegate sees who's coming and going and decides how they move.\n\n## The Default TransitionDelegate\n\nFlutter provides a `DefaultTransitionDelegate` that implements logical default behavior:\n\n*   The newly added page that ends up at the *very top* of the stack is marked for `markForPush` (animates in).\n*   Any other newly added pages *below* the top one are marked for `markForAdd` (appear instantly).\n*   The page that was at the *very top* and is now missing is marked for `markForPop` (animates out).\n*   Any other missing pages *below* the top one are marked for `markForComplete` (disappear instantly, completing their future).\n\nThis behavior mimics typical imperatively driven navigation patterns where only the top-most route transition is animated.\n\n## Implementing a Custom TransitionDelegate\n\nLet's imagine a simple use case: We want to always animate *all* new pages being pushed *in* from the right, and *all* pages being removed *out* to the right, regardless of where they are in the stack. This isn't typical, but it demonstrates overriding the default behavior.\n\nWe'll need a simple app using the Page-based API, perhaps showing a list of numbers, and adding a detail page when a number is tapped.\n\nFirst, let's set up our basic screens or page builders (similar to [Chapter 4: Page](04_page_.md)). We'll use `MaterialPage` for simplicity.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A simple page for the home screen\nclass HomePage extends Page<void> {\n  const HomePage() : super(key: const ValueKey('HomePage'), name: '/');\n\n  @override\n  Route<void> createRoute(BuildContext context) {\n    return MaterialPageRoute<void>(\n      settings: this,\n      builder: (BuildContext context) {\n        return Scaffold(\n          appBar: AppBar(title: const Text('Home')),\n          body: ListView.builder(\n            itemCount: 5,\n            itemBuilder: (context, index) {\n              return ListTile(\n                title: Text('Item $index'),\n                onTap: () {\n                  // In a real app, you'd add a DetailPage to your\n                  // pages list managed by a state object.\n                  // This is just to illustrate the Page concept.\n                },\n              );\n            },\n          ),\n        );\n      },\n    );\n  }\n}\n\n// A simple page for the detail screen\nclass DetailPage extends Page<void> {\n  const DetailPage({required this.itemIndex}) : super(key: ValueKey('Detail$itemIndex'), name: '/detail/$itemIndex', arguments: itemIndex);\n\n  final int itemIndex;\n\n  @override\n  Route<void> createRoute(BuildContext context) {\n    return MaterialPageRoute<void>(\n      settings: this,\n      builder: (BuildContext context) {\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nNow, let's create our custom `TransitionDelegate`:\n\n```dart\nimport 'package:flutter/widgets.dart'; // Important for TransitionDelegate and RouteTransitionRecord\n\n// Our custom TransitionDelegate that always animates pushes and pops\nclass AlwaysAnimateTransitionDelegate extends TransitionDelegate<void> {\n  const AlwaysAnimateTransitionDelegate();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n\n    // Handle routes that are entering (new pages)\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      if (pageRoute.isWaitingForEnteringDecision) {\n        // Always mark for push (animate in)\n        pageRoute.markForPush();\n      }\n      // Add the page route to the results list\n      results.add(pageRoute);\n    }\n\n    // Handle routes that are exiting (missing pages)\n    for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        // Always mark for pop (animate out)\n        exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n\n        // Handle any pageless routes on top of this exiting page\n        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n        if (pagelessRoutes != null) {\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n             if (pagelessRoute.isWaitingForExitingDecision) {\n                // Also mark pageless routes for pop\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n             }\n           }\n        }\n      }\n      // Add the exiting route to the results list.\n      // Note: The order matters; we must maintain the relative order\n      // of pages from newPageRouteHistory. Exiting pages can be inserted\n      // around them. In this simple example, we just add them to the end.\n      results.add(exitingPageRoute);\n    }\n\n    // The default delegate inserts exiting pages at the location they were removed\n    // from. Let's imitate that to keep the list order accurate.\n    final List<RouteTransitionRecord> mergedList = [];\n    final Iterator<RouteTransitionRecord> exitingIterator = locationToExitingPageRoute.values.iterator;\n    RouteTransitionRecord? nextExiting = exitingIterator.moveNext() ? exitingIterator.current : null;\n    final RouteTransitionRecord? firstEnteringPage = newPageRouteHistory.isNotEmpty ? newPageRouteHistory.first : null;\n     RouteTransitionRecord? nextEntering = firstEnteringPage;\n\n    Iterable<RouteTransitionRecord>? exitingBelowFirstEntering;\n    if (firstEnteringPage != null) {\n         exitingBelowFirstEntering = locationToExitingPageRoute.entries\n             .where(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.key == null) // Find exiting pages whose location was null (bottom)\n             .map(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.value);\n         mergedList.addAll(exitingBelowFirstEntering); // Add exiting pages that were at the bottom\n    }\n\n    for(final RouteTransitionRecord entering in newPageRouteHistory) {\n        mergedList.add(entering);\n        // Find any exiting pages whose location was this entering page\n         final Iterable<RouteTransitionRecord> exitingAboveThisEntering = locationToExitingPageRoute.entries\n             .where(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.key == entering)\n             .map(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.value);\n         mergedList.addAll(exitingAboveThisEntering);\n    }\n\n    // Add any remaining exiting pages that weren't placed\n    for(final exiting in locationToExitingPageRoute.values) {\n        if (!mergedList.contains(exiting)) {\n             mergedList.add(exiting);\n        }\n    }\n\n    // Add any pageless routes attached to exiting pages that weren't added\n    for (final parentPageEntry in pageRouteToPagelessRoutes.keys) {\n        final pagelessRoutes = pageRouteToPagelessRoutes[parentPageEntry]!;\n         for (final pagelessRoute in pagelessRoutes) {\n             if (!mergedList.contains(pagelessRoute)) {\n                  mergedList.add(pagelessRoute);\n             }\n        }\n    }\n\n    return mergedList;\n  }\n}\n```\n\nExplanation:\n\n*   Our `AlwaysAnimateTransitionDelegate` extends `TransitionDelegate<void>`.\n*   The `resolve` method receives the information described earlier.\n*   We iterate through `newPageRouteHistory`. If a page `isWaitingForEnteringDecision`, we call `markForPush()` on its record. This signals to the [Navigator](01_navigator_.md) that the corresponding route should be pushed with an animation.\n*   We iterate through the values of `locationToExitingPageRoute` (the exiting page records). If a page `isWaitingForExitingDecision`, we call `markForPop()`. This signals that the corresponding route should be popped with an animation. We also handle any pageless routes associated with this exiting page in the same way.\n*   Finally, we construct the `mergedList`. The `resolve` method *must* return a list containing all involved route records in their *new* order. The relative order of `newPageRouteHistory` entries must be preserved. Exiting entries can be placed anywhere else. A safe default is to place entering routes followed by exiting routes, or (as done in the comment and refined logic) insert exiting routes where they were removed from relative to the entering stack. The slightly more complex list merging logic ensures all records are included and the relative order of the *new* history stack is correct while placing the exiting routes appropriately.\n\nTo use this delegate, you'd provide an instance of it to your `Navigator` (or `MaterialApp.router` / `WidgetsApp.router` which manage the [Navigator]):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'pages.dart'; // Contains HomePage and DetailPage\nimport 'my_transition_delegate.dart'; // Contains AlwaysAnimateTransitionDelegate\n\nvoid main() {\n  runApp(MaterialApp.router( // Using .router for Page-based navigation\n    routerDelegate: MyRouterDelegate(), // You'd typically have a custom RouterDelegate\n    routeInformationParser: MyRouteInformationParser(), // and a RouteInformationParser\n  ));\n}\n\n// Simplified example of a minimal delegate/parser setup\nclass MyRouterDelegate extends RouterDelegate<List<Page<dynamic>>>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<List<Page<dynamic>>> {\n\n  final List<Page<dynamic>> _pages = [const HomePage()];\n\n  @override\n  Widget build(BuildContext context) {\n    // This is where the Navigator is built with the pages and the transition delegate\n    return Navigator(\n      key: navigatorKey, // Required by PopNavigatorRouterDelegateMixin\n      pages: List.of(_pages), // Pass a copy of the pages list\n      onPopPage: _handlePopPage, // Handle pops\n      transitionDelegate: const AlwaysAnimateTransitionDelegate(), // Our custom delegate!\n    );\n  }\n\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n     if (route.settings is Page) {\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        _pages.removeAt(index);\n        notifyListeners(); // Notify the RouterDelegate that state changed\n        return route.didPop(result);\n      }\n    }\n    return false;\n  }\n\n  void _addDetailPage(int index) {\n     _pages.add(DetailPage(itemIndex: index));\n     notifyListeners(); // Trigger a rebuild of the Navigator\n  }\n\n  //--- Standard RouterDelegate overrides (simplified) ---\n  @override\n  GlobalKey<NavigatorState> get navigatorKey => GlobalKey<NavigatorState>();\n\n   @override\n  Future<void> setNewRoutePath(List<Page<dynamic>> configuration) {\n    // Implement logic to update _pages based on initial route/deep links\n     return SynchronousFuture(null);\n  }\n\n   @override\n   List<Page<dynamic>> get currentConfiguration => List.of(_pages);\n}\n\n// Minimal RouteInformationParser\nclass MyRouteInformationParser extends RouteInformationParser<List<Page<dynamic>>> {\n  @override\n  Future<List<Page<dynamic>>>> parseRouteInformation(RouteInformation routeInformation) async {\n     // Implement logic to parse initial route and create initial list of Pages\n     return [const HomePage()]; // Just return default for simplicity\n  }\n\n  @override\n  RouteInformation restoreRouteInformation(List<Page<dynamic>> configuration) {\n     // Implement logic to create RouteInformation from current Page list\n     return RouteInformation(uri: Uri.parse(configuration.last.name ?? '/'));\n  }\n}\n\n// In your HomeScreen, you'd need access to the RouterDelegate to call _addDetailPage:\n/*\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Access the RouterDelegate (example, implementation detail depends on state management)\n    final MyRouterDelegate routerDelegate = Router.of(context).routerDelegate as MyRouterDelegate;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: ListView.builder(\n        itemCount: 5,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text('Item $index'),\n            onTap: () {\n              routerDelegate._addDetailPage(index); // Call the method to add a page\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n*/\n```\n\nIn this setup, whenever the `_pages` list in `MyRouterDelegate` is modified (e.g., by calling `_addDetailPage` and then `notifyListeners`), the `MaterialApp.router` rebuilds the `Navigator`, providing the updated `_pages` list. The `Navigator` then uses `AlwaysAnimateTransitionDelegate` to decide how to animate the changes.\n\n## TransitionDelegate Under the Hood (Simplified)\n\nLet's look at the definition of `TransitionDelegate`:\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class TransitionDelegate<T> { // T is the return type, often void\n  const TransitionDelegate();\n\n  // This is the core method the Navigator calls\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n\n  // Internal method used by NavigatorState, wraps resolve and adds assertions\n  // to check the validity of the output.\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n```\n\nAnd the `RouteTransitionRecord`:\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class RouteTransitionRecord {\n  Route<dynamic> get route; // The associated Route\n  bool get isWaitingForEnteringDecision; // Needs entering decision?\n  bool get isWaitingForExitingDecision; // Needs exiting decision?\n\n  // Methods to make decisions:\n  void markForPush();\n  void markForAdd();\n  void markForPop([dynamic result]);\n  void markForComplete([dynamic result]);\n  void markForRemove();\n}\n```\n\nThese snippets show the interface the [NavigatorState](01_navigator_.md) uses to interact with the delegate. The `_transition` method is the internal entry point that calls your overridden `resolve` method and performs validation on your return value.\n\nHow does this fit into the `NavigatorState`'s update process when `pages` changes (simplified from `_updatePages` in `navigator.dart`)?\n\n1.  **Diffing:** The `NavigatorState` compares the old and new `pages` lists, identifies which routes correspond to new or missing pages, and creates `_RouteEntry` records (which implement `RouteTransitionRecord`) internally. `_RouteEntry`s for new pages are marked `isWaitingForEnteringDecision`. `_RouteEntry`s for missing pages are marked `isWaitingForExitingDecision`.\n2.  **Delegate Call:** The `NavigatorState` collects these records into the lists/maps required by `TransitionDelegate.resolve` and calls your delegate: `widget.transitionDelegate._transition(...)`.\n3.  **Decision Made:** Your `resolve` method iterates through the records that need decisions and calls methods like `markForPush`, `markForPop`, etc., on them. This updates the internal state (`currentState`) of those `_RouteEntry` records.\n4.  **History Update:** Your `resolve` method returns the merged list of records. The `NavigatorState` then updates its internal `_history` list (`_history.clear(); _history.addAll(results);`) according to this new order.\n5.  **Flush Updates:** The `NavigatorState` calls `_flushHistoryUpdates`, which processes the updated `_history` list. It looks at the `currentState` of each\n    `_RouteEntry` (which was set by your `TransitionDelegate`). For entries marked `push`, `add`, `pop`, `remove`, etc., it performs the corresponding actions:\n    *   `push`: Installs the route, adds its overlay entries, calls `route.didPush()`, starts animation.\n    *   `add`: Installs the route, adds its overlay entries, calls `route.didAdd()`.\n    *   `pop`: Calls `route.didPop()`, starts animation. After animation, calls `finalizeRoute`, removes overlay entries, disposes.\n    *   `complete`: Calls `route.didComplete()`, removes overlay entries, disposes.\n    *   `remove`: Removes overlay entries, disposes.\n6.  **Observer Notification:** As part of `_flushHistoryUpdates`, observers are notified ([Chapter 7: NavigatorObserver](07_navigatorobserver_.md)).\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant TransitionDelegate\n    participant RouteTransitionRecord(s)\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare and Identify Entering/Exiting Routes (_RouteEntrys)\n    NavigatorState->>TransitionDelegate: Call delegate.resolve(...) with RouteTransitionRecords\n    TransitionDelegate->>RouteTransitionRecord(s): Call markForPush(), markForPop(), etc.\n    TransitionDelegate-->>NavigatorState: Return merged list of RouteTransitionRecords\n    NavigatorState->>History(_RouteEntry List): Update internal _history list\n    NavigatorState->>NavigatorState: Call _flushHistoryUpdates\n    loop Process _history\n        NavigatorState->>_RouteEntry(s): Look at currentState (set by delegate)\n        alt currentState is push\n            NavigatorState->>_RouteEntry(s).route: Install route, call didPush(), start animation\n            NavigatorState->>Overlay: Add route's content to Overlay\n            NavigatorState->>History(_RouteEntry List): Update state to pushing/idle\n        end\n         alt currentState is pop\n            NavigatorState->>_RouteEntry(s).route: Call didPop(), start animation\n            NavigatorState->>History(_RouteEntry List): Update state to popping\n        end\n         alt currentState is add\n            NavigatorState->>_RouteEntry(s).route: Install route, call didAdd()\n             NavigatorState->>Overlay: Add route's content to Overlay\n            NavigatorState->>History(_RouteEntry List): Update state to idle\n        end\n        alt currentState is remove/complete\n            NavigatorState->>_RouteEntry(s).route: Call remove() / didComplete()\n            NavigatorState->>Overlay: Remove route's content from Overlay\n            NavigatorState->>History(_RouteEntry List): Mark for disposal\n        end\n    end\n    NavigatorState->>NavigatorState: Notify observers, etc.\n```\n\nThis expanded diagram shows where the `TransitionDelegate` fits into the Page-based navigation flow. It acts after the [Navigator] determines *what* needs to change based on the page list, but *before* it performs the final updates and animations.\n\n## Conclusion\n\nThe `TransitionDelegate` is a key component when using the Page-based API (`Navigator.pages`) for navigation in Flutter. It provides a centralized mechanism for deciding how screens should animate when the list of pages changes. By implementing your own `TransitionDelegate` and overriding the `resolve` method, you can customize the entry and exit transitions for pages, offering flexibility beyond the default push/pop behavior and enabling complex declarative navigation patterns.\n\nWith this chapter, we've covered most of the core building blocks of Navigator behavior. In the next and final chapter, we'll touch upon `RestorableRouteFuture`, a helper class specifically useful when using state restoration alongside imperative navigation calls.\n\n[Chapter 9: RestorableRouteFuture](09_restorableroutefuture_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RestorableRouteFuture\n\". This is Chapter 9.\n\nConcept Details:\n- Name: RestorableRouteFuture\n\n- Description:\nThis abstraction helps restore routes and their return values after your app restarts. Think of it like a sticky note you attach to a button that opens a new screen. When the screen closes and gives back a result, the sticky note remembers it. Even if your app restarts, the sticky note (RestorableRouteFuture) helps you get back the right screen and its result when it's re-opened.\n\n\nComplete Tutorial Structure:\n1. [Navigator\n](01_navigator_.md)\n2. [Route\n](02_route_.md)\n3. [RouteSettings\n](03_routesettings_.md)\n4. [Page\n](04_page_.md)\n5. [RoutePredicate\n](05_routepredicate_.md)\n6. [RoutePopDisposition\n](06_routepopdisposition_.md)\n7. [NavigatorObserver\n](07_navigatorobserver_.md)\n8. [TransitionDelegate\n](08_transitiondelegate_.md)\n9. [RestorableRouteFuture\n](09_restorableroutefuture_.md)\n\nContext from previous chapters:\n# Chapter 1: Navigator\n\nWelcome to the wonderful world of Flutter! In this first chapter, we'll be diving into a core concept that's essential for building interactive apps: the `Navigator`.\n\nThink of a **Navigator** like a friendly guide in your app. As you use an app, you move from one screen to another \u2013 maybe viewing a list of products, then tapping on one to see its details. The `Navigator` is the engine that makes these transitions happen smoothly.\n\nLet's imagine your app is like a stack of cards, where each card is a different screen or page.\n\n```mermaid\ngraph LR\n    HomeScreen --> ProductsScreen;\n    ProductsScreen --> ProductDetailScreen;\n```\n\nWhen you open your app, the \"Home Screen\" card is at the bottom of the stack. When you tap on \"Products,\" the \"Products Screen\" card is placed on top. Then, if you tap on a specific product, the \"Product Detail Screen\" card goes on top of the \"Products Screen.\"\n\nThe `Navigator` helps you manage this stack of \"cards\" (which we'll refer to as **[Route](02_route_.md)**s in Flutter). It allows you to:\n\n*   **Push** a new card onto the top of the stack. This shows a new screen to the user.\n*   **Pop** the top card off the stack. This takes the user back to the previous screen.\n*   Even **replace** cards or handle more complex rearrangements.\n\nThis \"stack\" metaphor is a great way to visualize how navigation works in most mobile apps.\n\n## Our First Navigation Example\n\nLet's build a super simple example to see the `Navigator` in action. We'll have one screen with a button that takes us to a second screen, and the second screen will have a button to go back.\n\nImagine our app structure:\n\n```\nHome Screen (Screen 1)\n  |\n  | -- Tap button to go to -->\n  |\nSecond Screen (Screen 2)\n```\n\nHere's how you would typically navigate from Screen 1 to Screen 2 in Flutter using the `Navigator`:\n\n```dart\n// In Screen 1's button's onPressed callback:\n// This pushes a new route (Screen 2) onto the navigator\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()),\n);\n```\n\n**Explanation:**\n\n*   `Navigator.push()` is the method we use to add a new screen to the stack.\n*   `context` tells Flutter where in the widget tree we are, so it knows which `Navigator` to use (we'll talk more about `of(context)` later).\n*   `MaterialPageRoute` is a specific type of **[Route](02_route_.md)** that provides platform-adaptive transitions (like sliding from the side on Android or fading on iOS). The `builder` creates the widget for the new screen (`SecondScreen`).\n\nNow, on the `SecondScreen`, we need a way to go back to the `HomeScreen`.\n\n```dart\n// In Screen 2's button's onPressed callback:\n// This pops the current route (Screen 2) off the navigator\nNavigator.pop(context);\n```\n\n**Explanation:**\n\n*   `Navigator.pop()` is the method to remove the top screen from the stack. It takes us back to the screen below (in this case, the `HomeScreen`).\n*   Again, `context` is used to find the correct `Navigator`.\n\nSee? It's like adding and removing cards from a deck! `push` adds a card, and `pop` removes the top one.\n\n## Understanding Navigator.of(context)\n\nIn the code snippets above, you might have noticed `Navigator.push(context, ...)` and `Navigator.pop(context)`. What's that `context` doing there?\n\nIn Flutter, the `context` is like an address for a widget's location in the widget tree. A `Navigator` widget lives somewhere in your app's widget tree (often managed by `MaterialApp` or `WidgetsApp`). When you call `Navigator.of(context)`, you are asking Flutter to find the nearest `Navigator` widget in the widget tree **above** the widget associated with that `context`.\n\nThink of it as saying, \"Hey Flutter, find the `Navigator` that is in charge of the part of the screen I'm currently in.\"\n\nThis means that when you are building the UI for a screen and you want to navigate FROM that screen, you use the `context` provided to that screen's `build` method.\n\n## Peeking Under the Hood (Simple Version)\n\nSo, how does the `Navigator` actually manage these \"cards\" or **[Route](02_route_.md)**s internally?\n\nImagine the `Navigator` has a private list: `_history`. This list holds all the **[Route](02_route_.md)**s, ordered from the one at the bottom of the stack to the one currently visible at the top.\n\nWhen you call `Navigator.push(context, newRoute)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState` (the actual object that manages the state of the `Navigator`).\n2.  A new entry representing `newRoute` is added to the end of the `_history` list.\n3.  The `NavigatorState` performs some internal updates. It tells the new **[Route](02_route_.md)** it's been added (`route.didAdd()`) or pushed (`route.didPush()`), and it tells the previous top **[Route](02_route_.md)** that something new is on top of it (`previousRoute.didChangeNext()`).\n4.  It then instructs Flutter's `Overlay` widget to display the visual content of the new **[Route](02_route_.md)**. The `Overlay` is like a special container that can layer widgets on top of each other, perfect for showing one screen on top of another.\n5.  An animation plays to transition the new screen into view.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>MyWidget: Tap Button\n    MyWidget->>NavigatorState: Navigator.push(context, RouteB)\n    NavigatorState->>NavigatorState: Add RouteB to _history\n    NavigatorState->>RouteB: Initialize and Install\n    NavigatorState->>RouteA: didChangeNext(RouteB)\n    NavigatorState->>RouteB: didPush() (start animation)\n    NavigatorState->>Overlay: Add RouteB's visual content\n    RouteB->>NavigatorState: Animation complete\n    NavigatorState->>RouteB: didComplete() (animation)\n```\n\nAnd when you call `Navigator.pop(context, result)`:\n\n1.  The `Navigator.of(context)` finds the correct `NavigatorState`.\n2.  The `NavigatorState` tells the current top **[Route](02_route_.md)** that it's being popped (`route.didPop(result)`). This is where the **[Route](02_route_.md)** can return an optional `result` back to the screen that pushed it.\n3.  If the **[Route](02_route_.md)** allows itself to be popped (most do), the `NavigatorState` removes it from the `_history` list.\n4.  It tells the **[Route](02_route_.md)** that's now at the top that the route above it has been popped (`newTopRoute.didPopNext(poppedRoute)`).\n5.  It removes the popped **[Route](02_route](02_route_).md)'s visual content from the `Overlay`.\n6.  An animation plays to transition back to the previous screen.\n7.  Finally, after any exit animations, the popped **[Route](02_route_.md)** is disposed of.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant RouteA\n    participant RouteB\n\n    User->>SecondScreenWidget: Tap Back Button\n    SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n    NavigatorState->>RouteB: didPop(result) (start animation)\n    RouteB->>NavigatorState: didComplete() (animation)\n    NavigatorState->>NavigatorState: Remove RouteB from _history\n    NavigatorState->>RouteA: didPopNext(RouteB)\n    NavigatorState->>Overlay: Remove RouteB's visual content\n    NavigatorState->>RouteB: dispose()\n```\n\n## Code Snippets from the Flutter Source\n\nLet's look at a couple of simplified snippets from the `navigator.dart` file to see how some of this is handled in the actual Flutter code.\n\nThe `Navigator` class definition:\n\n```dart\nclass Navigator extends StatefulWidget {\n  // ... properties like pages, onGenerateRoute, etc.\n\n  // Static methods for navigation (what you'll use most often)\n  static Future<T?> pushNamed<T extends Object?>(...) { ... }\n  static Future<T?> push<T extends Object?>(...) { ... }\n  static void pop<T extends Object?>(...) { ... }\n  // ... other navigation methods\n\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    // This is the helper function to find the NavigatorState\n    // It looks up the widget tree starting from the provided context\n    // ...\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n```\n\nThis snippet shows that `Navigator` is a `StatefulWidget`, meaning it has mutable state that changes over time (the stack of routes!). It also defines the handy static methods (`push`, `pop`, `pushNamed`, etc.) that you'll call on `Navigator.of(context)`. The `createState()` method creates the `NavigatorState` where the actual work happens.\n\nInside the `NavigatorState` class (which extends `State<Navigator>` and implements `RestorationMixin`):\n\n```dart\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History(); // This conceptually represents the stack of routes\n\n  // ... other internal variables and methods\n\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped; // Returns a Future that completes when the route is popped\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() { _debugLocked = true; return true; }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry); // Add the new route entry to the internal history list\n    _flushHistoryUpdates(); // Process changes and update UI\n    assert(() { _debugLocked = false; return true; }());\n    _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n     assert(!_debugLocked);\n     assert(() { _debugLocked = true; return true; }());\n     final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n     // ... logic to handle popping based on route properties\n     entry.pop<T>(result); // Mark the entry for popping with the result\n     _flushHistoryUpdates(rearrangeOverlay: false); // Process changes\n     assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n     assert(() { _debugLocked = false; return true; }());\n     _afterNavigation(entry.route); // Handle things like cancelling gestures\n  }\n\n  // ... build method to create the Overlay and handle gestures\n}\n```\n\nThis shows the `_history` list, where the `_RouteEntry` objects (which wrap our **[Route](02_route_.md)**s) are stored. You can also see simplified versions of the `push` and `pop` methods, which add/remove entries from `_history` and then call `_flushHistoryUpdates` to make the changes visible.\n\nNotice how `push` returns `route.popped`. This is the `Future` we talked about earlier! It lets you know when the pushed route eventually gets popped and gives you access to its result.\n\n## Conclusion\n\nIn this chapter, we introduced the Flutter `Navigator`. We learned that it manages a stack of **[Route](02_route_.md)**s, allowing users to navigate between different screens in an app. We saw how easy it is to `push` new screens onto the stack and `pop` back to previous ones using `Navigator.of(context)`. We also peeked at the internal `_history` list the `NavigatorState` uses to keep track of the route stack.\n\nIn the next chapter, we'll dive deeper into what a **[Route](02_route_.md)** is and explore different types of **[Route](02_route_.md)**s you can use with the `Navigator`.\n\n[Chapter 2: Route](02_route_.md)\n---\n# Chapter 2: Route\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 1: Navigator](01_navigator_.md), we learned that the `Navigator` is like a stack of cards, and it helps us move between different screens in our app using `push` and `pop`. But what *are* those cards? This chapter is all about the cards themselves: the `Route`.\n\nThink of a **Route** as the recipe for a single screen or \"page\" in your app. It's not the screen itself, but rather an instruction set for the `Navigator` on *how* to display that screen and manage its lifecycle.\n\nImagine our simple app from the last chapter again:\n\n```\nHome Screen (Screen 1 - Tap button to go to Screen 2)\n  |\n  | -- represents navigating --\n  |    (managed by Navigator)\n  |\nSecond Screen (Screen 2 - Tap button to go back)\n```\n\nEach of these screens, \"Home Screen\" and \"Second Screen,\" is represented by a `Route` in Flutter. When you `push` something onto the `Navigator`, you're essentially putting a `Route` object on top of the stack. When you `pop`, you're removing the top `Route`.\n\n## What does a Route do?\n\nA `Route` object holds all the information the `Navigator` needs to manage a screen, such as:\n\n*   **What widget to display:** This is the actual visual content of your screen (we'll often call this the \"page\").\n*   **How it animates:** When a `Route` is pushed or popped, it usually comes with a transition animation (like sliding or fading). The `Route` helps define this.\n*   **Whether it can be popped:** Does hitting the back button or calling `pop` on this screen work? Some routes might say \"no.\"\n*   **What value it returns:** Remember how we mentioned routes can return a result when popped? The `Route` facilitates this.\n\nIn short, the `Route` is the abstract idea of a navigable entry in your app's history, managed by the `Navigator`.\n\n## Our First Route in Action\n\nIn [Chapter 1: Navigator](01_navigator_.md), we used `MaterialPageRoute`. Let's look at that snippet again:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => SecondScreen()), // This is our Route!\n);\n```\n\nHere, `MaterialPageRoute` is a concrete type of `Route`. It's a pre-built recipe that knows how to create a full-screen mobile-platform-style animated transition.\n\nThe important part for the `Route` itself is the `builder` property.\n\n```dart\nMaterialPageRoute(\n  builder: (BuildContext context) {\n    // This function builds the widget for your screen (the \"page\")\n    return SecondScreen();\n  }\n)\n```\n\nThe `builder` is a function that takes a `BuildContext` and returns the widget tree for the screen this `Route` represents. So, our `SecondScreen` widget is the actual visual content, and the `MaterialPageRoute` is the `Route` object telling the `Navigator` how to handle that content.\n\nLet's simplify the `SecondScreen` for clarity:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Second Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This uses the Navigator to pop this Route off the stack\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd our first screen:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Import our second screen\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home Screen'),\n      ),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push the MaterialPageRoute onto the Navigator\n            Navigator.push(\n              context,\n              MaterialPageRoute(builder: (context) => const SecondScreen()),\n            );\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nIn this setup:\n\n*   `HomeScreen` is a widget.\n*   `SecondScreen` is the widget that visually represents the content of our second route.\n*   `MaterialPageRoute` is the `Route` instance that contains the `SecondScreen` widget recipe (`builder`) and tells the `Navigator` how to animate and manage this page.\n\n## Route Settings\n\nEvery `Route` also has `settings`. These are like extra details about the `Route`. The most common piece of `settings` you'll encounter is the `name`.\n\n```dart\nMaterialPageRoute(\n  settings: const RouteSettings(name: '/secondScreen'), // Add a name\n  builder: (context) => const SecondScreen(),\n);\n```\n\nAssigning a `name` allows you to navigate to routes using their name (which is super useful for larger apps), like with `Navigator.pushNamed`. We saw this briefly in [Chapter 1: Navigator](01_navigator_.md).\n\nLet's look at a code snippet from Flutter's `navigator.dart` file that defines `RouteSettings`:\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis confirms that `RouteSettings` holds an optional `name` and optional `arguments`. We'll learn more about arguments and how they're used with named routes in later chapters.\n\n## How Routes Interact with the Navigator Internals (Simplified)\n\nWe saw in [Chapter 1: Navigator](01_navigator_.md) a simplified diagram of how the `Navigator` manages its `_history` list. Let's refine that slightly to show where the `Route` fits in.\n\nImagine the `NavigatorState` has a list of internal entries, let's call them `_RouteEntry`. Each `_RouteEntry` wraps a `Route` object and keeps track of its internal state (is it animating? is it visible? etc.).\n\nWhen you call `Navigator.push(context, someRoute)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry` in its `_history` list.\n2.  It creates a new `_RouteEntry` wrapping your `someRoute`.\n3.  This new `_RouteEntry` is conceptually added to the end of the `_history` list.\n4.  The `NavigatorState` tells the new route it's being pushed (`route.didPush()`).\n5.  The new route gets added to the `Overlay` (which is where actual widgets live) and starts its entry animation.\n6.  The previous top route is told that a new route is above it (`previousRoute.didChangeNext(newRoute)`).\n7.  Once the animation finishes, the new route's internal state is updated to `idle`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant MyWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry\n    participant NewRouteEntry(wraps someRoute)\n    alt Navigator.push(context, someRoute)\n        User->>MyWidget: Tap Button\n        MyWidget->>NavigatorState: Navigator.push(context, someRoute)\n        NavigatorState->>NavigatorState: Find CurrentRouteEntry\n        NavigatorState->>NewRouteEntry(wraps someRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add NewRouteEntry to List\n        NewRouteEntry(wraps someRoute)->>someRoute: didPush()\n        NavigatorState->>Overlay: Add someRoute's visual content\n        CurrentRouteEntry->>CurrentRouteEntry: didChangeNext(someRoute)\n    end\n```\n\nWhen you call `Navigator.pop(context)`:\n\n1.  The `NavigatorState` finds the top visible `_RouteEntry`.\n2.  It tells that route it's being popped (`route.didPop(result)`). The route performs its exit animation.\n3.  Once the animation is done, the `_RouteEntry` is marked for final removal.\n4.  The `NavigatorState` removes the `_RouteEntry` and its content from the `_history` list and the `Overlay`.\n5.  The route that's now at the top is told that the route above it has been popped (`newTopicRoute.didPopNext(poppedRoute)`).\n6.  Finally, the popped `Route` object is fully disposed.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant SecondScreenWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant CurrentRouteEntry(wraps SecondRoute)\n    participant PreviousRouteEntry\n\n    alt Navigator.pop(context)\n        User->>SecondScreenWidget: Tap Back Button\n        SecondScreenWidget->>NavigatorState: Navigator.pop(context)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): didPop(result) (starts animation)\n        CurrentRouteEntry(wraps SecondRoute)->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove CurrentRouteEntry\n        NavigatorState->>Overlay: Remove someRoute's visual content\n        PreviousRouteEntry->>PreviousRouteEntry: didPopNext(someRoute)\n        NavigatorState->>CurrentRouteEntry(wraps SecondRoute): dispose()\n    end\n```\n\nNotice that the actual `Route` object (like our `MaterialPageRoute`) exists independently of the `_RouteEntry`. The `_RouteEntry` is the `Navigator`'s internal bookkeeper for that specific `Route` within its stack.\n\n## Code Snippet: The Abstract `Route` Class\n\nLet's look at the abstract definition of `Route` in `navigator.dart`. This is what all specific route types like `MaterialPageRoute` are built upon.\n\n```dart\n/// An abstraction for an entry managed by a [Navigator].\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    // ... memory allocation logging ...\n  }\n\n  // The settings for this route (name, arguments)\n  RouteSettings get settings;\n\n  // Called when the route is inserted into the navigator.\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  // Called after install when the route is pushed onto the navigator.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() { /* ... */ }\n\n  // Called after install when the route is added without transition.\n  @protected\n  @mustCallSuper\n  void didAdd() { /* ... */ }\n\n  // Called after install when the route replaced another.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  @Deprecated('Use popDisposition instead.')\n  Future<RoutePopDisposition> willPop() async { /* ... */ }\n\n  // Returns whether calling Navigator.maybePop should do anything.\n  RoutePopDisposition get popDisposition { /* ... */ }\n\n  // Called after a route pop was handled.\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) { /* ... */ }\n\n  // Returns the result to use if Navigator.pop is called with null.\n  T? get currentResult => null;\n\n  // A future that completes when this route is popped.\n  Future<T?> get popped;\n\n  // A request was made to pop this route. Returns true if the navigator should pop.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // The route was popped or is being removed.\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) { /* ... */ }\n\n  // The route above this one was popped.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  // This route's next route changed.\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  // This route's previous route changed.\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  // Called when the internal state of the route has changed.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  // Called when the Navigator's external state has changed.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  // Discards resources used by the object.\n  @mustCallSuper\n  @protected\n  void dispose() { /* ... */ }\n\n  // Whether this route is the top-most route.\n  bool get isCurrent;\n\n  // Whether this route is the bottom-most route.\n  bool get isFirst;\n\n  // Whether this route is on the navigator.\n  bool get isActive;\n\n  // ... other properties and methods ...\n}\n```\n\nThis abstract class shows the core methods that any `Route` implementation (like `MaterialPageRoute`) must handle. Things like `didPush`, `didPop`, `didComplete`, and interaction methods like `isCurrent` and `isFirst` are all defined here. This provides a consistent interface for the `Navigator` to interact with any type of `Route`.\n\n## Conclusion\n\nIn this chapter, we zoomed in on the `Route`, understanding it as the \"recipe\" for a screen that the `Navigator` uses to manage the app's history stack. We saw how a `Route` defines not just the visual content but also how it interacts with the `Navigator`, including animations and pop behavior. We looked at `MaterialPageRoute` as a common example and explored the base `Route` class definition.\n\nNow that we understand the building blocks of navigation (`Navigator` and `Route`), we'll look at the little helper object, `RouteSettings`, in more detail and see how it facilitates things like named routes and passing data in the next chapter.\n\n[Chapter 3: RouteSettings](03_routesettings_.md)\n---\n# Chapter 3: RouteSettings\n\nWelcome back, navigators! In the previous chapters, we learned about the fundamental concepts of mobile navigation in Flutter: the [Navigator](01_navigator_.md) (our stack manager) and the [Route](02_route_.md) (the recipe for a screen).\n\nNow, let's look at something that adds more details and flexibility to our routes: **RouteSettings**.\n\nImagine each [Route](02_route_.md) is a playing card representing a screen in our app. What information might we want to write on the back of that card? Maybe a name for the screen, or some extra data it needs to display correctly. That's what `RouteSettings` are for!\n\n`RouteSettings` are simple objects attached to a [Route](02_route_.md) that provide contextual information about that route, specifically its **name** and any **arguments** passed to it.\n\n## Why do we need RouteSettings?\n\nLet's revisit our simple app with a home screen and a second screen. In [Chapter 2: Route](02_route_.md), we pushed our `SecondScreen` like this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nThis worked fine. But what if our app grew larger and had many screens? Remembering to create `MaterialPageRoute` instances everywhere could become cumbersome. Also, what if we wanted to navigate to a screen but needed to give it some specific information?\n\nFor example, maybe our second screen should display details about a specific user. We need a way to tell the `SecondScreen` *which* user's details to show.\n\nThis is where `RouteSettings` become incredibly useful, particularly with **named routes**.\n\n## Using Named Routes with RouteSettings\n\nInstead of building a `MaterialPageRoute` directly every time, we can give our routes names (like URLs on the web!) and let the [Navigator](01_navigator_.md) generate the route based on that name.\n\nLet's set up our app to use named routes. We'll add a `routes` map to our `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'second_screen.dart'; // Assuming this file exists\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      '/secondScreen': (context) => const SecondScreen(), // Our second screen has the name '/secondScreen'\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name!\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// second_screen.dart remains the same\n// import 'package:flutter/material.dart';\n// class SecondScreen extends StatelessWidget {\n//   const SecondScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('Second Screen')),\n//       body: Center(\n//         child: ElevatedButton(\n//           onPressed: () {\n//             Navigator.pop(context);\n//           },\n//           child: const Text('Go Back!'),\n//         ),\n//       ),\n//     );\n//   }\n// }\n```\n\nNow, in our `HomeScreen`, instead of this:\n\n```dart\nNavigator.push(\n  context,\n  MaterialPageRoute(builder: (context) => const SecondScreen()),\n);\n```\n\nWe can simply do this:\n\n```dart\nNavigator.pushNamed(context, '/secondScreen');\n```\n\nThis is cleaner, especially when we might navigate to the same screen from multiple places. The `'/secondScreen'` string is the `name` property stored in the `RouteSettings` of the route that gets created.\n\nWhen we call `Navigator.pushNamed(context, '/secondScreen')`, here's what happens (simplified):\n\n1.  `Navigator.of(context)` finds the nearest [NavigatorState](01_navigator_.md).\n2.  The [NavigatorState](01_navigator_.md) looks in its `routes` map (provided in `MaterialApp`).\n3.  It finds the entry for `'/secondScreen'` which points to `(context) => const SecondScreen()`.\n4.  It calls this builder *and* creates a `RouteSettings` object behind the scenes with `name: '/secondScreen'`.\n5.  It then creates the actual [Route](02_route_.md) (like a `MaterialPageRoute`) using the builder and attaches these `RouteSettings` to it.\n6.  Finally, it pushes this new [Route](02_route_.md) onto the stack, just like a regular `push`.\n\nSo, even with named routes, a [Route](02_route_.md) object is still created, and it carries the `RouteSettings` with the name we used.\n\n## Passing Arguments with RouteSettings\n\nThe other significant property of `RouteSettings` is `arguments`. This allows us to pass data to the screen we're navigating to.\n\nLet's go back to our user detail example. We want to navigate to a `UserDetailScreen` and tell it which user to display.\n\nFirst, we need a new screen widget that knows how to receive arguments. We can access the arguments through the `RouteSettings` of the current route using `ModalRoute.of(context)!.settings.arguments`.\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass UserDetailScreen extends StatelessWidget {\n  const UserDetailScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // We expect the arguments to be a String (the user ID)\n    final userId = ModalRoute.of(context)!.settings.arguments as String?;\n\n    if (userId == null) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Error')),\n        body: const Center(child: Text('User ID not provided')),\n      );\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('User Details')),\n      body: Center(\n        child: Text('Displaying details for User ID: $userId'),\n      ),\n    );\n  }\n}\n```\n\nNow, we need to update our `MaterialApp`'s `routes` and our `HomeScreen` to push this new screen and pass the user ID.\n\nWe *could* add a new entry to the `routes` map:\n\n```dart\nroutes: {\n  // ... other routes\n  '/userDetails': (context) => const UserDetailScreen(),\n},\n```\n\nAnd push with arguments:\n\n```dart\nNavigator.pushNamed(context, '/userDetails', arguments: 'user123');\n```\n\nLet's integrate this into our example. We'll replace the button in `HomeScreen` to go to `UserDetailScreen` instead of `SecondScreen`.\n\n```dart\nimport 'package:flutter/material.dart';\n// import 'second_screen.dart'; // No longer needed for this example\nimport 'user_detail_screen.dart'; // Import our new user detail screen\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Named Routes with Arguments Demo',\n    initialRoute: '/', // Start on the home screen\n    routes: {\n      '/': (context) => const HomeScreen(), // Our home screen has the name '/'\n      // We won't explicitly list /userDetails here,\n      // we'll use onGenerateRoute for more flexibility\n      // for handling arguments.\n      // '/userDetails': (context) => const UserDetailScreen(),\n    },\n    // We'll use onGenerateRoute to handle named routes,\n    // especially those with arguments.\n    onGenerateRoute: (RouteSettings settings) {\n      // The settings object contains the name and arguments!\n      print('Navigating to: ${settings.name}');\n      print('Arguments: ${settings.arguments}');\n\n      if (settings.name == '/userDetails') {\n        // We create the route here, using the arguments from settings\n        return MaterialPageRoute(\n          builder: (context) => const UserDetailScreen(),\n          settings: settings, // Pass the settings to the new route!\n        );\n      }\n      // Handle other named routes here if needed, or return null for onUnknownRoute\n\n      // If the named route is not /userDetails or /, let the system handle it\n      // (or fall back to onUnknownRoute if defined)\n      return null; // Indicates route was not handled by onGenerateRoute\n    },\n  ));\n}\n\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Navigate using the route name and pass arguments!\n            Navigator.pushNamed(context, '/userDetails', arguments: 'user456');\n          },\n          child: const Text('Go to User Details (user456)'),\n        ),\n      ),\n    );\n  }\n}\n\n// Make sure user_detail_screen.dart is in the same project\n// import 'package:flutter/material.dart';\n// class UserDetailScreen extends StatelessWidget {\n//   const UserDetailScreen({super.key});\n//   @override\n//   Widget build(BuildContext context) {\n//     final userId = ModalRoute.of(context)!.settings.arguments as String?;\n//     if (userId == null) {\n//       return Scaffold(\n//         appBar: AppBar(title: const Text('Error')),\n//         body: const Center(child: Text('User ID not provided')),\n//       );\n//     }\n//     return Scaffold(\n//       appBar: AppBar(title: const Text('User Details')),\n//       body: Center(\n//         child: Text('Displaying details for User ID: $userId'),\n//       ),\n//     );\n//   }\n// }\n```\n\nNotice how we are now using the `onGenerateRoute` callback in `MaterialApp`. This callback receives the `RouteSettings` object directly. We inspect `settings.name` and `settings.arguments` inside `onGenerateRoute` to decide which route to create and how to configure it. It's crucial to **pass the `settings` object** to the `MaterialPageRoute` (or any custom [Route](02_route_.md) you create) so that the route itself and the widgets built by it can access these settings later (like our `UserDetailScreen` does with `ModalRoute.of(context)!.settings`).\n\nThis pattern of using `onGenerateRoute` with `RouteSettings` is very common and powerful for managing navigation in larger apps, especially when routes require specific initial data.\n\n## RouteSettings Under the Hood (Simplified)\n\nWe've already seen the definition of `RouteSettings` from the Flutter source code in [Chapter 2: Route](02_route_.md):\n\n```dart\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n```\n\nThis is a simple, immutable class (meaning its values don't change after it's created). It just holds the `name` (a `String?`) and `arguments` (an `Object?`).\n\nHow do these settings get attached to a [Route](02_route_.md) and then accessed by the widgets on that route?\n\n1.  **Creation:** When a [Route](02_route_.md) is created (either directly like `MaterialPageRoute(...)` or by the [Navigator's](01_navigator_.md) `onGenerateRoute` or `routes` map), it's typically given a `RouteSettings` object. For `MaterialPageRoute`, you pass it as a constructor argument (`settings: ...`). For named routes, the [Navigator](01_navigator_.md) creates one internally based on the pushed name and arguments.\n2.  **Attachment:** The [Route](02_route_.md) object has a `settings` property that holds this `RouteSettings` instance. Looking back at the abstract `Route<T>` class definition from [Chapter 2: Route](02_route_.md), you'll see the `RouteSettings get settings;` getter.\n3.  **Access:** Widgets on a route, like our `UserDetailScreen`, can access the `Route` they belong to. For modal routes (like `MaterialPageRoute` or dialogs that cover the screen), the easiest way to get the current `Route` (and thus its `RouteSettings`) is using `ModalRoute.of(context)`. `ModalRoute` is a subclass of `Route` that provides additional capabilities, including making the current route available via `ModalRoute.of`.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MaterialApp\n    participant onGenerateRoute\n    participant RouteSettingsObj\n    participant UserDetailRoute(wraps UserDetailScreen)\n    participant UserDetailScreenWidget\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/userDetails', arguments: 'user456')\n    NavigatorState->>MaterialApp: Lookup route for '/userDetails'\n    MaterialApp->>onGenerateRoute: Call onGenerateRoute(settings: RouteSettings(name: '/userDetails', arguments: 'user456'))\n    onGenerateRoute->>RouteSettingsObj: Receive RouteSettings object\n    onGenerateRoute->>UserDetailRoute(wraps UserDetailScreen): Create MaterialPageRoute(settings: RouteSettingsObj, builder: ...)\n    NavigatorState->>NavigatorState: Add UserDetailRoute to _history\n    NavigatorState->>Overlay: Display UserDetailRoute's content\n    UserDetailRoute(wraps UserDetailScreen)->>UserDetailScreenWidget: Build self\n    UserDetailScreenWidget->>UserDetailScreenWidget: ModalRoute.of(context).settings\n    UserDetailScreenWidget->>RouteSettingsObj: Get settings object\n    UserDetailScreenWidget->>UserDetailScreenWidget: Access settings.arguments ('user456')\n    UserDetailScreenWidget->>UserDetailScreenWidget: Use 'user456' to build UI\n```\n\nThis diagram shows how the `RouteSettings` object is created during `pushNamed`, passed to `onGenerateRoute`, attached to the `UserDetailRoute`, and finally accessed by the `UserDetailScreenWidget` using `ModalRoute.of(context)!.settings`.\n\n## Conclusion\n\nIn this chapter, we explored `RouteSettings`, the simple but important helper object that adds context and information to our [Route](02_route_.md)s. We learned how `RouteSettings` enable named routes and, crucially, how they allow us to pass arguments between screens using `Navigator.pushNamed` and retrieve them on the destination screen using `ModalRoute.of(context)`. This provides a clean and structured way to handle navigation data in Flutter applications, especially when combined with `onGenerateRoute`.\n\nUnderstanding `RouteSettings` is key to effectively using named routes and passing data, which are fundamental patterns in Flutter navigation. In the next chapter, we'll look at another core piece of the navigation puzzle: the `Page` abstraction.\n\n[Chapter 4: Page](04_page_.md)\n---\n# Chapter 4: Page\n\nWelcome back to our tour of Flutter navigation! In the previous chapters, we explored the [Navigator](01_navigator_.md) (our screen manager) and the [Route](02_route_.md) (the recipe for a screen, often with a name and arguments via [RouteSettings](03_routesettings_.md)).\n\nSo far, we've been using the \"imperative\" style of navigation. This means we tell the [Navigator](01_navigator_.md) exactly what to do with method calls like `push` and `pop`.\n\nNow, let's introduce a more \"declarative\" way to handle navigation, especially when your app's history is driven by data. This is where the **Page** comes in.\n\n## What is a Page?\n\nThink of a **Page** as a blueprint for a [Route](02_route_.md).\n\nInstead of telling the [Navigator](01_navigator_.md), \"Okay, now `push` this specific [Route](02_route_.md),\" you can give the [Navigator](01_navigator_.md) a **list of Page objects**. The [Navigator](01_navigator_.md) then looks at this list and figures out what [Route](02_route_.md)s it needs to build, add, remove, or update to match the list you provided.\n\nThis is particularly powerful when your app's state naturally lends itself to being represented as a list of active screens.\n\nLet's consider a practical example: building a dynamic list of screens based on user interactions or data from the internet. Imagine a simple app that shows a list of items, and tapping an item adds a detail screen for that item to the navigation stack.\n\nUsing the imperative style, you'd manage a list of routes yourself and call `push` and `pop`. With the Page-based approach, you would manage a `List<Page>` and provide it to the [Navigator](01_navigator_.md).\n\n## Page vs. RouteSettings\n\nYou might notice that `Page` sounds a lot like [RouteSettings](03_routesettings_.md) because they both hold information about a screen. In fact, `Page` is a specific *type* of [RouteSettings](03_routesettings_.md)!\n\nLooking back at the definition of `Page` in `navigator.dart` (which we saw briefly in the previous chapters):\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// ... (comments omitted for brevity)\nabstract class Page<T> extends RouteSettings { // <-- Extends RouteSettings!\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name, // <-- Inherits name from RouteSettings\n    super.arguments, // <-- Inherits arguments from RouteSettings\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  // ... other properties specific to Page ...\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nSo, a `Page` *is* [RouteSettings](03_routesettings_.md), but it adds extra capabilities essential for this declarative style:\n\n1.  **`key`:** Used for identifying pages when the list changes (similar to how keys are used in Flutter lists).\n2.  **`createRoute`:** This is the crucial part! It's a method that knows how to create the actual [Route](02_route_.md) object (like `MaterialPageRoute`) that the [Navigator](01_navigator_.md) will put on its stack.\n\nWhen you provide the [Navigator](01_navigator_.md) with a `List<Page>`, it iterates through the list. For each `Page`, it potentially calls `page.createRoute(context)` to get the [Route](02_route_.md) that corresponds to that page and adds it to its internal stack if needed.\n\n## How Pages Work with Navigator.pages\n\nThe Page-based approach uses the `pages` property of the `Navigator` (which is automatically managed by `MaterialApp.router` or `WidgetsApp.router`, but you can use it directly with a plain `Navigator`).\n\nHere's a simplified idea of how it works:\n\n1.  You maintain a `List<Page>`. This list represents the desired state of the [Navigator's](01_navigator_.md) stack.\n2.  You pass this list to the `pages` property of a `Navigator` widget.\n3.  When the `pages` list changes (because you changed your app's state and rebuilt the widget tree), the [Navigator](01_navigator_.md) compares the new list with the old list of pages it was displaying.\n4.  Based on this comparison (using the page `key` to identify matching pages), the [Navigator](01_navigator_.md) figures out which corresponding [Route](02_route_.md)s need to be added, removed, or reordered in its internal stack.\n5.  It then performs the necessary operations (pushing new routes, popping old ones) to make its internal stack match the list of `pages`.\n\nImagine you start with a list `[ HomePage1 ]`. The [Navigator](01_navigator_.md) builds and shows the route for `HomePage1`.\n\n```mermaid\ngraph TD\n    A[Navigator] --> B[Route for HomePage1]\n    B --> C[Overlay Entry for HomePage1]\n```\n\nThen, your app state changes, and you rebuild the [Navigator](01_navigator_.md) with the list `[ HomePage1, DetailsPageX ]`.\n\nThe [Navigator](01_navigator_.md):\n\n1.  Sees `HomePage1` is still in the list (and likely has the same key). It keeps the existing [Route](02_route_.md) for it.\n2.  Sees `DetailsPageX` is new. It calls `DetailsPageX.createRoute(context)` to build the [Route](02_route_.md) for it.\n3.  Pushes the new `DetailsPageX` route onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (add Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome, DetailsX -> RouteForDetails]\n    Navigator->>Navigator: Compares old([RouteForHome]) and new history\n    Navigator->>Navigator: Finds RouteForHome matches HomePage1\n    Navigator->>RouteForDetails: Calls DetailsPageX.createRoute(context)\n    Navigator->>Navigator: Pushes RouteForDetails onto stack\n    Navigator->>Overlay: Adds Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didChangeNext(RouteForDetails)\n```\n\nIf the list changes back to `[ HomePage1 ]`, the [Navigator](01_navigator_.md) sees `DetailsPageX` is gone and pops its corresponding [Route](02_route_.md).\n\n```mermaid\nsequenceDiagram\n    participant AppState\n    participant YourWidget\n    participant Navigator\n    participant RouteForHome\n    participant RouteForDetails\n\n    AppState->>YourWidget: Data changes (remove Details for X)\n    YourWidget->>Navigator: Rebuild with pages: [Home -> RouteForHome]\n    Navigator->>Navigator: Compares old([RouteForHome, RouteForDetails]) and new history\n    Navigator->>Navigator: Sees RouteForDetails is gone\n    Navigator->>RouteForDetails: didPop(null) (starts exit animation)\n    Navigator->>Navigator: Removes RouteForDetails from history (after animation)\n    Navigator->>Overlay: Removes Overlay Entry for RouteForDetails\n    Navigator->>RouteForHome: didPopNext(RouteForDetails)\n```\n\nThis \"diffing\" and updating process is handled automatically by the [Navigator](01_navigator_.md) when you use the `pages` list.\n\n## Implementing a Simple Page\n\nTo use the Page-based approach, you often create your own subclass of `Page`. A minimal custom `Page` needs to implement the `createRoute` method.\n\nLet's create a `DetailPage` that can receive an item index.\n\n```dart\n// Import necessary Flutter packages\nimport 'package:flutter/material.dart';\n\n// Define our custom Page class\nclass DetailPage extends Page<void> { // Page takes a generic type for the return value\n  const DetailPage({\n    required this.itemIndex,\n    LocalKey? key, // Pages often use keys for identification\n  }) : super(key: key, name: '/detail/$itemIndex', arguments: itemIndex); // Pass info to super\n\n  final int itemIndex; // Data the page needs\n\n  // This is the crucial method: telling the Navigator how to create the Route\n  @override\n  Route<void> createRoute(BuildContext context) {\n    // We'll use a MaterialPageRoute, but you could use others or a custom one\n    return MaterialPageRoute<void>(\n      settings: this, // Pass the Page itself as settings so the Route knows its config\n      builder: (BuildContext context) {\n        // This builder creates the actual widget for the screen\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nExplanation:\n\n*   We create a class `DetailPage` that `extends Page<void>`. `void` means this page doesn't return a result when popped (like dialogs might).\n*   It has an `itemIndex` property which is the data this page needs.\n*   In the constructor, we call `super()` to pass the `key`, `name`, and `arguments` (the `itemIndex`) up to the base `Page` ([RouteSettings](03_routesettings_.md)) class. The `name` is helpful for debugging and potential deep linking.\n*   The `createRoute` method takes a `BuildContext` and returns a `Route<void>`.\n*   Inside `createRoute`, we create a `MaterialPageRoute`. This route *recipe* knows how to build the visual part (`Scaffold` with the item details) and how to animate.\n*   **Crucially**, we pass `this` (`DetailPage`) as the `settings` for the `MaterialPageRoute`. This ensures the created [Route](02_route_.md) object holds a reference back to the `Page` config that created it, which is important for the [Navigator's](01_navigator_.md) internal management.\n\nNow, instead of calling `Navigator.push(context, MaterialPageRoute(...))`, you would add instances of `DetailPage` to your `List<Page>` that is provided to the [Navigator].\n\n## Page and the Page-Based Navigator (Briefly)\n\nUsing `Navigator.pages` is typically done when you're managing your app's navigation state explicitly, often with a state management solution or a custom `Router`. The core idea is that you maintain a list of `Page` objects in your state, and whenever that list changes, you rebuild the `Navigator` with the new list.\n\nThe [Navigator](01_navigator_.md) then uses its `transitionDelegate` to efficiently update its route stack based on the old and new `pages` lists.\n\nFor a very simple example, imagine a widget that holds a list of pages in its state:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass MyNavigatorWidget extends StatefulWidget {\n  const MyNavigatorWidget({super.key});\n\n  @override\n  State<MyNavigatorWidget> createState() => _MyNavigatorWidgetState();\n}\n\nclass _MyNavigatorWidgetState extends State<MyNavigatorWidget> {\n  // The list of pages we want to display\n  final List<Page<dynamic>> _pages = <Page<dynamic>>[\n    // Start with a home page\n    MaterialPage<void>(\n      key: const ValueKey('HomePage'), // Add keys for Page-based navigation\n      child: Scaffold(\n        appBar: AppBar(title: const Text('Home')),\n        body: Center(\n          child: ElevatedButton(\n            onPressed: () {\n              // Add a detail page to the list!\n              setState(() {\n                _pages.add(const DetailPage(itemIndex: 1, key: ValueKey('Detail1')));\n              });\n            },\n            child: const Text('Go to Detail 1 (Page)'),\n          ),\n        ),\n      ),\n    ),\n  ];\n\n  // Callback for when a Page-based route is popped\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n    // If the route corresponds to a Page...\n    if (route.settings is Page) {\n      // Find the index of this page in our list\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        // Remove the page from our list\n        setState(() {\n          _pages.removeAt(index);\n        });\n        // Tell the Navigator that the pop was handled by us\n        return route.didPop(result); // Important: Tell the route it was popped\n      }\n    }\n    // If it's not a Page-based route we manage, let Navigator handle it\n    return false;\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Navigator(\n      key: const ValueKey('MyNavigator'), // Give the navigator a key\n      pages: List.of(_pages), // Pass the list of pages\n      onPopPage: _handlePopPage, // Handle pops from Page-based routes\n      // onGenerateRoute and onUnknownRoute are NOT used with Navigator.pages\n      // unless handling non-page-based routes pushed imperatively.\n    );\n  }\n}\n\n// Need our DetailPage from the previous example\n// class DetailPage extends Page ... { ... }\n```\n\nExplanation:\n\n*   We have a `_MyNavigatorWidgetState` that holds the `_pages` list.\n*   Initially, the list contains only one `MaterialPage`. We use `MaterialPage` here, which is a convenient pre-built `Page` that creates a simple `MaterialPageRoute`. Notice we give it a `key`.\n*   The `Navigator`'s `pages` property is set to `List.of(_pages)`. We create a *copy* (`List.of`) because the `Navigator` expects an immutable list.\n*   The `onPopPage` callback is essential when using `Navigator.pages`. When the user tries to pop a route that was created from our `pages` list, the [Navigator](01_navigator_.md) calls this. It's *our* responsibility to update the `_pages` list by removing the corresponding `Page` and then calling `route.didPop(result)` to finalize the pop operation on the route itself.\n*   When the button is tapped, we `setState` to add a `DetailPage` to our `_pages` list. This triggers a rebuild of `MyNavigatorWidget`.\n*   The `Navigator` sees the `_pages` list has changed, compares it to the old list, and adds the `DetailPage` route.\n*   When the detail page is popped (e.g., by the back button), `_handlePopPage` is called. We find the corresponding `DetailPage` in `_pages`, remove it, and call `route.didPop`. The `Navigator` then sees the list has changed again and removes the detail route.\n\nThis example is simplified, but it shows the core pattern: manage a list of `Page` objects and feed it to the `Navigator.pages` property. The [Navigator](01_navigator_.md) does the heavy lifting of updating the route stack.\n\n## Page Under the Hood (Simplified)\n\nWe already saw the definition of the abstract `Page` class which extends [RouteSettings](03_routesettings_.md).\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class Page<T> extends RouteSettings {\n  // ... properties like key, name, arguments, restorationId, canPop, onPopInvoked\n\n  /// Creates the [Route] that corresponds to this page.\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  // ... rest of the class ...\n}\n```\n\nThe key part is the `createRoute` method. Any concrete implementation of `Page` (like `MaterialPage` or our `DetailPage`) must provide this method.\n\nLet's look at how the [NavigatorState](01_navigator_.md) internally handles the `pages` list (simplified from `_updatePages` method in `navigator.dart`).\n\n1.  **Comparison:** The `NavigatorState` compares the incoming `widget.pages` list with its current internal list of route entries (`_history`). Pages are matched primarily by their `key` property or, if keys are absent, by their runtime type. If a page has no key, it makes comparison less reliable.\n2.  **Route Creation:** For any new `Page` in the `widget.pages` list that doesn't have a matching existing route entry, the [Navigator](01_navigator_.md) calls `page.createRoute(context)` to get the corresponding [Route](02_route_.md) object.\n3.  **State Transfer:** If an existing route entry matches an updated page (based on key/type), the `Page` object on the existing route entry is updated by calling `_updateSettings` on the internal `_RouteEntry`. The existing [Route](02_route_.md) associated with the entry is told that its settings have changed via `route.changedInternalState()`.\n4.  **Operations (Push/Pop/Remove):** Based on the difference between the lists, the [Navigator](01_navigator_.md) determines which entries need to be added (corresponding to new pages), which need to be removed (corresponding to missing pages), and the order of the remaining entries.\n5.  **Transition Delegate:** The `transitionDelegate` (like `DefaultTransitionDelegate`) is consulted to decide how new entries should animate in (e.g., `markForPush` or `markForAdd`) and how removed entries should animate out (e.g., `markForPop` or `markForRemove`).\n6.  **History Update:** The internal `_history` list is updated according to the decisions from the `transitionDelegate`. Entries marked for disposal are removed.\n7.  **Overlay & Animations:** The necessary [OverlayEntry](01_navigator_.md) objects for the new route entries are added to the [Navigator's](01_navigator_.md) `Overlay`, and the transition animations are started for routes marked for push or pop.\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare New Pages vs. Old History\n    alt Found new Page\n        NavigatorState->>NewPage(blueprint): Call NewPage.createRoute(context)\n        NewPage(blueprint)->>NewRoute: Returns NewRoute\n        NavigatorState->>_RouteEntry(wraps NewRoute): Create _RouteEntry\n        NavigatorState->>History(_RouteEntry List): Add _RouteEntry to List (marked for push/add)\n    end\n    alt Found missing Page\n        NavigatorState->>OldRouteEntry: Mark for pop/remove/complete\n    end\n    NavigatorState->>NavigatorState: Consult transitionDelegate\n    NavigatorState->>History(_RouteEntry List): Update _history list order/state\n    NavigatorState->>Overlay: Add/Remove OverlayEntries based on history\n    NavigatorState->>NavigatorState: Start animations for push/pop\n```\n\nThis high-level flow shows that the `Page` objects are the *input* to the `Navigator` in this paradigm. The `Navigator` takes these blueprints, creates the actual `Route` objects using `createRoute`, and manages its internal stack state to match the desired configuration described by the list of `Page`s.\n\n## Conclusion\n\nIn this chapter, we introduced the concept of a `Page`. We learned that a `Page` is a type of [RouteSettings](03_routesettings_.md) that adds a `key` and, crucially, a `createRoute` method, making it a blueprint for creating [Route](02_route_.md)s. We saw how the Page-based approach allows for declarative navigation by providing a list of `Page` objects to the `Navigator.pages` property. This enables the [Navigator](01_navigator_.md) to automatically manage its route stack to match the desired state represented by the list, simplifying navigation logic, especially in scenarios driven by dynamic data or complex state.\n\nNow that we understand how Pages are used as blueprints for routes in the declarative navigation model, we'll move on to another concept that helps the [Navigator](01_navigator_.md) make decisions: the `RoutePredicate`.\n\n[Chapter 5: RoutePredicate](05_routepredicate_.md)\n---\n# Chapter 5: RoutePredicate\n\nWelcome back, future Flutter navigators! In our previous chapters, we explored the [Navigator](01_navigator_.md) (the screen manager), the [Route](02_route_.md) (the screen recipe), [RouteSettings](03_routesettings_.md) (names and arguments), and the [Page](04_page_.md) (a blueprint for routes).\n\nToday, we're looking at another useful tool in the Navigator's kit: the **RoutePredicate**. While `push` adds routes and `pop` removes the top one, sometimes you need more control over *which* routes get removed from the stack. That's where a `RoutePredicate` comes in!\n\n## What is a RoutePredicate?\n\nA `RoutePredicate` is essentially a **function** that helps the [Navigator](01_navigator_.md) decide if a specific [Route](02_route_.md) meets certain criteria. Think of it like a filter or a test you can apply to each [Route](02_route_.md) in the [Navigator's](01_navigator_.md) history stack.\n\nThe [Navigator](01_navigator_.md) can use these predicates with methods like `popUntil` and `pushNamedAndRemoveUntil` to perform actions on multiple routes until a route that matches the predicate is found.\n\n## The Use Case: Clearing Navigation History\n\nImagine you have an app with a navigation flow like this:\n\nHome -> List -> Detail -> Edit -> Confirmation -> Home\n\nIf you are on the \"Confirmation\" screen and tap a button that says \"Finish,\" you probably want to go all the way back to the \"Home\" screen, removing \"Confirmation,\" \"Edit,\" and \"Detail\" from the history.\n\nUsing just `pop` wouldn't work easily; you'd have to call `pop` three times, only if you knew exactly how many screens were above the Home screen. This isn't flexible.\n\nA `RoutePredicate` allows you to say, \"Keep popping routes off the stack *until* you find the 'Home' route.\"\n\n## Using RoutePredicate with `popUntil`\n\nThe primary method where you'll use a `RoutePredicate` is `Navigator.popUntil`. This method traverses backwards through the [Navigator's](01_navigator_.md) history stack and pops routes until the provided predicate returns `true` for a route. The route that satisfies the predicate is *not* popped itself.\n\nLet's set up a simple example to demonstrate this. We'll have three screens: Home, Screen A, and Screen B. We'll navigate from Home -> Screen A -> Screen B, and then use `popUntil` from Screen B to go back to Home.\n\nFirst, let's define our screens with unique names in their `RouteSettings`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenA');\n          },\n          child: const Text('Go to Screen A'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Screen A\nclass ScreenA extends StatelessWidget {\n  const ScreenA({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen A')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/screenB');\n          },\n          child: const Text('Go to Screen B'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 3: Screen B\nclass ScreenB extends StatelessWidget {\n  const ScreenB({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Screen B')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // This is where we use popUntil!\n            Navigator.popUntil(context, (route) {\n              // Our predicate: check if the route is the Home Screen route ('/')\n              return route.settings.name == '/';\n            });\n          },\n          child: const Text('Go back to Home'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nNow, let's set up our `MaterialApp` with named routes:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Assuming screens.dart contains the screen widgets above\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Pop Until Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/screenA': (context) => const ScreenA(),\n      '/screenB': (context) => const ScreenB(),\n    },\n  ));\n}\n```\n\nIn this example:\n\n1.  We start on `/` (HomeScreen).\n2.  Tapping the button on `HomeScreen` pushes `/screenA`.\n3.  Tapping the button on `ScreenA` pushes `/screenB`.\n4.  Now the navigation stack is conceptually `[/, /screenA, /screenB]`.\n5.  On `ScreenB`, when the button is tapped, `Navigator.popUntil(context, (route) { return route.settings.name == '/'; });` is called.\n6.  The [Navigator](01_navigator_.md) looks at `/screenB`. Does its name equal '/'? No. It is popped.\n7.  The [Navigator](01_navigator_.md) looks at `/screenA`. Does its name equal '/'? No. It is popped.\n8.  The [Navigator](01_navigator_.md) looks at `/`. Does its name equal '/'? Yes! The predicate returns true. The popping stops.\n9.  The user is now back on the `HomeScreen`.\n\nThe `RoutePredicate` itself is this part:\n\n```dart\n(route) {\n  return route.settings.name == '/';\n}\n```\n\nIt's a function that takes one argument: a `Route<dynamic>` object. Inside the function, we check if the `settings.name` of that route is equal to '/'.\n\n## Common RoutePredicates\n\nWhile you can write any predicate function you need, Flutter provides some handy ones:\n\n*   **`(Route<dynamic> route) => false`**: This predicate always returns false. If used with `popUntil`, it would pop *all* routes until the last one (which won't be popped). If used with `pushNamedAndRemoveUntil`, it would remove *all* routes currently in the stack before pushing the new one.\n*   **`ModalRoute.withName('/someName')`**: This is a very common predicate. It returns a function that checks if a route is a `ModalRoute` (which most full-screen routes are) and if its `settings.name` matches the provided string. This is exactly what we used in our example with `ModalRoute.withName('/')`.\n\nLet's rewrite our `ScreenB` code using `ModalRoute.withName`:\n\n```dart\n// Inside Screen B's ElevatedButton onPressed:\nonPressed: () {\n  Navigator.popUntil(context, ModalRoute.withName('/'));\n},\n```\n\nThis is functionally identical to our previous code and is more concise. `ModalRoute.withName('/')` *returns* the predicate function we need.\n\n## Using RoutePredicate with `pushNamedAndRemoveUntil`\n\nAnother method that uses `RoutePredicate` is `Navigator.pushNamedAndRemoveUntil`. This method first pushes a new named route onto the stack and *then* removes all the routes below the new route until the predicate returns true.\n\nThe \"Confirmation -> Home\" example from earlier is a perfect fit for this. If the \"Finish\" button on \"Confirmation\" pushes the \"Home\" route and removes everything until the \"Home\" route is found *again* (the original one at the bottom of the stack).\n\nAssume we have a `ConfirmationScreen` widget and `/confirmation` route:\n\n```dart\n// Inside ConfirmationScreen's ElevatedButton onPressed:\nonPressed: () {\n  // Push the Home screen route and remove everything until we find\n  // the original Home screen route ('/')\n  Navigator.pushNamedAndRemoveUntil(\n    context,\n    '/', // The name of the new route to push\n    ModalRoute.withName('/') // The predicate: stop removing when we find '/'\n  );\n},\n```\n\nIn this scenario:\n\n1.  The stack is `[ /, /list, /detail, /edit, /confirmation ]`.\n2.  `pushNamedAndRemoveUntil` first prepares to push `/`.\n3.  It looks at `/confirmation`. Does it match `ModalRoute.withName('/')`? No. It's marked for removal.\n4.  It looks at `/edit`. Does it match? No. Marked for removal.\n5.  It looks at `/detail`. Does it match? No. Marked for removal.\n6.  It looks at `/list`. Does it match? No. Marked for removal.\n7.  It looks at `/`. Does it match? Yes! The predicate returns true. The process of identifying routes to remove stops.\n8.  The new route (`/`) is pushed, and simultaneously, the routes marked for removal (`/confirmation`, `/edit`, `/detail`, `/list`) are disposed of.\n9.  The stack is now just `[ / ]`.\n\nThis allows you to effectively \"reset\" part of the navigation stack or jump back to a known point while removing everything above it.\n\n## RoutePredicate Under the Hood (Simplified)\n\nA `RoutePredicate` is just a function signature. Looking at the Flutter code (`navigator.dart`):\n\n```dart\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n```\n\nThis tells us it's a function that accepts a `Route<dynamic>` as input and returns a `bool`. `true` means the predicate is satisfied, `false` means it's not.\n\nHow does the `NavigatorState` use this predicate internally? Let's focus on the `popUntil` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified)\nvoid popUntil(RoutePredicate predicate) {\n  assert(!_debugLocked);\n  assert(() { _debugLocked = true; return true; }());\n\n  // Find the last route that is current or has state that handles pops internally.\n  // We stop there.\n  _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  // Iterate backwards through the history\n  // We use candidate.route.willHandlePopInternally to handle routes that\n  // manage their own pop behavior (like nested navigators or forms).\n  // If a route handles pop internally (willHandlePopInternally is true),\n  // we try to pop it internally first (candidate.route.didPop(null)).\n  // If it still satisfies the predicate after internal pop, we stop.\n  // If not, or if it didn't handle it internally, we continue popping.\n  while (candidate != null) {\n    // Check if the current route candidate satisfies the predicate\n    if (predicate(candidate.route)) {\n      assert(() { _debugLocked = false; return true; }());\n      return; // Predicate returned true, stop popping\n    }\n\n    // If the candidate wants to handle pops internally, try that first\n    if (candidate.route.willHandlePopInternally) {\n        // Try to pop internally. If it returns false, it means\n        // it handled something, but doesn't want to be removed from the stack yet.\n        final bool poppedInternally = candidate.route.didPop(null);\n        assert(!poppedInternally); // didPop returning false means it's handled internally\n        // After internal pop, does it *now* satisfy the predicate?\n        if (predicate(candidate.route)) {\n             assert(() { _debugLocked = false; return true; }());\n            return; // Predicate returned true after internal pop, stop\n        }\n        // If it didn't satisfy the predicate even after internal pop,\n        // continue the while loop check\n    } else {\n         // If the route doesn't handle pop internally, just pop it off the stack.\n         pop(); // This calls _history[index of candidate].pop(null) and leads to _flushHistoryUpdates removing it\n    }\n\n    // After potentially popping the current candidate, revisit the list\n    // to find the new top candidate.\n    candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n  }\n\n  // If the loop finishes, it means the predicate never returned true\n  // before the stack was (almost) empty.\n  assert(() { _debugLocked = false; return true; }());\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant ScreenBWidget\n    participant NavigatorState\n    participant History(_RouteEntry List)\n    participant RouteBEntry\n    participant RouteAEntry\n    participant RouteHomeEntry\n\n    User->>ScreenBWidget: Tap \"Go back to Home\"\n    ScreenBWidget->>NavigatorState: Navigator.popUntil(context, predicate = '/' name check)\n    loop Pop Routes\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteBEntry)\n        NavigatorState->>predicate: Call predicate(RouteBEntry.route)\n        predicate->>NavigatorState: Return false ('/screenB' != '/')\n        NavigatorState->>RouteBEntry: route.didPop(null) (starts animation)\n        RouteBEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteBEntry\n        NavigatorState->>Overlay: Remove RouteB's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteAEntry)\n        NavigatorState->>predicate: Call predicate(RouteAEntry.route)\n        predicate->>NavigatorState: Return false ('/screenA' != '/')\n        NavigatorState->>RouteAEntry: route.didPop(null) (starts animation)\n        RouteAEntry->>NavigatorState: Animation complete\n        NavigatorState->>History(_RouteEntry List): Remove RouteAEntry\n        NavigatorState->>Overlay: Remove RouteA's content\n        NavigatorState->>History(_RouteEntry List): Get last _RouteEntry (RouteHomeEntry)\n        NavigatorState->>predicate: Call predicate(RouteHomeEntry.route)\n        predicate->>NavigatorState: Return true ('/' == '/')\n        NavigatorState->>NavigatorState: Stop popping\n    end\nalt Loop ends before predicate returns true\n        NavigatorState->>NavigatorState: Stack is nearly empty. Stop looping.\nend\n```\n\nThis simplified diagram shows `popUntil` iterating backwards, applying the predicate to each route it encounters (represented by `_RouteEntry.route`), and if the predicate is false, it removes that route before checking the next one. The loop stops *before* removing the route that satisfies the predicate.\n\n## Conclusion\n\nA `RoutePredicate` is a powerful function that allows you to define criteria for selecting routes within the [Navigator's](01_navigator_.md) history stack. This is particularly useful with methods like `popUntil` and `pushNamedAndRemoveUntil` to clear multiple routes efficiently based on their properties, most commonly their name. By using predicates like `ModalRoute.withName`, you can create flexible navigation flows that aren't tied to knowing the exact number of screens in the stack.\n\nNow that we understand how to identify and manage groups of routes using predicates, we'll move on to discuss `RoutePopDisposition`, which determines whether a route *can* be popped and how a pop request should be handled.\n\n[Chapter 6: RoutePopDisposition](06_routepopdisposition_.md)\n---\n# Chapter 6: RoutePopDisposition\n\nWelcome back, aspiring Flutter developers! In our previous chapter, [Chapter 5: RoutePredicate](05_routepredicate_.md), we learned how `RoutePredicate` helps the [Navigator](01_navigator_.md) decide which routes to interact with, especially when using `popUntil` or `pushNamedAndRemoveUntil`.\n\nToday, we're going to look at a concept that's closely related to *whether* a single [Route](02_route_.md) can be popped at all and how it should behave when a pop is attempted: **RoutePopDisposition**.\n\nThink of `RoutePopDisposition` as a rule that a specific screen ([Route](02_route_.md)) sets for itself about how it responds to being asked to close or \"pop.\" It's like a door deciding if it should open when someone tries to go back through it.\n\n## Why do we need RoutePopDisposition?\n\nMost of the time, when you push a new screen, it's expected that hitting the back button or calling `Navigator.pop` will dismiss that screen and take you back. `MaterialPageRoute` (which we used in earlier chapters) provides this behavior automatically.\n\nHowever, there are cases where you might *not* want a screen to be easily dismissed by the back button:\n\n1.  **Forms with unsaved changes:** If a user is filling out a form and accidentally hits the back button, you might want to show a confirmation dialog (\"Discard changes?\") instead of just closing the screen immediately. The screen needs a way to say, \"Hold on, let me handle this pop request first.\"\n2.  **Blocking navigation:** Sometimes, a screen represents a crucial step that the user *must* complete before going back. You might want to completely ignore back button presses until a specific action is taken on that screen.\n3.  **Top-level app exit:** When the very first screen of your app is visible, hitting the back button shouldn't usually navigate *back* within your app (because there's nowhere to go!). Instead, it should allow the operating system (like Android) to handle it, potentially closing the app or sending it to the background.\n\n`RoutePopDisposition` helps a [Route](02_route_.md) communicate its preference for how the [Navigator](01_navigator_.md) should handle a pop request targeted at it.\n\n## Understanding the Options\n\n`RoutePopDisposition` is an `enum` (a set of predefined values) with three possible options:\n\n*   **`RoutePopDisposition.pop`**: This is the default behavior for most routes that aren't the very first one. It means, \"Yes, go ahead and pop me off the stack.\" The [Navigator](01_navigator_.md) will proceed with the standard pop operation (exit animation, disposal, etc.).\n*   **`RoutePopDisposition.doNotPop`**: This means, \"No, don't pop me. Ignore this pop request.\" The [Navigator](01_navigator_.md) will stop the pop process, and the screen will remain visible. This is useful for completely blocking back navigation.\n*   **`RoutePopDisposition.bubble`**: This is the default behavior for the very first route ([Route.isFirst](02_route_.md) is true). It means, \"I can't be popped internally. Pass this pop request up to the next level,\" which is typically the operating system. This allows the system to handle the \"back\" action (e.g., minimizing the app).\n\n## How is RoutePopDisposition Used?\n\nThe [Navigator](01_navigator_.md) checks the `RoutePopDisposition` when the `Navigator.maybePop` method is called. `maybePop` is internally called when the system back button is pressed (on platforms that have one) or when a `PopScope` widget allows a pop. It's the polite way to attempt a pop, giving the current [Route](02_route_.md) a chance to respond. The standard `Navigator.pop` method, however, is an imperative command that bypasses this check and force-pops the route (unless the route has internal pop handling that *does* check the disposition, like `ModalRoute`).\n\n`Route` objects have a getter `popDisposition` (and a deprecated `willPop` future) that return one of these `RoutePopDisposition` values.\n\nLet's create a simple screen that prevents itself from being popped using `doNotPop`:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A screen that resists popping!\nclass ResistPopScreen extends ModalRoute<void> {\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300);\n\n  @override\n  bool get opaque => true;\n\n  @override\n  bool get barrierDismissible => false; // Cannot dismiss by tapping barrier\n\n  @override\n  Color get barrierColor => Colors.black54; // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => null;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Material(\n      type: MaterialType.transparency,\n      child: Center(\n        child: Container(\n          padding: const EdgeInsets.all(16),\n          color: Colors.white,\n          child: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              const Text(\n                'You cannot pop this screen with the back button!',\n                textAlign: TextAlign.center,\n                style: TextStyle(fontSize: 18),\n              ),\n              const SizedBox(height: 20),\n              ElevatedButton(\n                onPressed: () {\n                  // We use Navigator.pop here, which is an imperative command\n                  // and bypasses the RoutePopDisposition check.\n                  // This button *will* dismiss the screen.\n                  Navigator.pop(context);\n                },\n                child: const Text('Dismiss Anyway (using pop)'),\n              ),\n               ElevatedButton(\n                onPressed: () {\n                  // This tries to maybePop, which will consult\n                  // RoutePopDisposition and be ignored.\n                  Navigator.maybePop(context);\n                },\n                child: const Text('Try to Pop Politely (won\\'t work)'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n\n  // Override popDisposition to prevent popping via maybePop (like back button)\n  @override\n  RoutePopDisposition get popDisposition {\n      print('ResistPopScreen: Deciding pop disposition...');\n      return RoutePopDisposition.doNotPop;\n  }\n}\n\n// Our HomeScreen to push the ResistPopScreen\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            // Push our ResistPopScreen\n            Navigator.push(context, ResistPopScreen());\n          },\n          child: const Text('Go to Resist Pop Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Add this to your main MaterialApp routes if using named routes,\n// or push it directly as shown above.\n/*\nroutes: {\n  '/': (context) => const HomeScreen(),\n  // We push the route directly in this example, not via named routes.\n  // If you wanted a named route:\n  // '/resistPop': (context) => ResistPopScreen(), // Need a different way to build ModalRoute often\n},\n*/\n```\n\nIn this example:\n\n*   We created a custom [Route](02_route_.md) by extending `ModalRoute`. `ModalRoute`s are good for overlays like dialogs or custom screens that block interaction with the previous screen.\n*   We overrode the `buildPage` method to provide the visual content of our screen (a simple box with text and buttons).\n*   **Crucially**, we overrode the `popDisposition` getter to return `RoutePopDisposition.doNotPop`.\n*   When you run this, navigate to the `ResistPopScreen`. Hitting the system back button (which calls `maybePop`) will do nothing. The `print` statement in `popDisposition` confirms it was checked.\n*   Tapping the \"Try to Pop Politely\" button (which also calls `maybePop`) will also do nothing. The `popDisposition` prevents it.\n*   Tapping the \"Dismiss Anyway (using pop)\" button works because it calls `Navigator.pop`, which is a direct command to the [Navigator](01_navigator_.md) to remove the route, regardless of its `popDisposition`.\n\nThis demonstrates how `doNotPop` gives a route control over whether it responds to \"polite\" pop requests like the system back button.\n\nFor a forms-with-unsaved-changes scenario, you might initially return `RoutePopDisposition.pop` but use a `PopScope` widget (or the older `WillPopScope`) within the route's content. This widget would intercept the pop and show a dialog *before* the route's `popDisposition` is even consulted (or sometimes trigger a change that causes `popDisposition` to become `doNotPop` if necessary).\n\n## RoutePopDisposition Under the Hood (Simplified)\n\nLet's look at where `RoutePopDisposition` is defined and how it's used in the `NavigatorState`.\n\nThe `RoutePopDisposition` enum is simply:\n\n```dart\n/// Indicates whether the current route should be popped.\nenum RoutePopDisposition {\n  /// Pop the route.\n  pop,\n\n  /// Do not pop the route.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  bubble,\n}\n```\n\nThe core logic for using this enum lives in the `NavigatorState.maybePop` method (simplified, focusing on `popDisposition`):\n\n```dart\n// Inside NavigatorState class (simplified maybePop)\n@optionalTypeArgs\nFuture<bool> maybePop<T extends Object?>([T? result]) async {\n  // Find the current top-most route that is \"present\" (visible or animating)\n  final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n\n  if (lastEntry == null) {\n    return false; // Nothing to pop\n  }\n  assert(lastEntry.route._navigator == this);\n\n  // Check the route's pop disposition\n  switch (lastEntry.route.popDisposition) {\n    case RoutePopDisposition.bubble:\n      // Route says let someone else handle it (e.g., OS)\n      return false; // Indicate that *this* navigator didn't handle it\n\n    case RoutePopDisposition.pop:\n      // Route says it's okay to pop.\n      pop(result); // Call our internal pop method\n      return true; // Indicate that we handled the pop\n\n    case RoutePopDisposition.doNotPop:\n      // Route says don't pop it, ignore the request.\n      // We still call onPopInvokedWithResult to notify the route that a pop\n      // was attempted but canceled.\n      lastEntry.route.onPopInvokedWithResult(false, result);\n      return true; // Indicate that we handled the pop (by ignoring it)\n  }\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant OperatingSystem\n    participant NavigatorState\n    participant CurrentRouteEntry\n\n    User->>OperatingSystem: Back button pressed\n    OperatingSystem->>NavigatorState: Call maybePop(null)\n    NavigatorState->>CurrentRouteEntry: Get current route's RoutePopDisposition\n    alt RoutePopDisposition is bubble\n        CurrentRouteEntry->>NavigatorState: Return bubble\n        NavigatorState-->>OperatingSystem: Return false (not handled)\n    else RoutePopDisposition is pop\n        CurrentRouteEntry->>NavigatorState: Return pop\n        NavigatorState->>NavigatorState: Call pop(null)\n         NavigatorState-->>OperatingSystem: Return true (handled)\n    else RoutePopDisposition is doNotPop\n        CurrentRouteEntry->>NavigatorState: Return doNotPop\n        NavigatorState->>CurrentRouteEntry: route.onPopInvokedWithResult(false, null)\n        NavigatorState-->>OperatingSystem: Return true (handled)\n    end\n```\n\nThis simplified flow shows that `maybePop` is the gatekeeper that respects the `RoutePopDisposition`. It gets the disposition from the current route and then follows the rule: return `false` for `bubble` (let the caller handle it, usually means exiting the app scope), or return `true` for `pop` or `doNotPop` (meaning this `Navigator` \"handled\" the request, either by performing the pop or deliberately ignoring it).\n\nRoutes built with `MaterialPageRoute` and `CupertinoPageRoute` automatically implement `popDisposition` to return `bubble` if `isFirst` is true and `pop` otherwise. Custom routes can override this logic to implement behaviors like our `ResistPopScreen`.\n\n## Conclusion\n\n`RoutePopDisposition` is a simple but effective enum that allows individual [Route](02_route_.md)s to control how they respond to requests to be popped, particularly via `Navigator.maybePop` (triggered by system back buttons). By returning `pop`, `doNotPop`, or `bubble`, a route signals its intention, enabling scenarios like preventing accidental data loss or controlling app exit behavior. While `Navigator.pop` provides a way to imperatively dismiss a route, `maybePop` and `RoutePopDisposition` offer a cooperative mechanism for handling navigation changes requested by the system or other widgets like `PopScope`.\n\nIn the next chapter, we'll explore `NavigatorObserver`, which allows you to listen to and react to various navigation events happening within a [Navigator].\n\n[Chapter 7: NavigatorObserver](07_navigatorobserver_.md)\n---\n# Chapter 7: NavigatorObserver\n\nWelcome back, Flutter enthusiasts! In our journey through Flutter navigation, we've learned about the [Navigator](01_navigator_.md) managing the route stack, [Route](02_route_.md)s as screen recipes, [RouteSettings](03_routesettings_.md) for details, [Page](04_page_.md)s for declarative navigation, [RoutePredicate](05_routepredicate_.md)s for advanced route selection, and [RoutePopDisposition](06_routepopdisposition_.md) for controlling pop behavior.\n\nToday, we're adding a tool that lets us *watch* all of this navigation magic happen: the **NavigatorObserver**.\n\nThink of a **NavigatorObserver** as a silent spy or a detective that keeps an eye on everything the [Navigator](01_navigator_.md) is doing. Whenever a route is pushed, popped, replaced, or even removed, the `NavigatorObserver` gets a notification.\n\n## Why do we need a NavigatorObserver?\n\nWhy would you want to watch the [Navigator](01_navigator_.md)? Here are a few common reasons:\n\n1.  **Logging:** You might want to track which screens the user visits and in what order for analytics or debugging. A `NavigatorObserver` can simply print a message every time a route changes.\n2.  **Analytics:** Similar to logging, you can send navigation events to an analytics service (like Google Analytics or Firebase Analytics) to understand user flow within your app.\n3.  **External Updates:** Maybe some part of your app needs to react whenever a specific screen is shown or dismissed. An observer can trigger actions outside of the screen itself.\n4.  **Custom Behaviors:** In advanced scenarios, you might use an observer to implement custom global behaviors related to navigation, like managing certain background tasks.\n\nThe core idea is that the `NavigatorObserver` allows you to react *globally* to changes in the [Navigator's](01_navigator_.md) state without needing to add logic to *every single screen's* navigation calls (`push`, `pop`, etc.).\n\n## Using NavigatorObserver to Log Navigation Events\n\nLet's dive into our main use case: logging every time a screen is pushed or popped.\n\nTo use a `NavigatorObserver`, you need to:\n\n1.  Create a class that extends `NavigatorObserver`.\n2.  Override the methods that correspond to the events you want to listen to (like `didPush` and `didPop`).\n3.  Provide an instance of your observer class to the `observers` list of your `Navigator` (or usually, your `MaterialApp` or `WidgetsApp`, which creates the main [Navigator]).\n\nHere's our simple logging observer:\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Our custom observer that extends NavigatorObserver\nclass MyNavigatorObserver extends NavigatorObserver {\n  // Called when a route is pushed (a new screen is added)\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Pushed route: ${route.settings.name}');\n    print('NavigatorObserver: Previous route: ${previousRoute?.settings.name}');\n  }\n\n  // Called when a route is popped (a screen is removed)\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    print('NavigatorObserver: Popped route: ${route.settings.name}');\n    print('NavigatorObserver: New current route: ${previousRoute?.settings.name}');\n  }\n\n  // You can override other methods too, like didReplace, didRemove, etc.\n}\n```\n\nThis class is pretty straightforward. It just overrides `didPush` and `didPop` to print messages showing the name of the route involved in the event and the route below it.\n\nNow, let's integrate this into our simple navigation setup with a Home Screen and Second Screen using named routes, similar to what we did in [Chapter 3: RouteSettings](03_routesettings_.md).\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Screen 1: Home\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pushNamed(context, '/secondScreen');\n          },\n          child: const Text('Go to Second Screen'),\n        ),\n      ),\n    );\n  }\n}\n\n// Screen 2: Second Screen\nclass SecondScreen extends StatelessWidget {\n  const SecondScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Second Screen')),\n      body: Center(\n        child: ElevatedButton(\n          onPressed: () {\n            Navigator.pop(context);\n          },\n          child: const Text('Go Back!'),\n        ),\n      ),\n    );\n  }\n}\n```\n\nAnd here's how we provide our observer to the `MaterialApp`:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'screens.dart'; // Contains HomeScreen and SecondScreen\nimport 'my_navigator_observer.dart'; // Import our observer\n\n// Create an instance of our observer\nfinal MyNavigatorObserver myObserver = MyNavigatorObserver();\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Navigator Observer Demo',\n    initialRoute: '/',\n    routes: {\n      '/': (context) => const HomeScreen(),\n      '/secondScreen': (context) => const SecondScreen(),\n    },\n    // Provide our observer here!\n    observers: [\n      myObserver, // Add our observer to the list\n    ],\n  ));\n}\n```\n\nWhen you run this code and navigate between the screens, you'll see the `print` statements from `MyNavigatorObserver` appear in your console every time a `push` or `pop` happens.\n\n**Expected Console Output (walking through the simple flow):**\n\n1.  App starts (HomeScreen is the initial route, often added without a `push` notification by default setup): No observer notification yet.\n2.  Tap \"Go to Second Screen\" button:\n    ```\n    NavigatorObserver: Pushed route: /secondScreen\n    NavigatorObserver: Previous route: /\n    ```\n3.  Tap \"Go Back!\" button:\n    ```\n    NavigatorObserver: Popped route: /secondScreen\n    NavigatorObserver: New current route: /\n    ```\n\nThis is a minimal example, but it shows the power of listening to navigation events centrally.\n\n## Other Methods to Observe\n\nBesides `didPush` and `didPop`, `NavigatorObserver` also offers other methods you can override:\n\n*   `didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute})`: Called when one route is replaced by another (e.g., using `Navigator.pushReplacement`).\n*   `didRemove(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a route is removed from the stack without being popped (e.g., using `Navigator.removeRoute`).\n*   `didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute)`: Called whenever the top-most route on the navigator changes, regardless of how it changed (push, pop, replace affecting top).\n*   `didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute)`: Called when a user starts a gesture associated with navigation (like the iOS back swipe).\n*   `didStopUserGesture()`: Called when a user gesture associated with navigation ends.\n\nOverriding these methods lets your observer react to the full spectrum of navigation changes.\n\n## NavigatorObserver Under the Hood (Simplified)\n\nHow does the `NavigatorObserver` get its notifications?\n\nThe `NavigatorState` (the actual state object that manages the routes, discussed in [Chapter 1: Navigator](01_navigator_.md)) holds a list of `NavigatorObserver` instances provided to it via the `Navigator` widget's `observers` property. Whenever the `NavigatorState` performs a navigation operation (like adding or removing a route from its internal stack), it iterates through its list of observers and calls the corresponding notification method on each one.\n\nImagine the `NavigatorState`'s `push` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified push)\n@optionalTypeArgs\nFuture<T?> push<T extends Object?>(Route<T> route) {\n  // ... (internal logic to add route entry to _history) ...\n\n  // After the internal state is updated...\n  // Notify observers about the push event!\n  // _effectiveObservers is the list of observers including the hero controller\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPush(route, previousRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic, animations, etc.) ...\n\n  return route.popped; // Return the future\n}\n```\n\nSimilarly, the `pop` method (simplified):\n\n```dart\n// Inside NavigatorState class (simplified pop)\n@optionalTypeArgs\nvoid pop<T extends Object?>([T? result]) {\n  // ... (internal logic to remove route entry from _history) ...\n\n  // After the internal state changes...\n  // Notify observers about the pop event!\n  // _effectiveObservers is the list of observers\n  for (final NavigatorObserver observer in _effectiveObservers) {\n    observer.didPop(poppedRoute, newTopRoute); // Calls the observer's method\n  }\n\n  // ... (more internal logic) ...\n}\n```\n\nAnd how about our logging example flow with the observer?\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant HomeScreenWidget\n    participant NavigatorState\n    participant MyNavigatorObserver\n    participant SecondScreenRoute\n\n    User->>HomeScreenWidget: Tap Button\n    HomeScreenWidget->>NavigatorState: Navigator.pushNamed(context, '/secondScreen')\n    NavigatorState->>NavigatorState: Look up route for /secondScreen\n    NavigatorState->>SecondScreenRoute: Create route for /secondScreen\n    NavigatorState->>NavigatorState: Add SecondScreenRoute to _history\n    NavigatorState->>MyNavigatorObserver: observer.didPush(SecondScreenRoute, HomeScreenRoute)\n    MyNavigatorObserver->>Console: Print \"Pushed route: /secondScreen\", etc.\n    NavigatorState->>Overlay: Display SecondScreenRoute content\n```\n\nThis simple diagram shows that when `Navigator.pushNamed` (which internally calls the `push` method in `NavigatorState`) is executed, the `NavigatorState` makes a call to the `didPush` method on your `MyNavigatorObserver` instance, allowing it to react to the event.\n\n## Conclusion\n\nThe `NavigatorObserver` is a powerful, yet simple abstraction that allows you to listen to and react to events happening within a [Navigator]. By creating a custom observer and providing it to your application's main [Navigator], you can centralize logic for tasks like logging, analytics, or triggering side effects based on navigation changes. It provides a clean way to decouple these global concerns from the individual screen widgets and navigation calls.\n\nIn the next chapter, we'll explore another advanced concept for customizing behavior within the [Navigator]: the `TransitionDelegate`, which influences how pages animate when the `Navigator.pages` list changes.\n\n[Chapter 8: TransitionDelegate](08_transitiondelegate_.md)\n---\n# Chapter 8: TransitionDelegate\n\nWelcome back, future Flutter navigators! In our previous chapter, [Chapter 7: NavigatorObserver](07_navigatorobserver_.md), we learned how `NavigatorObserver` lets us watch and react to navigation events like routes being pushed or popped.\n\nToday, we're diving into a concept that\u2019s specifically relevant when you're using the Page-based navigation API ([Chapter 4: Page](04_page_.md)), and it helps the [Navigator](01_navigator_.md) decide *how* screens should animate when the list of [Page](04_page_.md)s changes: the **TransitionDelegate**.\n\nThink of the **TransitionDelegate** as the choreographer for the Page-based [Navigator](01_navigator_.md). When you change the list of [Page](04_page_.md)s you provide to the [Navigator](01_navigator_.md), the `TransitionDelegate` is consulted to decide exactly which pages need to animate (slide in or out) and which ones can just appear or disappear instantly.\n\n## Why do we need a TransitionDelegate?\n\nWhen you use the `Navigator.pages` property (as introduced in [Chapter 4: Page](04_page_.md)), the [Navigator](01_navigator_.md) compares the *new* list of [Page](04_page_.md)s you give it with the *old* list it was managing. Based on this comparison, it figures out which pages are:\n\n*   **New:** These need to enter the screen.\n*   **Missing:** These need to exit the screen.\n*   **Existing:** These stay on the screen (though their position relative to others might change).\n\nFor the \"New\" and \"Missing\" pages, the [Navigator](01_navigator_.md) needs to know how to handle them:\n\n*   Should a \"New\" page slide in with a push animation? Or should it just appear instantly (like adding it without an animation)?\n*   Should a \"Missing\" page slide out with a pop animation? Or should it just disappear instantly (like removing it without an animation)?\n\nThe **TransitionDelegate** is the object that makes these decisions. It looks at the state of all pages (entering, exiting, or remaining) and *tells* the [Navigator](01_navigator_.md) what actions to take (push, add, pop, remove, complete) for each route, corresponding to the page.\n\nThis delegate-based approach is flexible because you can customize the animation behavior based on your app's needs, especially when navigating complex or non-linear flows using the Page-based API.\n\n## How TransitionDelegate Works\n\nWhen you update the `pages` list on a [Navigator](01_navigator_.md), the [Navigator](01_navigator_.md) does some internal work to figure out which pages are entering and which are exiting. It represents these changes as a list of `RouteTransitionRecord` objects. Each `RouteTransitionRecord` wraps a [Route](02_route_.md) and indicates if that route is \"waiting for an entering decision\" or \"waiting for an exiting decision.\"\n\nThe [Navigator](01_navigator_.md) then passes these records to the `TransitionDelegate`'s `resolve` method.\n\nThe `resolve` method receives three pieces of information:\n\n1.  `newPageRouteHistory`: A list of `RouteTransitionRecord`s for pages that will be in the history *after* the update. Some of these might be new and need an \"entering decision.\"\n2.  `locationToExitingPageRoute`: A map showing which pages are exiting, keyed by the page below them (or null if they were the bottom-most exiting page). Some of these might need an \"exiting decision.\"\n3.  `pageRouteToPagelessRoutes`: A map showing any [Route](02_route_.md)s that were pushed imperatively ([Chapter 1: Navigator](01_navigator_.md)) *on top of* page-based routes. If a page they were on top of is exiting, these pageless routes also need \"exiting decisions.\"\n\nYour `TransitionDelegate.resolve` method must then iterate through these records and make decisions. For records needing a decision:\n\n*   If `isWaitingForEnteringDecision` is true, you call `markForPush()` or `markForAdd()` on the record.\n*   If `isWaitingForExitingDecision` is true, you call `markForPop()`, `markForComplete()`, or `markForRemove()` on the record.\n\nAfter making *all* necessary decisions, `resolve` must return an `Iterable<RouteTransitionRecord>` containing *all* the records from `newPageRouteHistory` and *all* the records from `locationToExitingPageRoute` (and their associated pageless routes), merged into a single list representing the final desired order of routes in the history. The relative order of pages from `newPageRouteHistory` must be preserved in the result.\n\nIt sounds a bit complex, but the core idea is: the delegate sees who's coming and going and decides how they move.\n\n## The Default TransitionDelegate\n\nFlutter provides a `DefaultTransitionDelegate` that implements logical default behavior:\n\n*   The newly added page that ends up at the *very top* of the stack is marked for `markForPush` (animates in).\n*   Any other newly added pages *below* the top one are marked for `markForAdd` (appear instantly).\n*   The page that was at the *very top* and is now missing is marked for `markForPop` (animates out).\n*   Any other missing pages *below* the top one are marked for `markForComplete` (disappear instantly, completing their future).\n\nThis behavior mimics typical imperatively driven navigation patterns where only the top-most route transition is animated.\n\n## Implementing a Custom TransitionDelegate\n\nLet's imagine a simple use case: We want to always animate *all* new pages being pushed *in* from the right, and *all* pages being removed *out* to the right, regardless of where they are in the stack. This isn't typical, but it demonstrates overriding the default behavior.\n\nWe'll need a simple app using the Page-based API, perhaps showing a list of numbers, and adding a detail page when a number is tapped.\n\nFirst, let's set up our basic screens or page builders (similar to [Chapter 4: Page](04_page_.md)). We'll use `MaterialPage` for simplicity.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// A simple page for the home screen\nclass HomePage extends Page<void> {\n  const HomePage() : super(key: const ValueKey('HomePage'), name: '/');\n\n  @override\n  Route<void> createRoute(BuildContext context) {\n    return MaterialPageRoute<void>(\n      settings: this,\n      builder: (BuildContext context) {\n        return Scaffold(\n          appBar: AppBar(title: const Text('Home')),\n          body: ListView.builder(\n            itemCount: 5,\n            itemBuilder: (context, index) {\n              return ListTile(\n                title: Text('Item $index'),\n                onTap: () {\n                  // In a real app, you'd add a DetailPage to your\n                  // pages list managed by a state object.\n                  // This is just to illustrate the Page concept.\n                },\n              );\n            },\n          ),\n        );\n      },\n    );\n  }\n}\n\n// A simple page for the detail screen\nclass DetailPage extends Page<void> {\n  const DetailPage({required this.itemIndex}) : super(key: ValueKey('Detail$itemIndex'), name: '/detail/$itemIndex', arguments: itemIndex);\n\n  final int itemIndex;\n\n  @override\n  Route<void> createRoute(BuildContext context) {\n    return MaterialPageRoute<void>(\n      settings: this,\n      builder: (BuildContext context) {\n        return Scaffold(\n          appBar: AppBar(title: Text('Item Detail $itemIndex')),\n          body: Center(\n            child: Text('Details for item $itemIndex'),\n          ),\n        );\n      },\n    );\n  }\n}\n```\n\nNow, let's create our custom `TransitionDelegate`:\n\n```dart\nimport 'package:flutter/widgets.dart'; // Important for TransitionDelegate and RouteTransitionRecord\n\n// Our custom TransitionDelegate that always animates pushes and pops\nclass AlwaysAnimateTransitionDelegate extends TransitionDelegate<void> {\n  const AlwaysAnimateTransitionDelegate();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n\n    // Handle routes that are entering (new pages)\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      if (pageRoute.isWaitingForEnteringDecision) {\n        // Always mark for push (animate in)\n        pageRoute.markForPush();\n      }\n      // Add the page route to the results list\n      results.add(pageRoute);\n    }\n\n    // Handle routes that are exiting (missing pages)\n    for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        // Always mark for pop (animate out)\n        exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n\n        // Handle any pageless routes on top of this exiting page\n        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n        if (pagelessRoutes != null) {\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n             if (pagelessRoute.isWaitingForExitingDecision) {\n                // Also mark pageless routes for pop\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n             }\n           }\n        }\n      }\n      // Add the exiting route to the results list.\n      // Note: The order matters; we must maintain the relative order\n      // of pages from newPageRouteHistory. Exiting pages can be inserted\n      // around them. In this simple example, we just add them to the end.\n      results.add(exitingPageRoute);\n    }\n\n    // The default delegate inserts exiting pages at the location they were removed\n    // from. Let's imitate that to keep the list order accurate.\n    final List<RouteTransitionRecord> mergedList = [];\n    final Iterator<RouteTransitionRecord> exitingIterator = locationToExitingPageRoute.values.iterator;\n    RouteTransitionRecord? nextExiting = exitingIterator.moveNext() ? exitingIterator.current : null;\n    final RouteTransitionRecord? firstEnteringPage = newPageRouteHistory.isNotEmpty ? newPageRouteHistory.first : null;\n     RouteTransitionRecord? nextEntering = firstEnteringPage;\n\n    Iterable<RouteTransitionRecord>? exitingBelowFirstEntering;\n    if (firstEnteringPage != null) {\n         exitingBelowFirstEntering = locationToExitingPageRoute.entries\n             .where(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.key == null) // Find exiting pages whose location was null (bottom)\n             .map(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.value);\n         mergedList.addAll(exitingBelowFirstEntering); // Add exiting pages that were at the bottom\n    }\n\n    for(final RouteTransitionRecord entering in newPageRouteHistory) {\n        mergedList.add(entering);\n        // Find any exiting pages whose location was this entering page\n         final Iterable<RouteTransitionRecord> exitingAboveThisEntering = locationToExitingPageRoute.entries\n             .where(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.key == entering)\n             .map(( MapEntry<RouteTransitionRecord?, RouteTransitionRecord> entry) => entry.value);\n         mergedList.addAll(exitingAboveThisEntering);\n    }\n\n    // Add any remaining exiting pages that weren't placed\n    for(final exiting in locationToExitingPageRoute.values) {\n        if (!mergedList.contains(exiting)) {\n             mergedList.add(exiting);\n        }\n    }\n\n    // Add any pageless routes attached to exiting pages that weren't added\n    for (final parentPageEntry in pageRouteToPagelessRoutes.keys) {\n        final pagelessRoutes = pageRouteToPagelessRoutes[parentPageEntry]!;\n         for (final pagelessRoute in pagelessRoutes) {\n             if (!mergedList.contains(pagelessRoute)) {\n                  mergedList.add(pagelessRoute);\n             }\n        }\n    }\n\n    return mergedList;\n  }\n}\n```\n\nExplanation:\n\n*   Our `AlwaysAnimateTransitionDelegate` extends `TransitionDelegate<void>`.\n*   The `resolve` method receives the information described earlier.\n*   We iterate through `newPageRouteHistory`. If a page `isWaitingForEnteringDecision`, we call `markForPush()` on its record. This signals to the [Navigator](01_navigator_.md) that the corresponding route should be pushed with an animation.\n*   We iterate through the values of `locationToExitingPageRoute` (the exiting page records). If a page `isWaitingForExitingDecision`, we call `markForPop()`. This signals that the corresponding route should be popped with an animation. We also handle any pageless routes associated with this exiting page in the same way.\n*   Finally, we construct the `mergedList`. The `resolve` method *must* return a list containing all involved route records in their *new* order. The relative order of `newPageRouteHistory` entries must be preserved. Exiting entries can be placed anywhere else. A safe default is to place entering routes followed by exiting routes, or (as done in the comment and refined logic) insert exiting routes where they were removed from relative to the entering stack. The slightly more complex list merging logic ensures all records are included and the relative order of the *new* history stack is correct while placing the exiting routes appropriately.\n\nTo use this delegate, you'd provide an instance of it to your `Navigator` (or `MaterialApp.router` / `WidgetsApp.router` which manage the [Navigator]):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'pages.dart'; // Contains HomePage and DetailPage\nimport 'my_transition_delegate.dart'; // Contains AlwaysAnimateTransitionDelegate\n\nvoid main() {\n  runApp(MaterialApp.router( // Using .router for Page-based navigation\n    routerDelegate: MyRouterDelegate(), // You'd typically have a custom RouterDelegate\n    routeInformationParser: MyRouteInformationParser(), // and a RouteInformationParser\n  ));\n}\n\n// Simplified example of a minimal delegate/parser setup\nclass MyRouterDelegate extends RouterDelegate<List<Page<dynamic>>>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<List<Page<dynamic>>> {\n\n  final List<Page<dynamic>> _pages = [const HomePage()];\n\n  @override\n  Widget build(BuildContext context) {\n    // This is where the Navigator is built with the pages and the transition delegate\n    return Navigator(\n      key: navigatorKey, // Required by PopNavigatorRouterDelegateMixin\n      pages: List.of(_pages), // Pass a copy of the pages list\n      onPopPage: _handlePopPage, // Handle pops\n      transitionDelegate: const AlwaysAnimateTransitionDelegate(), // Our custom delegate!\n    );\n  }\n\n  bool _handlePopPage(Route<dynamic> route, dynamic result) {\n     if (route.settings is Page) {\n      final int index = _pages.indexWhere(\n        (Page<dynamic> page) => page.key == route.settings.key,\n      );\n      if (index >= 0) {\n        _pages.removeAt(index);\n        notifyListeners(); // Notify the RouterDelegate that state changed\n        return route.didPop(result);\n      }\n    }\n    return false;\n  }\n\n  void _addDetailPage(int index) {\n     _pages.add(DetailPage(itemIndex: index));\n     notifyListeners(); // Trigger a rebuild of the Navigator\n  }\n\n  //--- Standard RouterDelegate overrides (simplified) ---\n  @override\n  GlobalKey<NavigatorState> get navigatorKey => GlobalKey<NavigatorState>();\n\n   @override\n  Future<void> setNewRoutePath(List<Page<dynamic>> configuration) {\n    // Implement logic to update _pages based on initial route/deep links\n     return SynchronousFuture(null);\n  }\n\n   @override\n   List<Page<dynamic>> get currentConfiguration => List.of(_pages);\n}\n\n// Minimal RouteInformationParser\nclass MyRouteInformationParser extends RouteInformationParser<List<Page<dynamic>>> {\n  @override\n  Future<List<Page<dynamic>>>> parseRouteInformation(RouteInformation routeInformation) async {\n     // Implement logic to parse initial route and create initial list of Pages\n     return [const HomePage()]; // Just return default for simplicity\n  }\n\n  @override\n  RouteInformation restoreRouteInformation(List<Page<dynamic>> configuration) {\n     // Implement logic to create RouteInformation from current Page list\n     return RouteInformation(uri: Uri.parse(configuration.last.name ?? '/'));\n  }\n}\n\n// In your HomeScreen, you'd need access to the RouterDelegate to call _addDetailPage:\n/*\nclass HomeScreen extends StatelessWidget {\n  const HomeScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Access the RouterDelegate (example, implementation detail depends on state management)\n    final MyRouterDelegate routerDelegate = Router.of(context).routerDelegate as MyRouterDelegate;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Home')),\n      body: ListView.builder(\n        itemCount: 5,\n        itemBuilder: (context, index) {\n          return ListTile(\n            title: Text('Item $index'),\n            onTap: () {\n              routerDelegate._addDetailPage(index); // Call the method to add a page\n            },\n          );\n        },\n      ),\n    );\n  }\n}\n*/\n```\n\nIn this setup, whenever the `_pages` list in `MyRouterDelegate` is modified (e.g., by calling `_addDetailPage` and then `notifyListeners`), the `MaterialApp.router` rebuilds the `Navigator`, providing the updated `_pages` list. The `Navigator` then uses `AlwaysAnimateTransitionDelegate` to decide how to animate the changes.\n\n## TransitionDelegate Under the Hood (Simplified)\n\nLet's look at the definition of `TransitionDelegate`:\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class TransitionDelegate<T> { // T is the return type, often void\n  const TransitionDelegate();\n\n  // This is the core method the Navigator calls\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n\n  // Internal method used by NavigatorState, wraps resolve and adds assertions\n  // to check the validity of the output.\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n```\n\nAnd the `RouteTransitionRecord`:\n\n```dart\n// From packages/flutter/lib/src/widgets/navigator.dart\n\nabstract class RouteTransitionRecord {\n  Route<dynamic> get route; // The associated Route\n  bool get isWaitingForEnteringDecision; // Needs entering decision?\n  bool get isWaitingForExitingDecision; // Needs exiting decision?\n\n  // Methods to make decisions:\n  void markForPush();\n  void markForAdd();\n  void markForPop([dynamic result]);\n  void markForComplete([dynamic result]);\n  void markForRemove();\n}\n```\n\nThese snippets show the interface the [NavigatorState](01_navigator_.md) uses to interact with the delegate. The `_transition` method is the internal entry point that calls your overridden `resolve` method and performs validation on your return value.\n\nHow does this fit into the `NavigatorState`'s update process when `pages` changes (simplified from `_updatePages` in `navigator.dart`)?\n\n1.  **Diffing:** The `NavigatorState` compares the old and new `pages` lists, identifies which routes correspond to new or missing pages, and creates `_RouteEntry` records (which implement `RouteTransitionRecord`) internally. `_RouteEntry`s for new pages are marked `isWaitingForEnteringDecision`. `_RouteEntry`s for missing pages are marked `isWaitingForExitingDecision`.\n2.  **Delegate Call:** The `NavigatorState` collects these records into the lists/maps required by `TransitionDelegate.resolve` and calls your delegate: `widget.transitionDelegate._transition(...)`.\n3.  **Decision Made:** Your `resolve` method iterates through the records that need decisions and calls methods like `markForPush`, `markForPop`, etc., on them. This updates the internal state (`currentState`) of those `_RouteEntry` records.\n4.  **History Update:** Your `resolve` method returns the merged list of records. The `NavigatorState` then updates its internal `_history` list (`_history.clear(); _history.addAll(results);`) according to this new order.\n5.  **Flush Updates:** The `NavigatorState` calls `_flushHistoryUpdates`, which processes the updated `_history` list. It looks at the `currentState` of each\n    `_RouteEntry` (which was set by your `TransitionDelegate`). For entries marked `push`, `add`, `pop`, `remove`, etc., it performs the corresponding actions:\n    *   `push`: Installs the route, adds its overlay entries, calls `route.didPush()`, starts animation.\n    *   `add`: Installs the route, adds its overlay entries, calls `route.didAdd()`.\n    *   `pop`: Calls `route.didPop()`, starts animation. After animation, calls `finalizeRoute`, removes overlay entries, disposes.\n    *   `complete`: Calls `route.didComplete()`, removes overlay entries, disposes.\n    *   `remove`: Removes overlay entries, disposes.\n6.  **Observer Notification:** As part of `_flushHistoryUpdates`, observers are notified ([Chapter 7: NavigatorObserver](07_navigatorobserver_.md)).\n\n```mermaid\nsequenceDiagram\n    participant YourWidget\n    participant NavigatorWidget\n    participant NavigatorState\n    participant TransitionDelegate\n    participant RouteTransitionRecord(s)\n    participant History(_RouteEntry List)\n    participant Overlay\n\n    YourWidget->>NavigatorWidget: Rebuild with New Pages List\n    NavigatorWidget->>NavigatorState: Pass New Pages List to Navigator.pages\n    NavigatorState->>NavigatorState: Compare and Identify Entering/Exiting Routes (_RouteEntrys)\n    NavigatorState->>TransitionDelegate: Call delegate.resolve(...) with RouteTransitionRecords\n    TransitionDelegate->>RouteTransitionRecord(s): Call markForPush(), markForPop(), etc.\n    TransitionDelegate-->>NavigatorState: Return merged list of RouteTransitionRecords\n    NavigatorState->>History(_RouteEntry List): Update internal _history list\n    NavigatorState->>NavigatorState: Call _flushHistoryUpdates\n    loop Process _history\n        NavigatorState->>_RouteEntry(s): Look at currentState (set by delegate)\n        alt currentState is push\n            NavigatorState->>_RouteEntry(s).route: Install route, call didPush(), start animation\n            NavigatorState->>Overlay: Add route's content to Overlay\n            NavigatorState->>History(_RouteEntry List): Update state to pushing/idle\n        end\n         alt currentState is pop\n            NavigatorState->>_RouteEntry(s).route: Call didPop(), start animation\n            NavigatorState->>History(_RouteEntry List): Update state to popping\n        end\n         alt currentState is add\n            NavigatorState->>_RouteEntry(s).route: Install route, call didAdd()\n             NavigatorState->>Overlay: Add route's content to Overlay\n            NavigatorState->>History(_RouteEntry List): Update state to idle\n        end\n        alt currentState is remove/complete\n            NavigatorState->>_RouteEntry(s).route: Call remove() / didComplete()\n            NavigatorState->>Overlay: Remove route's content from Overlay\n            NavigatorState->>History(_RouteEntry List): Mark for disposal\n        end\n    end\n    NavigatorState->>NavigatorState: Notify observers, etc.\n```\n\nThis expanded diagram shows where the `TransitionDelegate` fits into the Page-based navigation flow. It acts after the [Navigator] determines *what* needs to change based on the page list, but *before* it performs the final updates and animations.\n\n## Conclusion\n\nThe `TransitionDelegate` is a key component when using the Page-based API (`Navigator.pages`) for navigation in Flutter. It provides a centralized mechanism for deciding how screens should animate when the list of pages changes. By implementing your own `TransitionDelegate` and overriding the `resolve` method, you can customize the entry and exit transitions for pages, offering flexibility beyond the default push/pop behavior and enabling complex declarative navigation patterns.\n\nWith this chapter, we've covered most of the core building blocks of Navigator behavior. In the next and final chapter, we'll touch upon `RestorableRouteFuture`, a helper class specifically useful when using state restoration alongside imperative navigation calls.\n\n[Chapter 9: RestorableRouteFuture](09_restorableroutefuture_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/navigator.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'router.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:convert';\nimport 'dart:developer' as developer;\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'heroes.dart';\nimport 'notification_listener.dart';\nimport 'overlay.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\nimport 'routes.dart';\nimport 'ticker_provider.dart';\n\n// Duration for delay before refocusing in android so that the focus won't be interrupted.\nconst Duration _kAndroidRefocusingDelayDuration = Duration(milliseconds: 300);\n\n// Examples can assume:\n// typedef MyAppHome = Placeholder;\n// typedef MyHomePage = Placeholder;\n// typedef MyPage = ListTile; // any const widget with a Widget \"title\" constructor argument would do\n// late NavigatorState navigator;\n// late BuildContext context;\n\n/// Creates a route for the given route settings.\n///\n/// Used by [Navigator.onGenerateRoute].\n///\n/// See also:\n///\n///  * [Navigator], which is where all the [Route]s end up.\ntypedef RouteFactory = Route<dynamic>? Function(RouteSettings settings);\n\n/// Creates a series of one or more routes.\n///\n/// Used by [Navigator.onGenerateInitialRoutes].\ntypedef RouteListFactory =\n    List<Route<dynamic>> Function(NavigatorState navigator, String initialRoute);\n\n/// Creates a [Route] that is to be added to a [Navigator].\n///\n/// The route can be configured with the provided `arguments`. The provided\n/// `context` is the `BuildContext` of the [Navigator] to which the route is\n/// added.\n///\n/// Used by the restorable methods of the [Navigator] that add anonymous routes\n/// (e.g. [NavigatorState.restorablePush]). For this use case, the\n/// [RestorableRouteBuilder] must be static function annotated with\n/// `@pragma('vm:entry-point')`. The [Navigator] will call it again during\n/// state restoration to re-create the route.\ntypedef RestorableRouteBuilder<T> = Route<T> Function(BuildContext context, Object? arguments);\n\n/// Signature for the [Navigator.popUntil] predicate argument.\ntypedef RoutePredicate = bool Function(Route<dynamic> route);\n\n/// Signature for a callback that verifies that it's OK to call [Navigator.pop].\n///\n/// Used by [Form.onWillPop], [ModalRoute.addScopedWillPopCallback],\n/// [ModalRoute.removeScopedWillPopCallback], and [WillPopScope].\n@Deprecated(\n  'Use PopInvokedCallback instead. '\n  'This feature was deprecated after v3.12.0-1.0.pre.',\n)\ntypedef WillPopCallback = Future<bool> Function();\n\n/// Signature for the [Navigator.onPopPage] callback.\n///\n/// This callback must call [Route.didPop] on the specified route and must\n/// properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the corresponding [Page].\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef PopPageCallback = bool Function(Route<dynamic> route, dynamic result);\n\n/// Signature for the [Navigator.onDidRemovePage] callback.\n///\n/// This must properly update the pages list the next time it is passed into\n/// [Navigator.pages] so that it no longer includes the input `page`.\n/// (Otherwise, the page will be interpreted as a new page to show when the\n/// [Navigator.pages] list is next updated.)\ntypedef DidRemovePageCallback = void Function(Page<Object?> page);\n\n/// Indicates whether the current route should be popped.\n///\n/// Used as the return value for [Route.willPop].\n///\n/// See also:\n///\n///  * [WillPopScope], a widget that hooks into the route's [Route.willPop]\n///    mechanism.\nenum RoutePopDisposition {\n  /// Pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [pop] then the back\n  /// button will actually pop the current route.\n  pop,\n\n  /// Do not pop the route.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [doNotPop] then the\n  /// back button will be ignored.\n  doNotPop,\n\n  /// Delegate this to the next level of navigation.\n  ///\n  /// If [Route.willPop] or [Route.popDisposition] return [bubble] then the back\n  /// button will be handled by the [SystemNavigator], which will usually close\n  /// the application.\n  bubble,\n}\n\n/// An abstraction for an entry managed by a [Navigator].\n///\n/// This class defines an abstract interface between the navigator and the\n/// \"routes\" that are pushed on and popped off the navigator. Most routes have\n/// visual affordances, which they place in the navigators [Overlay] using one\n/// or more [OverlayEntry] objects.\n///\n/// See [Navigator] for more explanation of how to use a [Route] with\n/// navigation, including code examples.\n///\n/// See [MaterialPageRoute] for a route that replaces the entire screen with a\n/// platform-adaptive transition.\n///\n/// A route can belong to a page if the [settings] are a subclass of [Page]. A\n/// page-based route, as opposed to a pageless route, is created from\n/// [Page.createRoute] during [Navigator.pages] updates. The page associated\n/// with this route may change during the lifetime of the route. If the\n/// [Navigator] updates the page of this route, it calls [changedInternalState]\n/// to notify the route that the page has been updated.\n///\n/// The type argument `T` is the route's return type, as used by\n/// [currentResult], [popped], and [didPop]. The type `void` may be used if the\n/// route does not return a value.\nabstract class Route<T> extends _RoutePlaceholder {\n  /// Initialize the [Route].\n  ///\n  /// If the [settings] are not provided, an empty [RouteSettings] object is\n  /// used instead.\n  ///\n  /// If [requestFocus] is not provided, the value of [Navigator.requestFocus] is\n  /// used instead.\n  Route({RouteSettings? settings, bool? requestFocus})\n    : _settings = settings ?? const RouteSettings(),\n      _requestFocus = requestFocus {\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$Route<$T>',\n        object: this,\n      );\n    }\n  }\n\n  /// When the route state is updated, request focus if the current route is at the top.\n  ///\n  /// If not provided in the constructor, [Navigator.requestFocus] is used instead.\n  bool get requestFocus => _requestFocus ?? navigator?.widget.requestFocus ?? false;\n  final bool? _requestFocus;\n\n  /// The navigator that the route is in, if any.\n  NavigatorState? get navigator => _navigator;\n  NavigatorState? _navigator;\n\n  /// The settings for this route.\n  ///\n  /// See [RouteSettings] for details.\n  ///\n  /// The settings can change during the route's lifetime. If the settings\n  /// change, the route's overlays will be marked dirty (see\n  /// [changedInternalState]).\n  ///\n  /// If the route is created from a [Page] in the [Navigator.pages] list, then\n  /// this will be a [Page] subclass, and it will be updated each time its\n  /// corresponding [Page] in the [Navigator.pages] has changed. Once the\n  /// [Route] is removed from the history, this value stops updating (and\n  /// remains with its last value).\n  RouteSettings get settings => _settings;\n  RouteSettings _settings;\n\n  bool get _isPageBased => settings is Page<Object?>;\n\n  /// The restoration scope ID to be used for the [RestorationScope] surrounding\n  /// this route.\n  ///\n  /// The restoration scope ID is null if restoration is currently disabled\n  /// for this route.\n  ///\n  /// If the restoration scope ID changes (e.g. because restoration is enabled\n  /// or disabled) during the life of the route, the [ValueListenable] notifies\n  /// its listeners. As an example, the ID changes to null while the route is\n  /// transitioning off screen, which triggers a notification on this field. At\n  /// that point, the route is considered as no longer present for restoration\n  /// purposes and its state will not be restored.\n  ValueListenable<String?> get restorationScopeId => _restorationScopeId;\n  final ValueNotifier<String?> _restorationScopeId = ValueNotifier<String?>(null);\n\n  void _updateSettings(RouteSettings newSettings) {\n    if (_settings != newSettings) {\n      _settings = newSettings;\n      if (_navigator != null) {\n        changedInternalState();\n      }\n    }\n  }\n\n  // ignore: use_setters_to_change_properties, (setters can't be private)\n  void _updateRestorationId(String? restorationId) {\n    _restorationScopeId.value = restorationId;\n  }\n\n  /// The overlay entries of this route.\n  ///\n  /// These are typically populated by [install]. The [Navigator] is in charge\n  /// of adding them to and removing them from the [Overlay].\n  ///\n  /// There must be at least one entry in this list after [install] has been\n  /// invoked.\n  ///\n  /// The [Navigator] will take care of keeping the entries together if the\n  /// route is moved in the history.\n  List<OverlayEntry> get overlayEntries => const <OverlayEntry>[];\n\n  /// Called when the route is inserted into the navigator.\n  ///\n  /// Uses this to populate [overlayEntries]. There must be at least one entry in\n  /// this list after [install] has been invoked. The [Navigator] will be in charge\n  /// to add them to the [Overlay] or remove them from it by calling\n  /// [OverlayEntry.remove].\n  @protected\n  @mustCallSuper\n  void install() {}\n\n  /// Called after [install] when the route is pushed onto the navigator.\n  ///\n  /// The returned value resolves when the push transition is complete.\n  ///\n  /// The [didAdd] method will be called instead of [didPush] when the route\n  /// immediately appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  TickerFuture didPush() {\n    return TickerFuture.complete()..then<void>((void _) {\n      if (requestFocus) {\n        navigator!.focusNode.enclosingScope?.requestFocus();\n      }\n    });\n  }\n\n  /// Called after [install] when the route is added to the navigator.\n  ///\n  /// This method is called instead of [didPush] when the route immediately\n  /// appears on screen without any push transition.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didAdd() {\n    if (requestFocus) {\n      // This TickerFuture serves two purposes. First, we want to make sure that\n      // animations triggered by other operations will finish before focusing\n      // the navigator. Second, navigator.focusNode might acquire more focused\n      // children in Route.install asynchronously. This TickerFuture will wait\n      // for it to finish first.\n      //\n      // The later case can be found when subclasses manage their own focus scopes.\n      // For example, ModalRoute creates a focus scope in its overlay entries. The\n      // focused child can only be attached to navigator after initState which\n      // will be guarded by the asynchronous gap.\n      TickerFuture.complete().then<void>((void _) {\n        // The route can be disposed before the ticker future completes. This can\n        // happen when the navigator is under a TabView that warps from one tab to\n        // another, non-adjacent tab, with an animation. The TabView reorders its\n        // children before and after the warping completes, and that causes its\n        // children to be built and disposed within the same frame. If one of its\n        // children contains a navigator, the routes in that navigator are also\n        // added and disposed within that frame.\n        //\n        // Since the reference to the navigator will be set to null after it is\n        // disposed, we have to do a null-safe operation in case that happens\n        // within the same frame when it is added.\n        navigator?.focusNode.enclosingScope?.requestFocus();\n      });\n    }\n  }\n\n  /// Called after [install] when the route replaced another in the navigator.\n  ///\n  /// The [didChangeNext] and [didChangePrevious] methods are typically called\n  /// immediately after this method is called.\n  @protected\n  @mustCallSuper\n  void didReplace(Route<dynamic>? oldRoute) {}\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button.\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.onWillPop] callback that uses this\n  ///    mechanism.\n  ///  * [WillPopScope], another widget that provides a way to intercept the\n  ///    back button.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  Future<RoutePopDisposition> willPop() async {\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Returns whether calling [Navigator.maybePop] when this [Route] is current\n  /// ([isCurrent]) should do anything.\n  ///\n  /// [Navigator.maybePop] is usually used instead of [Navigator.pop] to handle\n  /// the system back button, when it hasn't been disabled via\n  /// [SystemNavigator.setFrameworkHandlesBack].\n  ///\n  /// By default, if a [Route] is the first route in the history (i.e., if\n  /// [isFirst]), it reports that pops should be bubbled\n  /// ([RoutePopDisposition.bubble]). This behavior prevents the user from\n  /// popping the first route off the history and being stranded at a blank\n  /// screen; instead, the larger scope is popped (e.g. the application quits,\n  /// so that the user returns to the previous application).\n  ///\n  /// In other cases, the default behavior is to accept the pop\n  /// ([RoutePopDisposition.pop]).\n  ///\n  /// The third possible value is [RoutePopDisposition.doNotPop], which causes\n  /// the pop request to be ignored entirely.\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that is similar.\n  ///  * [PopScope], a widget that provides a way to intercept the back button.\n  ///  * [Page.canPop], a way for [Page] to affect this property.\n  RoutePopDisposition get popDisposition {\n    if (_isPageBased) {\n      final Page<Object?> page = settings as Page<Object?>;\n      if (!page.canPop) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return isFirst ? RoutePopDisposition.bubble : RoutePopDisposition.pop;\n  }\n\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  @Deprecated(\n    'Override onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@template flutter.widgets.navigator.onPopInvokedWithResult}\n  /// Called after a route pop was handled.\n  ///\n  /// Even when the pop is canceled, for example by a [PopScope] widget, this\n  /// will still be called. The `didPop` parameter indicates whether or not the\n  /// back navigation actually happened successfully.\n  /// {@endtemplate}\n  @mustCallSuper\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    if (_isPageBased) {\n      final Page<T> page = settings as Page<T>;\n      page.onPopInvoked(didPop, result);\n    }\n  }\n\n  /// Whether calling [didPop] would return false.\n  bool get willHandlePopInternally => false;\n\n  /// When this route is popped (see [Navigator.pop]) if the result isn't\n  /// specified or if it's null, this value will be used instead.\n  ///\n  /// This fallback is implemented by [didComplete]. This value is used if the\n  /// argument to that method is null.\n  T? get currentResult => null;\n\n  /// A future that completes when this route is popped off the navigator.\n  ///\n  /// The future completes with the value given to [Navigator.pop], if any, or\n  /// else the value of [currentResult]. See [didComplete] for more discussion\n  /// on this topic.\n  Future<T?> get popped => _popCompleter.future;\n  final Completer<T?> _popCompleter = Completer<T?>();\n\n  final Completer<T?> _disposeCompleter = Completer<T?>();\n\n  /// A request was made to pop this route. If the route can handle it\n  /// internally (e.g. because it has its own stack of internal state) then\n  /// return false, otherwise return true (by returning the value of calling\n  /// `super.didPop`). Returning false will prevent the default behavior of\n  /// [NavigatorState.pop].\n  ///\n  /// When this function returns true, the navigator removes this route from\n  /// the history but does not yet call [dispose]. Instead, it is the route's\n  /// responsibility to call [NavigatorState.finalizeRoute], which will in turn\n  /// call [dispose] on the route. This sequence lets the route perform an\n  /// exit animation (or some other visual effect) after being popped but prior\n  /// to being disposed.\n  ///\n  /// This method should call [didComplete] to resolve the [popped] future (and\n  /// this is all that the default implementation does); routes should not wait\n  /// for their exit animation to complete before doing so.\n  ///\n  /// See [popped], [didComplete], and [currentResult] for a discussion of the\n  /// `result` argument.\n  @mustCallSuper\n  bool didPop(T? result) {\n    didComplete(result);\n    return true;\n  }\n\n  /// The route was popped or is otherwise being removed somewhat gracefully.\n  ///\n  /// This is called by [didPop] and in response to\n  /// [NavigatorState.pushReplacement]. If [didPop] was not called, then the\n  /// [NavigatorState.finalizeRoute] method must be called immediately, and no exit\n  /// animation will run.\n  ///\n  /// The [popped] future is completed by this method. The `result` argument\n  /// specifies the value that this future is completed with, unless it is null,\n  /// in which case [currentResult] is used instead.\n  ///\n  /// This should be called before the pop animation, if any, takes place,\n  /// though in some cases the animation may be driven by the user before the\n  /// route is committed to being popped; this can in particular happen with the\n  /// iOS-style back gesture. See [NavigatorState.didStartUserGesture].\n  @protected\n  @mustCallSuper\n  void didComplete(T? result) {\n    _popCompleter.complete(result ?? currentResult);\n  }\n\n  /// The given route, which was above this one, has been popped off the\n  /// navigator.\n  ///\n  /// This route is now the current route ([isCurrent] is now true), and there\n  /// is no next route.\n  @protected\n  @mustCallSuper\n  void didPopNext(Route<dynamic> nextRoute) {}\n\n  /// This route's next route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the next route changes for any reason,\n  /// so long as it is in the history, including when a route is first added to\n  /// a [Navigator] (e.g. by [Navigator.push]), except for cases when\n  /// [didPopNext] would be called.\n  ///\n  /// The `nextRoute` argument will be null if there's no new next route (i.e.\n  /// if [isCurrent] is true).\n  @protected\n  @mustCallSuper\n  void didChangeNext(Route<dynamic>? nextRoute) {}\n\n  /// This route's previous route has changed to the given new route.\n  ///\n  /// This is called on a route whenever the previous route changes for any\n  /// reason, so long as it is in the history, except for immediately after the\n  /// route itself has been pushed (in which case [didPush] or [didReplace] will\n  /// be called instead).\n  ///\n  /// The `previousRoute` argument will be null if there's no previous route\n  /// (i.e. if [isFirst] is true).\n  @protected\n  @mustCallSuper\n  void didChangePrevious(Route<dynamic>? previousRoute) {}\n\n  /// Called whenever the internal state of the route has changed.\n  ///\n  /// This should be called whenever [willHandlePopInternally], [didPop],\n  /// [ModalRoute.offstage], or other internal state of the route changes value.\n  /// It is used by [ModalRoute], for example, to report the new information via\n  /// its inherited widget to any children of the route.\n  ///\n  /// See also:\n  ///\n  ///  * [changedExternalState], which is called when the [Navigator] has\n  ///    updated in some manner that might affect the routes.\n  @protected\n  @mustCallSuper\n  void changedInternalState() {}\n\n  /// Called whenever the [Navigator] has updated in some manner that might\n  /// affect routes, to indicate that the route may wish to rebuild as well.\n  ///\n  /// This is called by the [Navigator] whenever the\n  /// [NavigatorState]'s [State.widget] changes (as in [State.didUpdateWidget]),\n  /// for example because the [MaterialApp] has been rebuilt. This\n  /// ensures that routes that directly refer to the state of the\n  /// widget that built the [MaterialApp] will be notified when that\n  /// widget rebuilds, since it would otherwise be difficult to notify\n  /// the routes that state they depend on may have changed.\n  ///\n  /// It is also called whenever the [Navigator]'s dependencies change\n  /// (as in [State.didChangeDependencies]). This allows routes to use the\n  /// [Navigator]'s context ([NavigatorState.context]), for example in\n  /// [ModalRoute.barrierColor], and update accordingly.\n  ///\n  /// The [ModalRoute] subclass overrides this to force the barrier\n  /// overlay to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [changedInternalState], the equivalent but for changes to the internal\n  ///    state of the route.\n  @protected\n  @mustCallSuper\n  void changedExternalState() {}\n\n  /// Discards any resources used by the object.\n  ///\n  /// This method should not remove its [overlayEntries] from the [Overlay]. The\n  /// object's owner is in charge of doing that.\n  ///\n  /// After this is called, the object is not in a usable state and should be\n  /// discarded.\n  ///\n  /// This method should only be called by the object's owner; typically the\n  /// [Navigator] owns a route and so will call this method when the route is\n  /// removed, after which the route is no longer referenced by the navigator.\n  @mustCallSuper\n  @protected\n  void dispose() {\n    _navigator = null;\n    _restorationScopeId.dispose();\n    _disposeCompleter.complete();\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n  }\n\n  /// Whether this route is the top-most route on the navigator.\n  ///\n  /// If this is true, then [isActive] is also true.\n  bool get isCurrent {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._lastRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether this route is the bottom-most active route on the navigator.\n  ///\n  /// If [isFirst] and [isCurrent] are both true then this is the only route on\n  /// the navigator (and [isActive] will also be true).\n  bool get isFirst {\n    if (_navigator == null) {\n      return false;\n    }\n    final _RouteEntry? currentRouteEntry = _navigator!._firstRouteEntryWhereOrNull(\n      _RouteEntry.isPresentPredicate,\n    );\n    if (currentRouteEntry == null) {\n      return false;\n    }\n    return currentRouteEntry.route == this;\n  }\n\n  /// Whether there is at least one active route underneath this route.\n  @protected\n  bool get hasActiveRouteBelow {\n    if (_navigator == null) {\n      return false;\n    }\n    for (final _RouteEntry entry in _navigator!._history) {\n      if (entry.route == this) {\n        return false;\n      }\n      if (_RouteEntry.isPresentPredicate(entry)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// Whether this route is on the navigator.\n  ///\n  /// If the route is not only active, but also the current route (the top-most\n  /// route), then [isCurrent] will also be true. If it is the first route (the\n  /// bottom-most route), then [isFirst] will also be true.\n  ///\n  /// If a higher route is entirely opaque, then the route will be active but not\n  /// rendered. It is even possible for the route to be active but for the stateful\n  /// widgets within the route to not be instantiated. See [ModalRoute.maintainState].\n  bool get isActive {\n    return _navigator?._firstRouteEntryWhereOrNull(_RouteEntry.isRoutePredicate(this))?.isPresent ??\n        false;\n  }\n}\n\n/// Data that might be useful in constructing a [Route].\n@immutable\nclass RouteSettings {\n  /// Creates data used to construct routes.\n  const RouteSettings({this.name, this.arguments});\n\n  /// The name of the route (e.g., \"/settings\").\n  ///\n  /// If null, the route is anonymous.\n  final String? name;\n\n  /// The arguments passed to this route.\n  ///\n  /// May be used when building the route, e.g. in [Navigator.onGenerateRoute].\n  final Object? arguments;\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'RouteSettings')}(${name == null ? 'none' : '\"$name\"'}, $arguments)';\n}\n\n/// Describes the configuration of a [Route].\n///\n/// The type argument `T` is the corresponding [Route]'s return type, as\n/// used by [Route.currentResult], [Route.popped], and [Route.didPop].\n///\n/// The [canPop] and [onPopInvoked] are used for intercepting pops.\n///\n/// {@tool dartpad}\n/// This sample demonstrates how to use this [canPop] and [onPopInvoked] to\n/// intercept pops.\n///\n/// ** See code in examples/api/lib/widgets/page/page_can_pop.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.pages], which accepts a list of [Page]s and updates its routes\n///    history.\nabstract class Page<T> extends RouteSettings {\n  /// Creates a page and initializes [key] for subclasses.\n  const Page({\n    this.key,\n    super.name,\n    super.arguments,\n    this.restorationId,\n    this.canPop = true,\n    this.onPopInvoked = _defaultPopInvokedHandler,\n  });\n\n  static void _defaultPopInvokedHandler(bool didPop, Object? result) {}\n\n  /// The key associated with this page.\n  ///\n  /// This key will be used for comparing pages in [canUpdate].\n  final LocalKey? key;\n\n  /// Restoration ID to save and restore the state of the [Route] configured by\n  /// this page.\n  ///\n  /// If no restoration ID is provided, the [Route] will not restore its state.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationId;\n\n  /// Called after a pop on the associated route was handled.\n  ///\n  /// It's not possible to prevent the pop from happening at the time that this\n  /// method is called; the pop has already happened. Use [canPop] to\n  /// disable pops in advance.\n  ///\n  /// This will still be called even when the pop is canceled. A pop is canceled\n  /// when the associated [Route.popDisposition] returns false, or when\n  /// [canPop] is set to false. The `didPop` parameter indicates whether or not\n  /// the back navigation actually happened successfully.\n  final PopInvokedWithResultCallback<T> onPopInvoked;\n\n  /// When false, blocks the associated route from being popped.\n  ///\n  /// If this is set to false for first page in the Navigator. It prevents\n  /// Flutter app from exiting.\n  ///\n  /// If there are any [PopScope] widgets in a route's widget subtree,\n  /// each of their `canPop` must be `true`, in addition to this canPop, in\n  /// order for the route to be able to pop.\n  final bool canPop;\n\n  /// Whether this page can be updated with the [other] page.\n  ///\n  /// Two pages are consider updatable if they have same the [runtimeType] and\n  /// [key].\n  bool canUpdate(Page<dynamic> other) {\n    return other.runtimeType == runtimeType && other.key == key;\n  }\n\n  /// Creates the [Route] that corresponds to this page.\n  ///\n  /// The created [Route] must have its [Route.settings] property set to this [Page].\n  @factory\n  Route<T> createRoute(BuildContext context);\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'Page')}(\"$name\", $key, $arguments)';\n}\n\n/// An interface for observing the behavior of a [Navigator].\nclass NavigatorObserver {\n  /// The navigator that the observer is observing, if any.\n  NavigatorState? get navigator => _navigators[this];\n\n  // Expando mapping instances of NavigatorObserver to their associated\n  // NavigatorState (or `null`, if there is no associated NavigatorState). The\n  // reason we don't use a private instance field of type\n  // `NavigatorState?` is because as part of implementing\n  // https://github.com/dart-lang/language/issues/2020, it will soon become a\n  // runtime error to invoke a private member that is mocked in another\n  // library. By using an expando rather than an instance field, we ensure\n  // that a mocked NavigatorObserver can still properly keep track of its\n  // associated NavigatorState.\n  static final Expando<NavigatorState> _navigators = Expando<NavigatorState>();\n\n  /// The [Navigator] pushed `route`.\n  ///\n  /// The route immediately below that one, and thus the previously active\n  /// route, is `previousRoute`.\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] popped `route`.\n  ///\n  /// The route immediately below that one, and thus the newly active\n  /// route, is `previousRoute`.\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] removed `route`.\n  ///\n  /// If only one route is being removed, then the route immediately below\n  /// that one, if any, is `previousRoute`.\n  ///\n  /// If multiple routes are being removed, then the route below the\n  /// bottommost route being removed, if any, is `previousRoute`, and this\n  /// method will be called once for each removed route, from the topmost route\n  /// to the bottommost route.\n  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// The [Navigator] replaced `oldRoute` with `newRoute`.\n  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {}\n\n  /// The top most route has changed.\n  ///\n  /// The `topRoute` is the new top most route. This can be a new route pushed\n  /// on top of the screen, or an existing route that becomes the new top-most\n  /// route because the previous top-most route has been popped.\n  ///\n  /// The `previousTopRoute` was the top most route before the change. This can\n  /// be a route that was popped off the screen, or a route that will be covered\n  /// by the `topRoute`. This can also be null if this is the first build.\n  void didChangeTop(Route<dynamic> topRoute, Route<dynamic>? previousTopRoute) {}\n\n  /// The [Navigator]'s routes are being moved by a user gesture.\n  ///\n  /// For example, this is called when an iOS back gesture starts, and is used\n  /// to disable hero animations during such interactions.\n  void didStartUserGesture(Route<dynamic> route, Route<dynamic>? previousRoute) {}\n\n  /// User gesture is no longer controlling the [Navigator].\n  ///\n  /// Paired with an earlier call to [didStartUserGesture].\n  void didStopUserGesture() {}\n}\n\n/// An inherited widget to host a hero controller.\n///\n/// The hosted hero controller will be picked up by the navigator in the\n/// [child] subtree. Once a navigator picks up this controller, the navigator\n/// will bar any navigator below its subtree from receiving this controller.\n///\n/// The hero controller inside the [HeroControllerScope] can only subscribe to\n/// one navigator at a time. An assertion will be thrown if the hero controller\n/// subscribes to more than one navigators. This can happen when there are\n/// multiple navigators under the same [HeroControllerScope] in parallel.\nclass HeroControllerScope extends InheritedWidget {\n  /// Creates a widget to host the input [controller].\n  const HeroControllerScope({\n    super.key,\n    required HeroController this.controller,\n    required super.child,\n  });\n\n  /// Creates a widget to prevent the subtree from receiving the hero controller\n  /// above.\n  const HeroControllerScope.none({super.key, required super.child}) : controller = null;\n\n  /// The hero controller that is hosted inside this widget.\n  final HeroController? controller;\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor, or null if none exists.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context], if there is one.\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.of], which is similar to this method, but asserts\n  ///   if no [HeroControllerScope] ancestor is found.\n  static HeroController? maybeOf(BuildContext context) {\n    final HeroControllerScope? host =\n        context.dependOnInheritedWidgetOfExactType<HeroControllerScope>();\n    return host?.controller;\n  }\n\n  /// Retrieves the [HeroController] from the closest [HeroControllerScope]\n  /// ancestor.\n  ///\n  /// If no ancestor is found, this method will assert in debug mode, and throw\n  /// an exception in release mode.\n  ///\n  /// Calling this method will create a dependency on the closest\n  /// [HeroControllerScope] in the [context].\n  ///\n  /// See also:\n  ///\n  /// * [HeroControllerScope.maybeOf], which is similar to this method, but\n  ///   returns null if no [HeroControllerScope] ancestor is found.\n  static HeroController of(BuildContext context) {\n    final HeroController? controller = maybeOf(context);\n    assert(() {\n      if (controller == null) {\n        throw FlutterError(\n          'HeroControllerScope.of() was called with a context that does not contain a '\n          'HeroControllerScope widget.\\n'\n          'No HeroControllerScope widget ancestor could be found starting from the '\n          'context that was passed to HeroControllerScope.of(). This can happen '\n          'because you are using a widget that looks for a HeroControllerScope '\n          'ancestor, but no such ancestor exists.\\n'\n          'The context used was:\\n'\n          '  $context',\n        );\n      }\n      return true;\n    }());\n    return controller!;\n  }\n\n  @override\n  bool updateShouldNotify(HeroControllerScope oldWidget) {\n    return oldWidget.controller != controller;\n  }\n}\n\n/// A [Route] wrapper interface that can be staged for [TransitionDelegate] to\n/// decide how its underlying [Route] should transition on or off screen.\nabstract class RouteTransitionRecord {\n  /// Retrieves the wrapped [Route].\n  Route<dynamic> get route;\n\n  /// Whether this route is waiting for the decision on how to enter the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition into the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForEnteringDecision;\n\n  /// Whether this route is waiting for the decision on how to exit the screen.\n  ///\n  /// If this property is true, this route requires an explicit decision on how\n  /// to transition off the screen. Such a decision should be made in the\n  /// [TransitionDelegate.resolve].\n  bool get isWaitingForExitingDecision;\n\n  /// Marks the [route] to be pushed with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be pushed onto the [Navigator] with an animated transition.\n  void markForPush();\n\n  /// Marks the [route] to be added without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an entering\n  /// route (where [RouteTransitionRecord.isWaitingForEnteringDecision] is true) in indicate that the\n  /// route should be added onto the [Navigator] without an animated transition.\n  void markForAdd();\n\n  /// Marks the [route] to be popped with transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be popped off the [Navigator] with\n  /// an animated transition.\n  void markForPop([dynamic result]);\n\n  /// Marks the [route] to be completed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be completed with the provided\n  /// result and removed from the [Navigator] without an animated transition.\n  void markForComplete([dynamic result]);\n\n  /// Marks the [route] to be removed without transition.\n  ///\n  /// During [TransitionDelegate.resolve], this can be called on an exiting\n  /// route to indicate that the route should be removed from the [Navigator]\n  /// without completing and without an animated transition.\n  void markForRemove();\n}\n\n/// The delegate that decides how pages added and removed from [Navigator.pages]\n/// transition in or out of the screen.\n///\n/// This abstract class implements the API to be called by [Navigator] when it\n/// requires explicit decisions on how the routes transition on or off the screen.\n///\n/// To make route transition decisions, subclass must implement [resolve].\n///\n/// {@tool snippet}\n/// The following example demonstrates how to implement a subclass that always\n/// removes or adds routes without animated transitions and puts the removed\n/// routes at the top of the list.\n///\n/// ```dart\n/// class NoAnimationTransitionDelegate extends TransitionDelegate<void> {\n///   @override\n///   Iterable<RouteTransitionRecord> resolve({\n///     required List<RouteTransitionRecord> newPageRouteHistory,\n///     required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n///     required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n///   }) {\n///     final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n///\n///     for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n///       if (pageRoute.isWaitingForEnteringDecision) {\n///         pageRoute.markForAdd();\n///       }\n///       results.add(pageRoute);\n///\n///     }\n///     for (final RouteTransitionRecord exitingPageRoute in locationToExitingPageRoute.values) {\n///       if (exitingPageRoute.isWaitingForExitingDecision) {\n///        exitingPageRoute.markForRemove();\n///        final List<RouteTransitionRecord>? pagelessRoutes = pageRouteToPagelessRoutes[exitingPageRoute];\n///        if (pagelessRoutes != null) {\n///          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n///             pagelessRoute.markForRemove();\n///           }\n///        }\n///       }\n///       results.add(exitingPageRoute);\n///\n///     }\n///     return results;\n///   }\n/// }\n///\n/// ```\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [Navigator.transitionDelegate], which uses this class to make route\n///    transition decisions.\n///  * [DefaultTransitionDelegate], which implements the default way to decide\n///    how routes transition in or out of the screen.\nabstract class TransitionDelegate<T> {\n  /// Creates a delegate and enables subclass to create a constant class.\n  const TransitionDelegate();\n\n  Iterable<RouteTransitionRecord> _transition({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final Iterable<RouteTransitionRecord> results = resolve(\n      newPageRouteHistory: newPageRouteHistory,\n      locationToExitingPageRoute: locationToExitingPageRoute,\n      pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n    );\n    // Verifies the integrity after the decisions have been made.\n    //\n    // Here are the rules:\n    // - All the entering routes in newPageRouteHistory must either be pushed or\n    //   added.\n    // - All the exiting routes in locationToExitingPageRoute must either be\n    //   popped, completed or removed.\n    // - All the pageless routes that belong to exiting routes must either be\n    //   popped, completed or removed.\n    // - All the entering routes in the result must preserve the same order as\n    //   the entering routes in newPageRouteHistory, and the result must contain\n    //   all exiting routes.\n    //     ex:\n    //\n    //     newPageRouteHistory = [A, B, C]\n    //\n    //     locationToExitingPageRoute = {A -> D, C -> E}\n    //\n    //     results = [A, B ,C ,D ,E] is valid\n    //     results = [D, A, B ,C ,E] is also valid because exiting route can be\n    //     inserted in any place\n    //\n    //     results = [B, A, C ,D ,E] is invalid because B must be after A.\n    //     results = [A, B, C ,E] is invalid because results must include D.\n    assert(() {\n      final List<RouteTransitionRecord> resultsToVerify = results.toList(growable: false);\n      final Set<RouteTransitionRecord> exitingPageRoutes =\n          locationToExitingPageRoute.values.toSet();\n      // Firstly, verifies all exiting routes have been marked.\n      for (final RouteTransitionRecord exitingPageRoute in exitingPageRoutes) {\n        assert(!exitingPageRoute.isWaitingForExitingDecision);\n        if (pageRouteToPagelessRoutes.containsKey(exitingPageRoute)) {\n          for (final RouteTransitionRecord pagelessRoute\n              in pageRouteToPagelessRoutes[exitingPageRoute]!) {\n            assert(!pagelessRoute.isWaitingForExitingDecision);\n          }\n        }\n      }\n      // Secondly, verifies the order of results matches the newPageRouteHistory\n      // and contains all the exiting routes.\n      int indexOfNextRouteInNewHistory = 0;\n\n      for (final _RouteEntry routeEntry in resultsToVerify.cast<_RouteEntry>()) {\n        assert(!routeEntry.isWaitingForEnteringDecision && !routeEntry.isWaitingForExitingDecision);\n        if (indexOfNextRouteInNewHistory >= newPageRouteHistory.length ||\n            routeEntry != newPageRouteHistory[indexOfNextRouteInNewHistory]) {\n          assert(exitingPageRoutes.contains(routeEntry));\n          exitingPageRoutes.remove(routeEntry);\n        } else {\n          indexOfNextRouteInNewHistory += 1;\n        }\n      }\n\n      assert(\n        indexOfNextRouteInNewHistory == newPageRouteHistory.length && exitingPageRoutes.isEmpty,\n        'The merged result from the $runtimeType.resolve does not include all '\n        'required routes. Do you remember to merge all exiting routes?',\n      );\n      return true;\n    }());\n\n    return results;\n  }\n\n  /// A method that will be called by the [Navigator] to decide how routes\n  /// transition in or out of the screen when [Navigator.pages] is updated.\n  ///\n  /// The `newPageRouteHistory` list contains all page-based routes in the order\n  /// that will be on the [Navigator]'s history stack after this update\n  /// completes. If a route in `newPageRouteHistory` has its\n  /// [RouteTransitionRecord.isWaitingForEnteringDecision] set to true, this\n  /// route requires explicit decision on how it should transition onto the\n  /// Navigator. To make a decision, call [RouteTransitionRecord.markForPush] or\n  /// [RouteTransitionRecord.markForAdd].\n  ///\n  /// The `locationToExitingPageRoute` contains the pages-based routes that\n  /// are removed from the routes history after page update. This map records\n  /// page-based routes to be removed with the location of the route in the\n  /// original route history before the update. The keys are the locations\n  /// represented by the page-based routes that are directly below the removed\n  /// routes, and the value are the page-based routes to be removed. The\n  /// location is null if the route to be removed is the bottom most route. If\n  /// a route in `locationToExitingPageRoute` has its\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to true, this\n  /// route requires explicit decision on how it should transition off the\n  /// Navigator. To make a decision for a removed route, call\n  /// [RouteTransitionRecord.markForPop],\n  /// [RouteTransitionRecord.markForComplete] or\n  /// [RouteTransitionRecord.markForRemove]. It is possible that decisions are\n  /// not required for routes in the `locationToExitingPageRoute`. This can\n  /// happen if the routes have already been popped in earlier page updates and\n  /// are still waiting for popping animations to finish. In such case, those\n  /// routes are still included in the `locationToExitingPageRoute` with their\n  /// [RouteTransitionRecord.isWaitingForExitingDecision] set to false and no\n  /// decisions are required.\n  ///\n  /// The `pageRouteToPagelessRoutes` records the page-based routes and their\n  /// associated pageless routes. If a page-based route is waiting for exiting\n  /// decision, its associated pageless routes also require explicit decisions\n  /// on how to transition off the screen.\n  ///\n  /// Once all the decisions have been made, this method must merge the removed\n  /// routes (whether or not they require decisions) and the\n  /// `newPageRouteHistory` and return the merged result. The order in the\n  /// result will be the order the [Navigator] uses for updating the route\n  /// history. The return list must preserve the same order of routes in\n  /// `newPageRouteHistory`. The removed routes, however, can be inserted into\n  /// the return list freely as long as all of them are included.\n  ///\n  /// For example, consider the following case.\n  ///\n  /// `newPageRouteHistory = [A, B, C]`\n  ///\n  /// `locationToExitingPageRoute = {A -> D, C -> E}`\n  ///\n  /// The following outputs are valid.\n  ///\n  /// `result = [A, B ,C ,D ,E]` is valid.\n  /// `result = [D, A, B ,C ,E]` is also valid because exiting route can be\n  /// inserted in any place.\n  ///\n  /// The following outputs are invalid.\n  ///\n  /// `result = [B, A, C ,D ,E]` is invalid because B must be after A.\n  /// `result = [A, B, C ,E]` is invalid because results must include D.\n  ///\n  /// See also:\n  ///\n  ///  * [RouteTransitionRecord.markForPush], which makes route enter the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForAdd], which makes route enter the screen\n  ///    without an animated transition.\n  ///  * [RouteTransitionRecord.markForPop], which makes route exit the screen\n  ///    with an animated transition.\n  ///  * [RouteTransitionRecord.markForRemove], which does not complete the\n  ///    route and makes it exit the screen without an animated transition.\n  ///  * [RouteTransitionRecord.markForComplete], which completes the route and\n  ///    makes it exit the screen without an animated transition.\n  ///  * [DefaultTransitionDelegate.resolve], which implements the default way\n  ///    to decide how routes transition in or out of the screen.\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  });\n}\n\n/// The default implementation of [TransitionDelegate] that the [Navigator] will\n/// use if its [Navigator.transitionDelegate] is not specified.\n///\n/// This transition delegate follows two rules. Firstly, all the entering routes\n/// are placed on top of the exiting routes if they are at the same location.\n/// Secondly, the top most route will always transition with an animated transition.\n/// All the other routes below will either be completed with\n/// [Route.currentResult] or added without an animated transition.\nclass DefaultTransitionDelegate<T> extends TransitionDelegate<T> {\n  /// Creates a default transition delegate.\n  const DefaultTransitionDelegate() : super();\n\n  @override\n  Iterable<RouteTransitionRecord> resolve({\n    required List<RouteTransitionRecord> newPageRouteHistory,\n    required Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute,\n    required Map<RouteTransitionRecord?, List<RouteTransitionRecord>> pageRouteToPagelessRoutes,\n  }) {\n    final List<RouteTransitionRecord> results = <RouteTransitionRecord>[];\n    // This method will handle the exiting route and its corresponding pageless\n    // route at this location. It will also recursively check if there is any\n    // other exiting routes above it and handle them accordingly.\n    void handleExitingRoute(RouteTransitionRecord? location, bool isLast) {\n      final RouteTransitionRecord? exitingPageRoute = locationToExitingPageRoute[location];\n      if (exitingPageRoute == null) {\n        return;\n      }\n      if (exitingPageRoute.isWaitingForExitingDecision) {\n        final bool hasPagelessRoute = pageRouteToPagelessRoutes.containsKey(exitingPageRoute);\n        final bool isLastExitingPageRoute =\n            isLast && !locationToExitingPageRoute.containsKey(exitingPageRoute);\n        if (isLastExitingPageRoute && !hasPagelessRoute) {\n          exitingPageRoute.markForPop(exitingPageRoute.route.currentResult);\n        } else {\n          exitingPageRoute.markForComplete(exitingPageRoute.route.currentResult);\n        }\n        if (hasPagelessRoute) {\n          final List<RouteTransitionRecord> pagelessRoutes =\n              pageRouteToPagelessRoutes[exitingPageRoute]!;\n          for (final RouteTransitionRecord pagelessRoute in pagelessRoutes) {\n            // It is possible that a pageless route that belongs to an exiting\n            // page-based route does not require exiting decision. This can\n            // happen if the page list is updated right after a Navigator.pop.\n            if (pagelessRoute.isWaitingForExitingDecision) {\n              if (isLastExitingPageRoute && pagelessRoute == pagelessRoutes.last) {\n                pagelessRoute.markForPop(pagelessRoute.route.currentResult);\n              } else {\n                pagelessRoute.markForComplete(pagelessRoute.route.currentResult);\n              }\n            }\n          }\n        }\n      }\n      results.add(exitingPageRoute);\n\n      // It is possible there is another exiting route above this exitingPageRoute.\n      handleExitingRoute(exitingPageRoute, isLast);\n    }\n\n    // Handles exiting route in the beginning of list.\n    handleExitingRoute(null, newPageRouteHistory.isEmpty);\n\n    for (final RouteTransitionRecord pageRoute in newPageRouteHistory) {\n      final bool isLastIteration = newPageRouteHistory.last == pageRoute;\n      if (pageRoute.isWaitingForEnteringDecision) {\n        if (!locationToExitingPageRoute.containsKey(pageRoute) && isLastIteration) {\n          pageRoute.markForPush();\n        } else {\n          pageRoute.markForAdd();\n        }\n      }\n      results.add(pageRoute);\n      handleExitingRoute(pageRoute, isLastIteration);\n    }\n    return results;\n  }\n}\n\n/// The default value of [Navigator.routeTraversalEdgeBehavior].\n///\n/// {@macro flutter.widgets.navigator.routeTraversalEdgeBehavior}\nconst TraversalEdgeBehavior kDefaultRouteTraversalEdgeBehavior = TraversalEdgeBehavior.parentScope;\n\n/// A widget that manages a set of child widgets with a stack discipline.\n///\n/// Many apps have a navigator near the top of their widget hierarchy in order\n/// to display their logical history using an [Overlay] with the most recently\n/// visited pages visually on top of the older pages. Using this pattern lets\n/// the navigator visually transition from one page to another by moving the widgets\n/// around in the overlay. Similarly, the navigator can be used to show a dialog\n/// by positioning the dialog widget above the current page.\n///\n/// ## Using the Pages API\n///\n/// The [Navigator] will convert its [Navigator.pages] into a stack of [Route]s\n/// if it is provided. A change in [Navigator.pages] will trigger an update to\n/// the stack of [Route]s. The [Navigator] will update its routes to match the\n/// new configuration of its [Navigator.pages]. To use this API, one can create\n/// a [Page] subclass and defines a list of [Page]s for [Navigator.pages]. A\n/// [Navigator.onPopPage] callback is also required to properly clean up the\n/// input pages in case of a pop.\n///\n/// By Default, the [Navigator] will use [DefaultTransitionDelegate] to decide\n/// how routes transition in or out of the screen. To customize it, define a\n/// [TransitionDelegate] subclass and provide it to the\n/// [Navigator.transitionDelegate].\n///\n/// For more information on using the pages API, see the [Router] widget.\n///\n/// ## Using the Navigator API\n///\n/// Mobile apps typically reveal their contents via full-screen elements\n/// called \"screens\" or \"pages\". In Flutter these elements are called\n/// routes and they're managed by a [Navigator] widget. The navigator\n/// manages a stack of [Route] objects and provides two ways for managing\n/// the stack, the declarative API [Navigator.pages] or imperative API\n/// [Navigator.push] and [Navigator.pop].\n///\n/// When your user interface fits this paradigm of a stack, where the user\n/// should be able to _navigate_ back to an earlier element in the stack,\n/// the use of routes and the Navigator is appropriate. On certain platforms,\n/// such as Android, the system UI will provide a back button (outside the\n/// bounds of your application) that will allow the user to navigate back\n/// to earlier routes in your application's stack. On platforms that don't\n/// have this build-in navigation mechanism, the use of an [AppBar] (typically\n/// used in the [Scaffold.appBar] property) can automatically add a back\n/// button for user navigation.\n///\n/// ### Displaying a full-screen route\n///\n/// Although you can create a navigator directly, it's most common to use the\n/// navigator created by the `Router` which itself is created and configured by\n/// a [WidgetsApp] or a [MaterialApp] widget. You can refer to that navigator\n/// with [Navigator.of].\n///\n/// A [MaterialApp] is the simplest way to set things up. The [MaterialApp]'s\n/// home becomes the route at the bottom of the [Navigator]'s stack. It is what\n/// you see when the app is launched.\n///\n/// ```dart\n/// void main() {\n///   runApp(const MaterialApp(home: MyAppHome()));\n/// }\n/// ```\n///\n/// To push a new route on the stack you can create an instance of\n/// [MaterialPageRoute] with a builder function that creates whatever you\n/// want to appear on the screen. For example:\n///\n/// ```dart\n/// Navigator.push(context, MaterialPageRoute<void>(\n///   builder: (BuildContext context) {\n///     return Scaffold(\n///       appBar: AppBar(title: const Text('My Page')),\n///       body: Center(\n///         child: TextButton(\n///           child: const Text('POP'),\n///           onPressed: () {\n///             Navigator.pop(context);\n///           },\n///         ),\n///       ),\n///     );\n///   },\n/// ));\n/// ```\n///\n/// The route defines its widget with a builder function instead of a\n/// child widget because it will be built and rebuilt in different\n/// contexts depending on when it's pushed and popped.\n///\n/// As you can see, the new route can be popped, revealing the app's home\n/// page, with the Navigator's pop method:\n///\n/// ```dart\n/// Navigator.pop(context);\n/// ```\n///\n/// It usually isn't necessary to provide a widget that pops the Navigator\n/// in a route with a [Scaffold] because the Scaffold automatically adds a\n/// 'back' button to its AppBar. Pressing the back button causes\n/// [Navigator.pop] to be called. On Android, pressing the system back\n/// button does the same thing.\n///\n/// ### Using named navigator routes\n///\n/// Mobile apps often manage a large number of routes and it's often\n/// easiest to refer to them by name. Route names, by convention,\n/// use a path-like structure (for example, '/a/b/c').\n/// The app's home page route is named '/' by default.\n///\n/// The [MaterialApp] can be created\n/// with a [Map<String, WidgetBuilder>] which maps from a route's name to\n/// a builder function that will create it. The [MaterialApp] uses this\n/// map to create a value for its navigator's [onGenerateRoute] callback.\n///\n/// ```dart\n/// void main() {\n///   runApp(MaterialApp(\n///     home: const MyAppHome(), // becomes the route named '/'\n///     routes: <String, WidgetBuilder> {\n///       '/a': (BuildContext context) => const MyPage(title: Text('page A')),\n///       '/b': (BuildContext context) => const MyPage(title: Text('page B')),\n///       '/c': (BuildContext context) => const MyPage(title: Text('page C')),\n///     },\n///   ));\n/// }\n/// ```\n///\n/// To show a route by name:\n///\n/// ```dart\n/// Navigator.pushNamed(context, '/b');\n/// ```\n///\n/// ### Routes can return a value\n///\n/// When a route is pushed to ask the user for a value, the value can be\n/// returned via the [pop] method's result parameter.\n///\n/// Methods that push a route return a [Future]. The Future resolves when the\n/// route is popped and the [Future]'s value is the [pop] method's `result`\n/// parameter.\n///\n/// For example if we wanted to ask the user to press 'OK' to confirm an\n/// operation we could `await` the result of [Navigator.push]:\n///\n/// ```dart\n/// bool? value = await Navigator.push(context, MaterialPageRoute<bool>(\n///   builder: (BuildContext context) {\n///     return Center(\n///       child: GestureDetector(\n///         child: const Text('OK'),\n///         onTap: () { Navigator.pop(context, true); }\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// If the user presses 'OK' then value will be true. If the user backs\n/// out of the route, for example by pressing the Scaffold's back button,\n/// the value will be null.\n///\n/// When a route is used to return a value, the route's type parameter must\n/// match the type of [pop]'s result. That's why we've used\n/// `MaterialPageRoute<bool>` instead of `MaterialPageRoute<void>` or just\n/// `MaterialPageRoute`. (If you prefer to not specify the types, though, that's\n/// fine too.)\n///\n/// ### Popup routes\n///\n/// Routes don't have to obscure the entire screen. [PopupRoute]s cover the\n/// screen with a [ModalRoute.barrierColor] that can be only partially opaque to\n/// allow the current screen to show through. Popup routes are \"modal\" because\n/// they block input to the widgets below.\n///\n/// There are functions which create and show popup routes. For\n/// example: [showDialog], [showMenu], and [showModalBottomSheet]. These\n/// functions return their pushed route's Future as described above.\n/// Callers can await the returned value to take an action when the\n/// route is popped, or to discover the route's value.\n///\n/// There are also widgets which create popup routes, like [PopupMenuButton] and\n/// [DropdownButton]. These widgets create internal subclasses of PopupRoute\n/// and use the Navigator's push and pop methods to show and dismiss them.\n///\n/// ### Custom routes\n///\n/// You can create your own subclass of one of the widget library route classes\n/// like [PopupRoute], [ModalRoute], or [PageRoute], to control the animated\n/// transition employed to show the route, the color and behavior of the route's\n/// modal barrier, and other aspects of the route.\n///\n/// The [PageRouteBuilder] class makes it possible to define a custom route\n/// in terms of callbacks. Here's an example that rotates and fades its child\n/// when the route appears or disappears. This route does not obscure the entire\n/// screen because it specifies `opaque: false`, just as a popup route does.\n///\n/// ```dart\n/// Navigator.push(context, PageRouteBuilder<void>(\n///   opaque: false,\n///   pageBuilder: (BuildContext context, _, _) {\n///     return const Center(child: Text('My PageRoute'));\n///   },\n///   transitionsBuilder: (_, Animation<double> animation, _, Widget child) {\n///     return FadeTransition(\n///       opacity: animation,\n///       child: RotationTransition(\n///         turns: Tween<double>(begin: 0.5, end: 1.0).animate(animation),\n///         child: child,\n///       ),\n///     );\n///   }\n/// ));\n/// ```\n///\n/// The page route is built in two parts, the \"page\" and the\n/// \"transitions\". The page becomes a descendant of the child passed to\n/// the `transitionsBuilder` function. Typically the page is only built once,\n/// because it doesn't depend on its animation parameters (elided with `_`\n/// in this example). The transition is built on every frame\n/// for its duration.\n///\n/// (In this example, `void` is used as the return type for the route, because\n/// it does not return a value.)\n///\n/// ### Nesting Navigators\n///\n/// An app can use more than one [Navigator]. Nesting one [Navigator] below\n/// another [Navigator] can be used to create an \"inner journey\" such as tabbed\n/// navigation, user registration, store checkout, or other independent journeys\n/// that represent a subsection of your overall application.\n///\n/// #### Example\n///\n/// It is standard practice for iOS apps to use tabbed navigation where each\n/// tab maintains its own navigation history. Therefore, each tab has its own\n/// [Navigator], creating a kind of \"parallel navigation.\"\n///\n/// In addition to the parallel navigation of the tabs, it is still possible to\n/// launch full-screen pages that completely cover the tabs. For example: an\n/// on-boarding flow, or an alert dialog. Therefore, there must exist a \"root\"\n/// [Navigator] that sits above the tab navigation. As a result, each of the\n/// tab's [Navigator]s are actually nested [Navigator]s sitting below a single\n/// root [Navigator].\n///\n/// In practice, the nested [Navigator]s for tabbed navigation sit in the\n/// [WidgetsApp] and [CupertinoTabView] widgets and do not need to be explicitly\n/// created or managed.\n///\n/// {@tool sample}\n/// The following example demonstrates how a nested [Navigator] can be used to\n/// present a standalone user registration journey.\n///\n/// Even though this example uses two [Navigator]s to demonstrate nested\n/// [Navigator]s, a similar result is possible using only a single [Navigator].\n///\n/// Run this example with `flutter run --route=/signup` to start it with\n/// the signup flow instead of on the home page.\n///\n/// ** See code in examples/api/lib/widgets/navigator/navigator.0.dart **\n/// {@end-tool}\n///\n/// [Navigator.of] operates on the nearest ancestor [Navigator] from the given\n/// [BuildContext]. Be sure to provide a [BuildContext] below the intended\n/// [Navigator], especially in large `build` methods where nested [Navigator]s\n/// are created. The [Builder] widget can be used to access a [BuildContext] at\n/// a desired location in the widget subtree.\n///\n/// ### Finding the enclosing route\n///\n/// In the common case of a modal route, the enclosing route can be obtained\n/// from inside a build method using [ModalRoute.of]. To determine if the\n/// enclosing route is the active route (e.g. so that controls can be dimmed\n/// when the route is not active), the [Route.isCurrent] property can be checked\n/// on the returned route.\n///\n/// ## State Restoration\n///\n/// If provided with a [restorationScopeId] and when surrounded by a valid\n/// [RestorationScope] the [Navigator] will restore its state by recreating\n/// the current history stack of [Route]s during state restoration and by\n/// restoring the internal state of those [Route]s. However, not all [Route]s\n/// on the stack can be restored:\n///\n///  * [Page]-based routes restore their state if [Page.restorationId] is\n///    provided.\n///  * [Route]s added with the classic imperative API ([push], [pushNamed], and\n///    friends) can never restore their state.\n///  * A [Route] added with the restorable imperative API ([restorablePush],\n///    [restorablePushNamed], and all other imperative methods with \"restorable\"\n///    in their name) restores its state if all routes below it up to and\n///    including the first [Page]-based route below it are restored. If there\n///    is no [Page]-based route below it, it only restores its state if all\n///    routes below it restore theirs.\n///\n/// If a [Route] is deemed restorable, the [Navigator] will set its\n/// [Route.restorationScopeId] to a non-null value. Routes can use that ID to\n/// store and restore their own state. As an example, the [ModalRoute] will\n/// use this ID to create a [RestorationScope] for its content widgets.\nclass Navigator extends StatefulWidget {\n  /// Creates a widget that maintains a stack-based history of child widgets.\n  ///\n  /// If the [pages] is not empty, the [onPopPage] must not be null.\n  const Navigator({\n    super.key,\n    this.pages = const <Page<dynamic>>[],\n    @Deprecated(\n      'Use onDidRemovePage instead. '\n      'This feature was deprecated after v3.16.0-17.0.pre.',\n    )\n    this.onPopPage,\n    this.initialRoute,\n    this.onGenerateInitialRoutes = Navigator.defaultGenerateInitialRoutes,\n    this.onGenerateRoute,\n    this.onUnknownRoute,\n    this.transitionDelegate = const DefaultTransitionDelegate<dynamic>(),\n    this.reportsRouteUpdateToEngine = false,\n    this.clipBehavior = Clip.hardEdge,\n    this.observers = const <NavigatorObserver>[],\n    this.requestFocus = true,\n    this.restorationScopeId,\n    this.routeTraversalEdgeBehavior = kDefaultRouteTraversalEdgeBehavior,\n    this.onDidRemovePage,\n  });\n\n  /// The list of pages with which to populate the history.\n  ///\n  /// Pages are turned into routes using [Page.createRoute] in a manner\n  /// analogous to how [Widget]s are turned into [Element]s (and [State]s or\n  /// [RenderObject]s) using [Widget.createElement] (and\n  /// [StatefulWidget.createState] or [RenderObjectWidget.createRenderObject]).\n  ///\n  /// When this list is updated, the new list is compared to the previous\n  /// list and the set of routes is updated accordingly.\n  ///\n  /// Some [Route]s do not correspond to [Page] objects, namely, those that are\n  /// added to the history using the [Navigator] API ([push] and friends). A\n  /// [Route] that does not correspond to a [Page] object is called a pageless\n  /// route and is tied to the [Route] that _does_ correspond to a [Page] object\n  /// that is below it in the history.\n  ///\n  /// Pages that are added or removed may be animated as controlled by the\n  /// [transitionDelegate]. If a page is removed that had other pageless routes\n  /// pushed on top of it using [push] and friends, those pageless routes are\n  /// also removed with or without animation as determined by the\n  /// [transitionDelegate].\n  ///\n  /// To use this API, an [onPopPage] callback must also be provided to properly\n  /// clean up this list if a page has been popped.\n  ///\n  /// If [initialRoute] is non-null when the widget is first created, then\n  /// [onGenerateInitialRoutes] is used to generate routes that are above those\n  /// corresponding to [pages] in the initial history.\n  final List<Page<dynamic>> pages;\n\n  /// This is deprecated and replaced by [onDidRemovePage].\n  ///\n  /// Called when [pop] is invoked but the current [Route] corresponds to a\n  /// [Page] found in the [pages] list.\n  ///\n  /// The `result` argument is the value with which the route is to complete\n  /// (e.g. the value returned from a dialog).\n  ///\n  /// This callback is responsible for calling [Route.didPop] and returning\n  /// whether this pop is successful.\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the [Page] for the given [Route]. The next time the [pages] list\n  /// is updated, if the [Page] corresponding to this [Route] is still present,\n  /// it will be interpreted as a new route to display.\n  @Deprecated(\n    'Use onDidRemovePage instead. '\n    'This feature was deprecated after v3.16.0-17.0.pre.',\n  )\n  final PopPageCallback? onPopPage;\n\n  /// Called when the [Route] associated with the given [Page] has been removed\n  /// from the Navigator.\n  ///\n  /// This can happen when the route is removed or completed through\n  /// [Navigator.pop], [Navigator.pushReplacement], or its friends.\n  ///\n  /// This callback is responsible for removing the given page from the list of\n  /// [pages].\n  ///\n  /// The [Navigator] widget should be rebuilt with a [pages] list that does not\n  /// contain the given page [Page]. The next time the [pages] list\n  /// is updated, if the given [Page] is still present, it will be interpreted\n  /// as a new page to display.\n  final DidRemovePageCallback? onDidRemovePage;\n\n  /// The delegate used for deciding how routes transition in or off the screen\n  /// during the [pages] updates.\n  ///\n  /// Defaults to [DefaultTransitionDelegate].\n  final TransitionDelegate<dynamic> transitionDelegate;\n\n  /// The name of the first route to show.\n  ///\n  /// Defaults to [Navigator.defaultRouteName].\n  ///\n  /// The value is interpreted according to [onGenerateInitialRoutes], which\n  /// defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// Changing the [initialRoute] will have no effect, as it only controls the\n  /// _initial_ route. To change the route while the application is running, use\n  /// the static functions on this class, such as [push] or [replace].\n  final String? initialRoute;\n\n  /// Called to generate a route for a given [RouteSettings].\n  final RouteFactory? onGenerateRoute;\n\n  /// Called when [onGenerateRoute] fails to generate a route.\n  ///\n  /// This callback is typically used for error handling. For example, this\n  /// callback might always generate a \"not found\" page that describes the route\n  /// that wasn't found.\n  ///\n  /// Unknown routes can arise either from errors in the app or from external\n  /// requests to push routes, such as from Android intents.\n  final RouteFactory? onUnknownRoute;\n\n  /// A list of observers for this navigator.\n  final List<NavigatorObserver> observers;\n\n  /// Restoration ID to save and restore the state of the navigator, including\n  /// its history.\n  ///\n  /// {@template flutter.widgets.navigator.restorationScopeId}\n  /// If a restoration ID is provided, the navigator will persist its internal\n  /// state (including the route history as well as the restorable state of the\n  /// routes) and restore it during state restoration.\n  ///\n  /// If no restoration ID is provided, the route history stack will not be\n  /// restored and state restoration is disabled for the individual routes as\n  /// well.\n  ///\n  /// The state is persisted in a [RestorationBucket] claimed from\n  /// the surrounding [RestorationScope] using the provided restoration ID.\n  /// Within that bucket, the [Navigator] also creates a new [RestorationScope]\n  /// for its children (the [Route]s).\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  ///  * [RestorationMixin], which contains a runnable code sample showcasing\n  ///    state restoration in Flutter.\n  ///  * [Navigator], which explains under the heading \"state restoration\"\n  ///    how and under what conditions the navigator restores its state.\n  ///  * [Navigator.restorablePush], which includes an example showcasing how\n  ///    to push a restorable route onto the navigator.\n  /// {@endtemplate}\n  final String? restorationScopeId;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// focus scope that defines focus traversal of widgets within a route.\n  ///\n  /// {@template flutter.widgets.navigator.routeTraversalEdgeBehavior}\n  /// The focus inside routes installed in the top of the app affects how\n  /// the app behaves with respect to the platform content surrounding it.\n  /// For example, on the web, an app is at a minimum surrounded by browser UI,\n  /// such as the address bar, browser tabs, and more. The user should be able\n  /// to reach browser UI using normal focus shortcuts. Similarly, if the app\n  /// is embedded within an `<iframe>` or inside a custom element, it should\n  /// be able to participate in the overall focus traversal, including elements\n  /// not rendered by Flutter.\n  /// {@endtemplate}\n  final TraversalEdgeBehavior routeTraversalEdgeBehavior;\n\n  /// The name for the default route of the application.\n  ///\n  /// See also:\n  ///\n  ///  * [dart:ui.PlatformDispatcher.defaultRouteName], which reflects the route that the\n  ///    application was started with.\n  static const String defaultRouteName = '/';\n\n  /// Called when the widget is created to generate the initial list of [Route]\n  /// objects if [initialRoute] is not null.\n  ///\n  /// Defaults to [defaultGenerateInitialRoutes].\n  ///\n  /// The [NavigatorState] and [initialRoute] will be passed to the callback.\n  /// The callback must return a list of [Route] objects with which the history\n  /// will be primed.\n  ///\n  /// When parsing the initialRoute, if there's any chance that it may\n  /// contain complex characters, it's best to use the\n  /// [characters](https://pub.dev/packages/characters) API. This will ensure\n  /// that extended grapheme clusters and surrogate pairs are treated as single\n  /// characters by the code, the same way that they appear to the user. For\n  /// example, the string \"\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\" appears to the user as a single\n  /// character and `string.characters.length` intuitively returns 1. On the\n  /// other hand, `string.length` returns 8, and `string.runes.length` returns\n  /// 5!\n  final RouteListFactory onGenerateInitialRoutes;\n\n  /// Whether this navigator should report route update message back to the\n  /// engine when the top-most route changes.\n  ///\n  /// If the property is set to true, this navigator automatically sends the\n  /// route update message to the engine when it detects top-most route changes.\n  /// The messages are used by the web engine to update the browser URL bar.\n  ///\n  /// If the property is set to true when the [Navigator] is first created,\n  /// single-entry history mode is requested using\n  /// [SystemNavigator.selectSingleEntryHistory]. This means this property\n  /// should not be used at the same time as [PlatformRouteInformationProvider]\n  /// is used with a [Router] (including when used with [MaterialApp.router],\n  /// for example).\n  ///\n  /// If there are multiple navigators in the widget tree, at most one of them\n  /// can set this property to true (typically, the top-most one created from\n  /// the [WidgetsApp]). Otherwise, the web engine may receive multiple route\n  /// update messages from different navigators and fail to update the URL\n  /// bar.\n  ///\n  /// Defaults to false.\n  final bool reportsRouteUpdateToEngine;\n\n  /// {@macro flutter.material.Material.clipBehavior}\n  ///\n  /// In cases where clipping is not desired, consider setting this property to\n  /// [Clip.none].\n  ///\n  /// Defaults to [Clip.hardEdge].\n  final Clip clipBehavior;\n\n  /// Whether or not the navigator and it's new topmost route should request focus\n  /// when the new route is pushed onto the navigator.\n  ///\n  /// If [Route.requestFocus] is set on the topmost route, that will take precedence\n  /// over this value.\n  ///\n  /// Defaults to true.\n  final bool requestFocus;\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed}\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  ///\n  /// To use [pushNamed], an [Navigator.onGenerateRoute] callback must be\n  /// provided,\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.navigator.pushNamed.returnValue}\n  /// Returns a [Future] that completes to the `result` value passed to [pop]\n  /// when the pushed route is popped off the navigator.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.pushNamed}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object can be passed as `arguments` (e.g. a\n  /// [String], [int], or an instance of a custom `MyRouteArguments` class).\n  /// Often, a [Map] is used to pass key-value pairs.\n  ///\n  /// The `arguments` may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _didPushButton() {\n  ///   Navigator.pushNamed(context, '/settings');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass additional `arguments` to the\n  /// route:\n  ///\n  /// ```dart\n  /// void _showBerlinWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Berlin',\n  ///       'country': 'Germany',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example shows how to pass a custom Object to the route:\n  ///\n  /// ```dart\n  /// class WeatherRouteArguments {\n  ///   WeatherRouteArguments({ required this.city, required this.country });\n  ///   final String city;\n  ///   final String country;\n  ///\n  ///   bool get isGermanCapital {\n  ///     return country == 'Germany' && city == 'Berlin';\n  ///   }\n  /// }\n  ///\n  /// void _showWeather() {\n  ///   Navigator.pushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: WeatherRouteArguments(city: 'Berlin', country: 'Germany'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Push a named route onto the navigator that most tightly encloses the given\n  /// context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamed}\n  /// Unlike [Route]s pushed via [pushNamed], [Route]s pushed with this method\n  /// are restored during state restoration according to the rules outlined\n  /// in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.arguments}\n  /// The provided `arguments` are passed to the pushed route via\n  /// [RouteSettings.arguments]. Any object that is serializable via the\n  /// [StandardMessageCodec] can be passed as `arguments`. Often, a Map is used\n  /// to pass key-value pairs.\n  ///\n  /// The arguments may be used in [Navigator.onGenerateRoute] or\n  /// [Navigator.onUnknownRoute] to construct the route.\n  /// {@endtemplate}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  /// The method returns an opaque ID for the pushed route that can be used by\n  /// the [RestorableRouteFuture] to gain access to the actual [Route] object\n  /// added to the navigator and its return value. You can ignore the return\n  /// value of this method, if you do not care about the route object or the\n  /// route's return value.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _showParisWeather() {\n  ///   Navigator.restorablePushNamed(\n  ///     context,\n  ///     '/weather',\n  ///     arguments: <String, String>{\n  ///       'city': 'Paris',\n  ///       'country': 'France',\n  ///     },\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamed<T extends Object?>(\n    BuildContext context,\n    String routeName, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacementNamed}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the old route (`TO`).\n  ///\n  /// The route name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]). The removed\n  /// route's exit animation is not run (see [popAndPushNamed] for a variant\n  /// that animates the removed route).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  ///\n  /// To use [pushReplacementNamed], a [Navigator.onGenerateRoute] callback must\n  /// be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToBrightness() {\n  ///   Navigator.pushReplacementNamed(context, '/settings/brightness');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///    can be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the route named [routeName] and then disposing\n  /// the previous route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacementNamed}\n  /// Unlike [Route]s pushed via [pushReplacementNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _switchToAudioVolume() {\n  ///   Navigator.restorablePushReplacementNamed(context, '/settings/volume');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacementNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.popAndPushNamed}\n  /// The popping of the previous route is handled as per [pop].\n  ///\n  /// The new route's name will be passed to the [Navigator.onGenerateRoute]\n  /// callback. The returned route will be pushed into the navigator.\n  ///\n  /// The new route, the old route, and the route below the old route (if any)\n  /// are all notified (see [Route.didPop], [Route.didComplete],\n  /// [Route.didPopNext], [Route.didPush], and [Route.didChangeNext]). If the\n  /// [Navigator] has any [Navigator.observers], they will be notified as well\n  /// (see [NavigatorObserver.didPop] and [NavigatorObserver.didPush]). The\n  /// animations for the pop and the push are performed simultaneously, so the\n  /// route below may be briefly visible even if both the old route and the new\n  /// route are opaque (see [TransitionRoute.opaque]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the return value type of the old route.\n  ///\n  /// To use [popAndPushNamed], a [Navigator.onGenerateRoute] callback must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectAccessibility() {\n  ///   Navigator.popAndPushNamed(context, '/settings/accessibility');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).popAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Pop the current route off the navigator that most tightly encloses the\n  /// given context and push a named route in its place.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePopAndPushNamed}\n  /// Unlike [Route]s pushed via [popAndPushNamed], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _selectNetwork() {\n  ///   Navigator.restorablePopAndPushNamed(context, '/settings/network');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePopAndPushNamed<T, TO>(routeName, arguments: arguments, result: result);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The new route's name (`routeName`) will be passed to the\n  /// [Navigator.onGenerateRoute] callback. The returned route will be pushed\n  /// into the navigator.\n  ///\n  /// The new route and the route below the bottommost removed route (which\n  /// becomes the route below the new route) are notified (see [Route.didPush]\n  /// and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush] and [NavigatorObserver.didRemove]). The\n  /// removed routes are disposed, without being notified, once the new route\n  /// has finished animating. The futures that had been returned from pushing\n  /// those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  ///\n  /// To use [pushNamedAndRemoveUntil], an [Navigator.onGenerateRoute] callback\n  /// must be provided.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToCalendar() {\n  ///   Navigator.pushNamedAndRemoveUntil(context, '/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).pushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator that most tightly\n  /// encloses the given context, and then remove all the previous routes until\n  /// the `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushNamedAndRemoveUntil], [Route]s pushed with\n  /// this method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetToOverview() {\n  ///   Navigator.restorablePushNamedAndRemoveUntil(context, '/overview', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushNamedAndRemoveUntil<T>(newRouteName, predicate, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.push}\n  /// The new route and the previous route (if any) are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPush]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openMyPage() {\n  ///   Navigator.push<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  static Future<T?> push<T extends Object?>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePush}\n  /// Unlike [Route]s pushed via [push], [Route]s pushed with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@template flutter.widgets.Navigator.restorablePush}\n  /// The method takes a [RestorableRouteBuilder] as argument, which must be a\n  /// _static_ function annotated with `@pragma('vm:entry-point')`. It must\n  /// instantiate and return a new [Route] object that will be added to the\n  /// navigator. The provided `arguments` object is passed to the\n  /// `routeBuilder`. The navigator calls the static `routeBuilder` function\n  /// again during state restoration to re-create the route object.\n  ///\n  /// Any object that is serializable via the [StandardMessageCodec] can be\n  /// passed as `arguments`. Often, a Map is used to pass key-value pairs.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePush<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorablePush(routeBuilder, arguments: arguments);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing the given route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.pushReplacement}\n  /// If non-null, `result` will be used as the result of the route that is\n  /// removed; the future that had been returned from pushing that old route will\n  /// complete with `result`. Routes such as dialogs or popup menus typically\n  /// use this mechanism to return the value selected by the user to the widget\n  /// that created their route. The type of `result`, if provided, must match\n  /// the type argument of the class of the old route (`TO`).\n  ///\n  /// The new route and the route below the removed route are notified (see\n  /// [Route.didPush] and [Route.didChangeNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is notified once the\n  /// new route has finished animating (see [Route.didComplete]).\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route,\n  /// and `TO` is the type of the return value of the old route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _completeLogin() {\n  ///   Navigator.pushReplacement<void, void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    return Navigator.of(context).pushReplacement<T, TO>(newRoute, result: result);\n  }\n\n  /// Replace the current route of the navigator that most tightly encloses the\n  /// given context by pushing a new route and then disposing the previous\n  /// route once the new route has finished animating in.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushReplacement}\n  /// Unlike [Route]s pushed via [pushReplacement], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushReplacement<T, TO>(routeBuilder, result: result, arguments: arguments);\n  }\n\n  /// Push the given route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.pushAndRemoveUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To remove routes until a route with a certain name, use the\n  /// [RoutePredicate] returned from [ModalRoute.withName].\n  ///\n  /// To remove all the routes below the pushed route, use a [RoutePredicate]\n  /// that always returns false (e.g. `(Route<dynamic> route) => false`).\n  ///\n  /// The removed routes are removed without being completed, so this method\n  /// does not take a return value argument.\n  ///\n  /// The newly pushed route and its preceding route are notified for\n  /// [Route.didPush]. After removal, the new route and its new preceding route,\n  /// (the route below the bottommost removed route) are notified through\n  /// [Route.didChangeNext]). If the [Navigator] has any [Navigator.observers],\n  /// they will be notified as well (see [NavigatorObserver.didPush] and\n  /// [NavigatorObserver.didRemove]). The removed routes are disposed of and\n  /// notified, once the new route has finished animating. The futures that had\n  /// been returned from pushing those routes will not complete.\n  ///\n  /// Ongoing gestures within the current route are canceled when a new route is\n  /// pushed.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _finishAccountCreation() {\n  ///   Navigator.pushAndRemoveUntil<void>(\n  ///     context,\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static Future<T?> pushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    Route<T> newRoute,\n    RoutePredicate predicate,\n  ) {\n    return Navigator.of(context).pushAndRemoveUntil<T>(newRoute, predicate);\n  }\n\n  /// Push a new route onto the navigator that most tightly encloses the\n  /// given context, and then remove all the previous routes until the\n  /// `predicate` returns true.\n  ///\n  /// {@template flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  /// Unlike [Route]s pushed via [pushAndRemoveUntil], [Route]s pushed with this\n  /// method are restored during state restoration according to the rules\n  /// outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  static String restorablePushAndRemoveUntil<T extends Object?>(\n    BuildContext context,\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return Navigator.of(\n      context,\n    ).restorablePushAndRemoveUntil<T>(newRouteBuilder, predicate, arguments: arguments);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.replace}\n  /// The old route must not be currently visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// This can be useful in combination with [removeRouteBelow] when building a\n  /// non-linear user experience.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  static void replace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replace<T>(oldRoute: oldRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplace}\n  /// Unlike [Route]s added via [replace], [Route]s added with this method are\n  /// restored during state restoration according to the rules outlined in the\n  /// \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplace<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplace<T>(\n      oldRoute: oldRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.replaceRouteBelow}\n  /// The old route must not be current visible, as this method skips the\n  /// animations and therefore the removal would be jarring if it was visible.\n  /// To replace the top-most route, consider [pushReplacement] instead, which\n  /// _does_ animate the new route, and delays removing the old route until the\n  /// new route has finished animating.\n  ///\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument.\n  ///\n  /// The new route, the route below the new route (if any), and the route above\n  /// the new route, are all notified (see [Route.didReplace],\n  /// [Route.didChangeNext], and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didReplace]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The `T` type argument is the type of the return value of the new route.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  static void replaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    return Navigator.of(context).replaceRouteBelow<T>(anchorRoute: anchorRoute, newRoute: newRoute);\n  }\n\n  /// Replaces a route on the navigator that most tightly encloses the given\n  /// context with a new route. The route to be replaced is the one below the\n  /// given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.restorableReplaceRouteBelow}\n  /// Unlike [Route]s added via [restorableReplaceRouteBelow], [Route]s added\n  /// with this method are restored during state restoration according to the\n  /// rules outlined in the \"State Restoration\" section of [Navigator].\n  /// {@endtemplate}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  static String restorableReplaceRouteBelow<T extends Object?>(\n    BuildContext context, {\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    return Navigator.of(context).restorableReplaceRouteBelow<T>(\n      anchorRoute: anchorRoute,\n      newRouteBuilder: newRouteBuilder,\n      arguments: arguments,\n    );\n  }\n\n  /// Whether the navigator that most tightly encloses the given context can be\n  /// popped.\n  ///\n  /// {@template flutter.widgets.navigator.canPop}\n  /// The initial route cannot be popped off the navigator, which implies that\n  /// this function returns true only if popping the navigator would not remove\n  /// the initial route.\n  ///\n  /// If there is no [Navigator] in scope, returns false.\n  ///\n  /// Does not consider anything that might externally prevent popping, such as\n  /// [PopEntry].\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  static bool canPop(BuildContext context) {\n    final NavigatorState? navigator = Navigator.maybeOf(context);\n    return navigator != null && navigator.canPop();\n  }\n\n  /// Consults the current route's [Route.popDisposition] getter or\n  /// [Route.willPop] method, and acts accordingly, potentially popping the\n  /// route as a result; returns whether the pop request should be considered\n  /// handled.\n  ///\n  /// {@template flutter.widgets.navigator.maybePop}\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.pop], then the [pop]\n  /// method is called, and this method returns true, indicating that it handled\n  /// the pop request.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.doNotPop], then this\n  /// method returns true, but does not do anything beyond that.\n  ///\n  /// If the [RoutePopDisposition] is [RoutePopDisposition.bubble], then this\n  /// method returns false, and the caller is responsible for sending the\n  /// request to the containing scope (e.g. by closing the application).\n  ///\n  /// This method is typically called for a user-initiated [pop]. For example on\n  /// Android it's called by the binding for the system's back button.\n  ///\n  /// The `T` type argument is the type of the return value of the current\n  /// route. (Typically this isn't known; consider specifying `dynamic` or\n  /// `Null`.)\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that enables the form\n  ///    to veto a [pop] initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedWillPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  static Future<bool> maybePop<T extends Object?>(BuildContext context, [T? result]) {\n    return Navigator.of(context).maybePop<T>(result);\n  }\n\n  /// Pop the top-most route off the navigator that most tightly encloses the\n  /// given context.\n  ///\n  /// {@template flutter.widgets.navigator.pop}\n  /// The current route's [Route.didPop] method is called first. If that method\n  /// returns false, then the route remains in the [Navigator]'s history (the\n  /// route is expected to have popped some internal state; see e.g.\n  /// [LocalHistoryRoute]). Otherwise, the rest of this description applies.\n  ///\n  /// If non-null, `result` will be used as the result of the route that is\n  /// popped; the future that had been returned from pushing the popped route\n  /// will complete with `result`. Routes such as dialogs or popup menus\n  /// typically use this mechanism to return the value selected by the user to\n  /// the widget that created their route. The type of `result`, if provided,\n  /// must match the type argument of the class of the popped route (`T`).\n  ///\n  /// The popped route and the route below it are notified (see [Route.didPop],\n  /// [Route.didComplete], and [Route.didPopNext]). If the [Navigator] has any\n  /// [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didPop]).\n  ///\n  /// The `T` type argument is the type of the return value of the popped route.\n  ///\n  /// The type of `result`, if provided, must match the type argument of the\n  /// class of the popped route (`T`).\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _close() {\n  ///   Navigator.pop(context);\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _accept() {\n  ///   Navigator.pop(context, true); // dialog returns true\n  /// }\n  /// ```\n  @optionalTypeArgs\n  static void pop<T extends Object?>(BuildContext context, [T? result]) {\n    Navigator.of(context).pop<T>(result);\n  }\n\n  /// Calls [pop] repeatedly on the navigator that most tightly encloses the\n  /// given context until the predicate returns true.\n  ///\n  /// {@template flutter.widgets.navigator.popUntil}\n  /// The predicate may be applied to the same route more than once if\n  /// [Route.willHandlePopInternally] is true.\n  ///\n  /// To pop until a route with a certain name, use the [RoutePredicate]\n  /// returned from [ModalRoute.withName].\n  ///\n  /// The routes are closed with null as their `return` value.\n  ///\n  /// See [pop] for more details of the semantics of popping a route.\n  /// {@endtemplate}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _logout() {\n  ///   Navigator.popUntil(context, ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  static void popUntil(BuildContext context, RoutePredicate predicate) {\n    Navigator.of(context).popUntil(predicate);\n  }\n\n  /// Immediately remove `route` from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it.\n  ///\n  /// {@template flutter.widgets.navigator.removeRoute}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `route` must be in the history; this method will throw an\n  /// exception if it is not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  ///\n  /// This method is used, for example, to instantly dismiss dropdown menus that\n  /// are up when the screen's orientation changes.\n  static void removeRoute(BuildContext context, Route<dynamic> route) {\n    return Navigator.of(context).removeRoute(route);\n  }\n\n  /// Immediately remove a route from the navigator that most tightly encloses\n  /// the given context, and [Route.dispose] it. The route to be removed is the\n  /// one below the given `anchorRoute`.\n  ///\n  /// {@template flutter.widgets.navigator.removeRouteBelow}\n  /// The removed route is removed without being completed, so this method does\n  /// not take a return value argument. No animations are run as a result of\n  /// this method call.\n  ///\n  /// The routes below and above the removed route are notified (see\n  /// [Route.didChangeNext] and [Route.didChangePrevious]). If the [Navigator]\n  /// has any [Navigator.observers], they will be notified as well (see\n  /// [NavigatorObserver.didRemove]). The removed route is disposed without\n  /// being notified. The future that had been returned from pushing that routes\n  /// will not complete.\n  ///\n  /// The given `anchorRoute` must be in the history and must have a route below\n  /// it; this method will throw an exception if it is not or does not.\n  ///\n  /// Ongoing gestures within the current route are canceled.\n  /// {@endtemplate}\n  static void removeRouteBelow(BuildContext context, Route<dynamic> anchorRoute) {\n    return Navigator.of(context).removeRouteBelow(anchorRoute);\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// Navigator.of(context)\n  ///   ..pop()\n  ///   ..pop()\n  ///   ..pushNamed('/settings');\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// If there is no [Navigator] in the given `context`, this function will throw\n  /// a [FlutterError] in debug mode, and an exception in release mode.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState of(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    navigator =\n        rootNavigator\n            ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n            : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n\n    assert(() {\n      if (navigator == null) {\n        throw FlutterError(\n          'Navigator operation requested with a context that does not include a Navigator.\\n'\n          'The context used to push or pop routes from the Navigator must be that of a '\n          'widget that is a descendant of a Navigator widget.',\n        );\n      }\n      return true;\n    }());\n    return navigator!;\n  }\n\n  /// The state from the closest instance of this class that encloses the given\n  /// context, if any.\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// NavigatorState? navigatorState = Navigator.maybeOf(context);\n  /// if (navigatorState != null) {\n  ///   navigatorState\n  ///     ..pop()\n  ///     ..pop()\n  ///     ..pushNamed('/settings');\n  /// }\n  /// ```\n  ///\n  /// If `rootNavigator` is set to true, the state from the furthest instance of\n  /// this class is given instead. Useful for pushing contents above all\n  /// subsequent instances of [Navigator].\n  ///\n  /// Will return null if there is no ancestor [Navigator] in the `context`.\n  ///\n  /// This method can be expensive (it walks the element tree).\n  static NavigatorState? maybeOf(BuildContext context, {bool rootNavigator = false}) {\n    NavigatorState? navigator;\n    if (context case StatefulElement(:final NavigatorState state)) {\n      navigator = state;\n    }\n\n    return rootNavigator\n        ? context.findRootAncestorStateOfType<NavigatorState>() ?? navigator\n        : navigator ?? context.findAncestorStateOfType<NavigatorState>();\n  }\n\n  /// Turn a route name into a set of [Route] objects.\n  ///\n  /// This is the default value of [onGenerateInitialRoutes], which is used if\n  /// [initialRoute] is not null.\n  ///\n  /// If this string starts with a `/` character and has multiple `/` characters\n  /// in it, then the string is split on those characters and substrings from\n  /// the start of the string up to each such character are, in turn, used as\n  /// routes to push.\n  ///\n  /// For example, if the route `/stocks/HOOLI` was used as the [initialRoute],\n  /// then the [Navigator] would push the following routes on startup: `/`,\n  /// `/stocks`, `/stocks/HOOLI`. This enables deep linking while allowing the\n  /// application to maintain a predictable route history.\n  static List<Route<dynamic>> defaultGenerateInitialRoutes(\n    NavigatorState navigator,\n    String initialRouteName,\n  ) {\n    final List<Route<dynamic>?> result = <Route<dynamic>?>[];\n    if (initialRouteName.startsWith('/') && initialRouteName.length > 1) {\n      initialRouteName = initialRouteName.substring(1); // strip leading '/'\n      assert(Navigator.defaultRouteName == '/');\n      List<String>? debugRouteNames;\n      assert(() {\n        debugRouteNames = <String>[Navigator.defaultRouteName];\n        return true;\n      }());\n      result.add(\n        navigator._routeNamed<dynamic>(\n          Navigator.defaultRouteName,\n          arguments: null,\n          allowNull: true,\n        ),\n      );\n      final List<String> routeParts = initialRouteName.split('/');\n      if (initialRouteName.isNotEmpty) {\n        String routeName = '';\n        for (final String part in routeParts) {\n          routeName += '/$part';\n          assert(() {\n            debugRouteNames!.add(routeName);\n            return true;\n          }());\n          result.add(navigator._routeNamed<dynamic>(routeName, arguments: null, allowNull: true));\n        }\n      }\n      if (result.last == null) {\n        assert(() {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception:\n                  'Could not navigate to initial route.\\n'\n                  'The requested route name was: \"/$initialRouteName\"\\n'\n                  'There was no corresponding route in the app, and therefore the initial route specified will be '\n                  'ignored and \"${Navigator.defaultRouteName}\" will be used instead.',\n            ),\n          );\n          return true;\n        }());\n        for (final Route<dynamic>? route in result) {\n          route?.dispose();\n        }\n        result.clear();\n      }\n    } else if (initialRouteName != Navigator.defaultRouteName) {\n      // If initialRouteName wasn't '/', then we try to get it with allowNull:true, so that if that fails,\n      // we fall back to '/' (without allowNull:true, see below).\n      result.add(\n        navigator._routeNamed<dynamic>(initialRouteName, arguments: null, allowNull: true),\n      );\n    }\n    // Null route might be a result of gap in initialRouteName\n    //\n    // For example, routes = ['A', 'A/B/C'], and initialRouteName = 'A/B/C'\n    // This should result in result = ['A', null, 'A/B/C'] where 'A/B' produces\n    // the null. In this case, we want to filter out the null and return\n    // result = ['A', 'A/B/C'].\n    result.removeWhere((Route<dynamic>? route) => route == null);\n    if (result.isEmpty) {\n      result.add(navigator._routeNamed<dynamic>(Navigator.defaultRouteName, arguments: null));\n    }\n    return result.cast<Route<dynamic>>();\n  }\n\n  @override\n  NavigatorState createState() => NavigatorState();\n}\n\n// The _RouteLifecycle state machine (only goes down):\n//\n//                    [creation of a _RouteEntry]\n//                                 |\n//                                 +\n//                                 |\\\n//                                 | \\\n//                                 | staging\n//                                 | /\n//                                 |/\n//                    +-+----------+--+-------+\n//                   /  |             |       |\n//                  /   |             |       |\n//                 /    |             |       |\n//                /     |             |       |\n//               /      |             |       |\n//      pushReplace   push*         add*   replace*\n//               \\       |            |       |\n//                \\      |            |      /\n//                 +--pushing#      adding  /\n//                          \\        /     /\n//                           \\      /     /\n//                           idle--+-----+\n//                           /  \\\n//                          /    +------+\n//                         /     |      |\n//                        /      |  complete*\n//                        |      |    /\n//                       pop*  remove*\n//                        /        \\\n//                       /       removing#\n//                     popping#       |\n//                      |             |\n//                   [finalizeRoute]  |\n//                              \\     |\n//                              dispose*\n//                                 |\n//                              disposing\n//                                 |\n//                              disposed\n//                                 |\n//                                 |\n//                  [_RouteEntry garbage collected]\n//                          (terminal state)\n//\n// * These states are transient; as soon as _flushHistoryUpdates is run the\n//   route entry will exit that state.\n// # These states await futures or other events, then transition automatically.\nenum _RouteLifecycle {\n  staging, // we will wait for transition delegate to decide what to do with this route.\n  //\n  // routes that are present:\n  //\n  add, // we'll want to run install, didAdd, etc; a route created by onGenerateInitialRoutes or by the initial widget.pages\n  adding, // we'll waiting for the future from didPush of top-most route to complete\n  // routes that are ready for transition.\n  push, // we'll want to run install, didPush, etc; a route added via push() and friends\n  pushReplace, // we'll want to run install, didPush, etc; a route added via pushReplace() and friends\n  pushing, // we're waiting for the future from didPush to complete\n  replace, // we'll want to run install, didReplace, etc; a route added via replace() and friends\n  idle, // route is being harmless\n  //\n  // routes that are not present:\n  //\n  // routes that should be included in route announcement and should still listen to transition changes.\n  pop, // we'll want to call didPop\n  complete, // we'll want to call didComplete,\n  remove, // we'll want to run didReplace/didRemove etc\n  // routes should not be included in route announcement but should still listen to transition changes.\n  popping, // we're waiting for the route to call finalizeRoute to switch to dispose\n  removing, // we are waiting for subsequent routes to be done animating, then will switch to dispose\n  // routes that are completely removed from the navigator and overlay.\n  dispose, // we will dispose the route momentarily\n  disposing, // The entry is waiting for its widget subtree to be disposed\n  // first. It is stored in _entryWaitingForSubTreeDisposal while\n  // awaiting that.\n  disposed, // we have disposed the route\n}\n\ntypedef _RouteEntryPredicate = bool Function(_RouteEntry entry);\n\n/// Placeholder for a route.\nclass _RoutePlaceholder {\n  const _RoutePlaceholder();\n}\n\nclass _RouteEntry extends RouteTransitionRecord {\n  _RouteEntry(\n    this.route, {\n    required _RouteLifecycle initialState,\n    required this.pageBased,\n    this.restorationInformation,\n  }) : assert(!pageBased || route.settings is Page),\n       assert(\n         initialState == _RouteLifecycle.staging ||\n             initialState == _RouteLifecycle.add ||\n             initialState == _RouteLifecycle.push ||\n             initialState == _RouteLifecycle.pushReplace ||\n             initialState == _RouteLifecycle.replace,\n       ),\n       currentState = initialState {\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: 'package:flutter/widgets.dart',\n        className: '$_RouteEntry',\n        object: this,\n      );\n    }\n  }\n\n  @override\n  final Route<dynamic> route;\n  final _RestorationInformation? restorationInformation;\n  final bool pageBased;\n\n  /// The limit this route entry will attempt to pop in the case of route being\n  /// remove as a result of a page update.\n  static const int kDebugPopAttemptLimit = 100;\n\n  static const _RoutePlaceholder notAnnounced = _RoutePlaceholder();\n\n  _RouteLifecycle currentState;\n  _RoutePlaceholder? lastAnnouncedPreviousRoute =\n      notAnnounced; // last argument to Route.didChangePrevious\n  WeakReference<_RoutePlaceholder> lastAnnouncedPoppedNextRoute = WeakReference<_RoutePlaceholder>(\n    notAnnounced,\n  ); // last argument to Route.didPopNext\n  _RoutePlaceholder? lastAnnouncedNextRoute = notAnnounced; // last argument to Route.didChangeNext\n  int? lastFocusNode; // The last focused semantic node for the route entry.\n\n  /// Restoration ID to be used for the encapsulating route when restoration is\n  /// enabled for it or null if restoration cannot be enabled for it.\n  String? get restorationId {\n    // User-provided restoration ids of Pages are prefixed with 'p+'. Generated\n    // ids for pageless routes are prefixed with 'r+' to avoid clashes.\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      return page.restorationId != null ? 'p+${page.restorationId}' : null;\n    }\n    if (restorationInformation != null) {\n      return 'r+${restorationInformation!.restorationScopeId}';\n    }\n    return null;\n  }\n\n  bool canUpdateFrom(Page<dynamic> page) {\n    if (!willBePresent) {\n      return false;\n    }\n    if (!pageBased) {\n      return false;\n    }\n    final Page<dynamic> routePage = route.settings as Page<dynamic>;\n    return page.canUpdate(routePage);\n  }\n\n  void handleAdd({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(currentState == _RouteLifecycle.add);\n    assert(navigator._debugLocked);\n    currentState = _RouteLifecycle.adding;\n    navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n  }\n\n  void handlePush({\n    required NavigatorState navigator,\n    required bool isNewFirst,\n    required Route<dynamic>? previous,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(\n      currentState == _RouteLifecycle.push ||\n          currentState == _RouteLifecycle.pushReplace ||\n          currentState == _RouteLifecycle.replace,\n    );\n    assert(navigator._debugLocked);\n    assert(\n      route._navigator == null,\n      'The pushed route has already been used. When pushing a route, a new '\n      'Route object must be provided.',\n    );\n    final _RouteLifecycle previousState = currentState;\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    if (currentState == _RouteLifecycle.push || currentState == _RouteLifecycle.pushReplace) {\n      final TickerFuture routeFuture = route.didPush();\n      currentState = _RouteLifecycle.pushing;\n      routeFuture.whenCompleteOrCancel(() {\n        if (currentState == _RouteLifecycle.pushing) {\n          currentState = _RouteLifecycle.idle;\n          assert(!navigator._debugLocked);\n          assert(() {\n            navigator._debugLocked = true;\n            return true;\n          }());\n          navigator._flushHistoryUpdates();\n          assert(() {\n            navigator._debugLocked = false;\n            return true;\n          }());\n        }\n      });\n    } else {\n      assert(currentState == _RouteLifecycle.replace);\n      route.didReplace(previous);\n      currentState = _RouteLifecycle.idle;\n    }\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n\n    if (previousState == _RouteLifecycle.replace || previousState == _RouteLifecycle.pushReplace) {\n      navigator._observedRouteAdditions.add(_NavigatorReplaceObservation(route, previousPresent));\n    } else {\n      assert(previousState == _RouteLifecycle.push);\n      navigator._observedRouteAdditions.add(_NavigatorPushObservation(route, previousPresent));\n    }\n  }\n\n  void handleDidPopNext(Route<dynamic> poppedRoute) {\n    route.didPopNext(poppedRoute);\n    lastAnnouncedPoppedNextRoute = WeakReference<Route<dynamic>>(poppedRoute);\n    if (lastFocusNode != null) {\n      // Move focus back to the last focused node.\n      poppedRoute._disposeCompleter.future.then((dynamic result) async {\n        switch (defaultTargetPlatform) {\n          case TargetPlatform.android:\n            // In the Android platform, we have to wait for the system refocus to complete before\n            // sending the refocus message. Otherwise, the refocus message will be ignored.\n            // TODO(hangyujin): update this logic if Android provide a better way to do so.\n            final int? reFocusNode = lastFocusNode;\n            await Future<void>.delayed(_kAndroidRefocusingDelayDuration);\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: reFocusNode),\n            );\n          case TargetPlatform.iOS:\n            SystemChannels.accessibility.send(\n              const FocusSemanticEvent().toMap(nodeId: lastFocusNode),\n            );\n          case _:\n            break;\n        }\n      });\n    }\n  }\n\n  /// Process the to-be-popped route.\n  ///\n  /// A route can be marked for pop by transition delegate or Navigator.pop,\n  /// this method actually pops the route by calling Route.didPop.\n  ///\n  /// Returns true if the route is popped; otherwise, returns false if the route\n  /// refuses to be popped.\n  bool handlePop({required NavigatorState navigator, required Route<dynamic>? previousPresent}) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.popping;\n    if (route._popCompleter.isCompleted) {\n      // This is a page-based route popped through the Navigator.pop. The\n      // didPop should have been called. No further action is needed.\n      assert(pageBased);\n      assert(pendingResult == null);\n      return true;\n    }\n    if (!route.didPop(pendingResult)) {\n      currentState = _RouteLifecycle.idle;\n      return false;\n    }\n    route.onPopInvokedWithResult(true, pendingResult);\n    if (pageBased) {\n      final Page<Object?> page = route.settings as Page<Object?>;\n      navigator.widget.onDidRemovePage?.call(page);\n    }\n    pendingResult = null;\n    return true;\n  }\n\n  void handleComplete() {\n    route.didComplete(pendingResult);\n    pendingResult = null;\n    assert(route._popCompleter.isCompleted); // implies didComplete was called\n    currentState = _RouteLifecycle.remove;\n  }\n\n  void handleRemoval({\n    required NavigatorState navigator,\n    required Route<dynamic>? previousPresent,\n  }) {\n    assert(navigator._debugLocked);\n    assert(route._navigator == navigator);\n    currentState = _RouteLifecycle.removing;\n    if (_reportRemovalToObserver) {\n      navigator._observedRouteDeletions.add(_NavigatorRemoveObservation(route, previousPresent));\n    }\n  }\n\n  void didAdd({required NavigatorState navigator, required bool isNewFirst}) {\n    assert(route._navigator == null);\n    route._navigator = navigator;\n    route.install();\n    assert(route.overlayEntries.isNotEmpty);\n    route.didAdd();\n    currentState = _RouteLifecycle.idle;\n    if (isNewFirst) {\n      route.didChangeNext(null);\n    }\n  }\n\n  Object? pendingResult;\n\n  void pop<T>(T? result) {\n    assert(isPresent);\n    pendingResult = result;\n    currentState = _RouteLifecycle.pop;\n  }\n\n  bool _reportRemovalToObserver = true;\n\n  // Route is removed without being completed.\n  void remove({bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    currentState = _RouteLifecycle.remove;\n  }\n\n  // Route completes with `result` and is removed.\n  void complete<T>(T result, {bool isReplaced = false}) {\n    assert(\n      !pageBased || isWaitingForExitingDecision,\n      'A page-based route cannot be completed using imperative api, provide a '\n      'new list without the corresponding Page to Navigator.pages instead. ',\n    );\n    if (currentState.index >= _RouteLifecycle.remove.index) {\n      return;\n    }\n    assert(isPresent);\n    _reportRemovalToObserver = !isReplaced;\n    pendingResult = result;\n    currentState = _RouteLifecycle.complete;\n  }\n\n  void finalize() {\n    assert(currentState.index < _RouteLifecycle.dispose.index);\n    currentState = _RouteLifecycle.dispose;\n  }\n\n  /// Disposes this route entry and its [route] immediately.\n  ///\n  /// This method does not wait for the widget subtree of the [route] to unmount\n  /// before disposing.\n  void forcedDispose() {\n    assert(currentState.index < _RouteLifecycle.disposed.index);\n    // TODO(polina-c): stop duplicating code across disposables\n    // https://github.com/flutter/flutter/issues/137435\n    if (kFlutterMemoryAllocationsEnabled) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    currentState = _RouteLifecycle.disposed;\n    route.dispose();\n  }\n\n  /// Disposes this route entry and its [route].\n  ///\n  /// This method waits for the widget subtree of the [route] to unmount before\n  /// disposing. If subtree is already unmounted, this method calls\n  /// [forcedDispose] immediately.\n  ///\n  /// Use [forcedDispose] if the [route] need to be disposed immediately.\n  void dispose() {\n    assert(currentState.index < _RouteLifecycle.disposing.index);\n    currentState = _RouteLifecycle.disposing;\n\n    // If the overlay entries are still mounted, widgets in the route's subtree\n    // may still reference resources from the route and we delay disposal of\n    // the route until the overlay entries are no longer mounted.\n    // Since the overlay entry is the root of the route's subtree it will only\n    // get unmounted after every other widget in the subtree has been unmounted.\n\n    final Iterable<OverlayEntry> mountedEntries = route.overlayEntries.where(\n      (OverlayEntry e) => e.mounted,\n    );\n\n    if (mountedEntries.isEmpty) {\n      forcedDispose();\n      return;\n    }\n\n    int mounted = mountedEntries.length;\n    assert(mounted > 0);\n    final NavigatorState navigator = route._navigator!;\n    navigator._entryWaitingForSubTreeDisposal.add(this);\n    for (final OverlayEntry entry in mountedEntries) {\n      late VoidCallback listener;\n      listener = () {\n        assert(mounted > 0);\n        assert(!entry.mounted);\n        mounted--;\n        entry.removeListener(listener);\n        if (mounted == 0) {\n          assert(route.overlayEntries.every((OverlayEntry e) => !e.mounted));\n          // This is a listener callback of one of the overlayEntries in this\n          // route. Disposing the route also disposes its overlayEntries and\n          // violates the rule that a change notifier can't be disposed during\n          // its notifying callback.\n          //\n          // Use a microtask to ensure the overlayEntries have finished\n          // notifying their listeners before disposing.\n          return scheduleMicrotask(() {\n            if (!navigator._entryWaitingForSubTreeDisposal.remove(this)) {\n              // This route must have been destroyed as a result of navigator\n              // force dispose.\n              assert(route._navigator == null && !navigator.mounted);\n              return;\n            }\n            assert(currentState == _RouteLifecycle.disposing);\n            forcedDispose();\n          });\n        }\n      };\n      entry.addListener(listener);\n    }\n  }\n\n  bool get willBePresent {\n    return currentState.index <= _RouteLifecycle.idle.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresent {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.add.index;\n  }\n\n  bool get isPresentForRestoration => currentState.index <= _RouteLifecycle.idle.index;\n\n  bool get suitableForAnnouncement {\n    return currentState.index <= _RouteLifecycle.removing.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool get suitableForTransitionAnimation {\n    return currentState.index <= _RouteLifecycle.remove.index &&\n        currentState.index >= _RouteLifecycle.push.index;\n  }\n\n  bool shouldAnnounceChangeToNext(Route<dynamic>? nextRoute) {\n    assert(nextRoute != lastAnnouncedNextRoute);\n    // Do not announce if `next` changes from a just popped route to null. We\n    // already announced this change by calling didPopNext.\n    return !(nextRoute == null && lastAnnouncedPoppedNextRoute.target == lastAnnouncedNextRoute);\n  }\n\n  static bool isPresentPredicate(_RouteEntry entry) => entry.isPresent;\n  static bool suitableForTransitionAnimationPredicate(_RouteEntry entry) =>\n      entry.suitableForTransitionAnimation;\n  static bool willBePresentPredicate(_RouteEntry entry) => entry.willBePresent;\n\n  static _RouteEntryPredicate isRoutePredicate(Route<dynamic> route) {\n    return (_RouteEntry entry) => entry.route == route;\n  }\n\n  @override\n  bool get isWaitingForEnteringDecision => currentState == _RouteLifecycle.staging;\n\n  @override\n  bool get isWaitingForExitingDecision => _isWaitingForExitingDecision;\n  bool _isWaitingForExitingDecision = false;\n\n  void markNeedsExitingDecision() => _isWaitingForExitingDecision = true;\n\n  @override\n  void markForPush() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for push. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.push;\n  }\n\n  @override\n  void markForAdd() {\n    assert(\n      isWaitingForEnteringDecision && !isWaitingForExitingDecision,\n      'This route cannot be marked for add. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition in.',\n    );\n    currentState = _RouteLifecycle.add;\n  }\n\n  @override\n  void markForPop([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for pop. Either a decision has already been '\n      'made or it does not require an explicit decision on how to transition out.',\n    );\n    // Remove state that prevents a pop, e.g. LocalHistoryEntry[s].\n    int attempt = 0;\n    while (route.willHandlePopInternally) {\n      assert(() {\n        attempt += 1;\n        return attempt < kDebugPopAttemptLimit;\n      }(), 'Attempted to pop $route $kDebugPopAttemptLimit times, but still failed');\n      final bool popResult = route.didPop(result);\n      assert(!popResult);\n    }\n    pop<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForComplete([dynamic result]) {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for complete. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    complete<dynamic>(result);\n    _isWaitingForExitingDecision = false;\n  }\n\n  @override\n  void markForRemove() {\n    assert(\n      !isWaitingForEnteringDecision && isWaitingForExitingDecision && isPresent,\n      'This route cannot be marked for remove. Either a decision has already '\n      'been made or it does not require an explicit decision on how to transition '\n      'out.',\n    );\n    remove();\n    _isWaitingForExitingDecision = false;\n  }\n\n  bool get restorationEnabled => route.restorationScopeId.value != null;\n  set restorationEnabled(bool value) {\n    assert(!value || restorationId != null);\n    route._updateRestorationId(value ? restorationId : null);\n  }\n}\n\nabstract class _NavigatorObservation {\n  _NavigatorObservation(this.primaryRoute, this.secondaryRoute);\n  final Route<dynamic> primaryRoute;\n  final Route<dynamic>? secondaryRoute;\n\n  void notify(NavigatorObserver observer);\n}\n\nclass _NavigatorPushObservation extends _NavigatorObservation {\n  _NavigatorPushObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPush(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorPopObservation extends _NavigatorObservation {\n  _NavigatorPopObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didPop(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorRemoveObservation extends _NavigatorObservation {\n  _NavigatorRemoveObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didRemove(primaryRoute, secondaryRoute);\n  }\n}\n\nclass _NavigatorReplaceObservation extends _NavigatorObservation {\n  _NavigatorReplaceObservation(super.primaryRoute, super.secondaryRoute);\n\n  @override\n  void notify(NavigatorObserver observer) {\n    observer.didReplace(newRoute: primaryRoute, oldRoute: secondaryRoute);\n  }\n}\n\ntypedef _IndexWhereCallback = bool Function(_RouteEntry element);\n\n/// A collection of _RouteEntries representing a navigation history.\n///\n/// Acts as a ChangeNotifier and notifies after its List of _RouteEntries is\n/// mutated.\nclass _History extends Iterable<_RouteEntry> with ChangeNotifier {\n  /// Creates an instance of [_History].\n  _History() {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  final List<_RouteEntry> _value = <_RouteEntry>[];\n\n  int indexWhere(_IndexWhereCallback test, [int start = 0]) {\n    return _value.indexWhere(test, start);\n  }\n\n  void add(_RouteEntry element) {\n    _value.add(element);\n    notifyListeners();\n  }\n\n  void addAll(Iterable<_RouteEntry> elements) {\n    _value.addAll(elements);\n    if (elements.isNotEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void clear() {\n    final bool valueWasEmpty = _value.isEmpty;\n    _value.clear();\n    if (!valueWasEmpty) {\n      notifyListeners();\n    }\n  }\n\n  void insert(int index, _RouteEntry element) {\n    _value.insert(index, element);\n    notifyListeners();\n  }\n\n  _RouteEntry removeAt(int index) {\n    final _RouteEntry entry = _value.removeAt(index);\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry removeLast() {\n    final _RouteEntry entry = _value.removeLast();\n    notifyListeners();\n    return entry;\n  }\n\n  _RouteEntry operator [](int index) {\n    return _value[index];\n  }\n\n  @override\n  Iterator<_RouteEntry> get iterator {\n    return _value.iterator;\n  }\n\n  @override\n  String toString() {\n    return _value.toString();\n  }\n}\n\n/// The state for a [Navigator] widget.\n///\n/// A reference to this class can be obtained by calling [Navigator.of].\nclass NavigatorState extends State<Navigator> with TickerProviderStateMixin, RestorationMixin {\n  late GlobalKey<OverlayState> _overlayKey;\n  final _History _history = _History();\n\n  /// A set for entries that are waiting to dispose until their subtrees are\n  /// disposed.\n  ///\n  /// These entries are not considered to be in the _history and will usually\n  /// remove themselves from this set once they can dispose.\n  ///\n  /// The navigator keep track of these entries so that, in case the navigator\n  /// itself is disposed, it can dispose these entries immediately.\n  final Set<_RouteEntry> _entryWaitingForSubTreeDisposal = <_RouteEntry>{};\n  final _HistoryProperty _serializableHistory = _HistoryProperty();\n  final Queue<_NavigatorObservation> _observedRouteAdditions = Queue<_NavigatorObservation>();\n  final Queue<_NavigatorObservation> _observedRouteDeletions = Queue<_NavigatorObservation>();\n\n  /// The [FocusNode] for the [Focus] that encloses the routes.\n  final FocusNode focusNode = FocusNode(debugLabel: 'Navigator');\n\n  bool _debugLocked = false; // used to prevent re-entrant calls to push, pop, and friends\n\n  HeroController? _heroControllerFromScope;\n\n  late List<NavigatorObserver> _effectiveObservers;\n\n  bool get _usingPagesAPI => widget.pages != const <Page<dynamic>>[];\n\n  void _handleHistoryChanged() {\n    final bool navigatorCanPop = canPop();\n    final bool routeBlocksPop;\n    if (!navigatorCanPop) {\n      final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n      routeBlocksPop =\n          lastEntry != null && lastEntry.route.popDisposition == RoutePopDisposition.doNotPop;\n    } else {\n      routeBlocksPop = false;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      canHandlePop: navigatorCanPop || routeBlocksPop,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(context);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!mounted) {\n            return;\n          }\n          notification.dispatch(context);\n        }, debugLabel: 'Navigator.dispatchNotification');\n    }\n  }\n\n  bool _debugCheckPageApiParameters() {\n    if (!_usingPagesAPI) {\n      return true;\n    }\n    if (widget.pages.isEmpty) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'The Navigator.pages must not be empty to use the '\n            'Navigator.pages API',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    } else if ((widget.onDidRemovePage == null) == (widget.onPopPage == null)) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: FlutterError(\n            'Either onDidRemovePage or onPopPage must be provided to use the '\n            'Navigator.pages API but not both.',\n          ),\n          library: 'widget library',\n          stack: StackTrace.current,\n        ),\n      );\n    }\n    return true;\n  }\n\n  @protected\n  @override\n  void initState() {\n    super.initState();\n    assert(_debugCheckPageApiParameters());\n    for (final NavigatorObserver observer in widget.observers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n    _effectiveObservers = widget.observers;\n\n    // We have to manually extract the inherited widget in initState because\n    // the current context is not fully initialized.\n    final HeroControllerScope? heroControllerScope =\n        context.getElementForInheritedWidgetOfExactType<HeroControllerScope>()?.widget\n            as HeroControllerScope?;\n    _updateHeroController(heroControllerScope?.controller);\n\n    if (widget.reportsRouteUpdateToEngine) {\n      SystemNavigator.selectSingleEntryHistory();\n    }\n\n    ServicesBinding.instance.accessibilityFocus.addListener(_recordLastFocus);\n    _history.addListener(_handleHistoryChanged);\n  }\n\n  // Record the last focused node in route entry.\n  void _recordLastFocus() {\n    final _RouteEntry? entry = _history.where(_RouteEntry.isPresentPredicate).lastOrNull;\n    entry?.lastFocusNode = ServicesBinding.instance.accessibilityFocus.value;\n  }\n\n  // Use [_nextPagelessRestorationScopeId] to get the next id.\n  final RestorableNum<int> _rawNextPagelessRestorationScopeId = RestorableNum<int>(0);\n\n  int get _nextPagelessRestorationScopeId => _rawNextPagelessRestorationScopeId.value++;\n\n  @protected\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_rawNextPagelessRestorationScopeId, 'id');\n    registerForRestoration(_serializableHistory, 'history');\n\n    // Delete everything in the old history and clear the overlay.\n    _forcedDisposeAllRouteEntries();\n    assert(_history.isEmpty);\n    _overlayKey = GlobalKey<OverlayState>();\n\n    // Populate the new history from restoration data.\n    _history.addAll(_serializableHistory.restoreEntriesForPage(null, this));\n    for (final Page<dynamic> page in widget.pages) {\n      final _RouteEntry entry = _RouteEntry(\n        page.createRoute(context),\n        pageBased: true,\n        initialState: _RouteLifecycle.add,\n      );\n      assert(\n        entry.route.settings == page,\n        'The settings getter of a page-based Route must return a Page object. '\n        'Please set the settings to the Page in the Page.createRoute method.',\n      );\n      _history.add(entry);\n      _history.addAll(_serializableHistory.restoreEntriesForPage(entry, this));\n    }\n\n    // If there was nothing to restore, we need to process the initial route.\n    if (!_serializableHistory.hasData) {\n      String? initialRoute = widget.initialRoute;\n      if (widget.pages.isEmpty) {\n        initialRoute ??= Navigator.defaultRouteName;\n      }\n      if (initialRoute != null) {\n        _history.addAll(\n          widget\n              .onGenerateInitialRoutes(this, widget.initialRoute ?? Navigator.defaultRouteName)\n              .map(\n                (Route<dynamic> route) => _RouteEntry(\n                  route,\n                  pageBased: false,\n                  initialState: _RouteLifecycle.add,\n                  restorationInformation:\n                      route.settings.name != null\n                          ? _RestorationInformation.named(\n                            name: route.settings.name!,\n                            arguments: null,\n                            restorationScopeId: _nextPagelessRestorationScopeId,\n                          )\n                          : null,\n                ),\n              ),\n        );\n      }\n    }\n\n    assert(\n      _history.isNotEmpty,\n      'All routes returned by onGenerateInitialRoutes are not restorable. '\n      'Please make sure that all routes returned by onGenerateInitialRoutes '\n      'have their RouteSettings defined with names that are defined in the '\n      \"app's routes table.\",\n    );\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void didToggleBucket(RestorationBucket? oldBucket) {\n    super.didToggleBucket(oldBucket);\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    } else {\n      _serializableHistory.clear();\n    }\n  }\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @protected\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _updateHeroController(HeroControllerScope.maybeOf(context));\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  /// Dispose all lingering router entries immediately.\n  void _forcedDisposeAllRouteEntries() {\n    _entryWaitingForSubTreeDisposal.removeWhere((_RouteEntry entry) {\n      entry.forcedDispose();\n      return true;\n    });\n    while (_history.isNotEmpty) {\n      _disposeRouteEntry(_history.removeLast(), graceful: false);\n    }\n  }\n\n  static void _disposeRouteEntry(_RouteEntry entry, {required bool graceful}) {\n    for (final OverlayEntry overlayEntry in entry.route.overlayEntries) {\n      overlayEntry.remove();\n    }\n    if (graceful) {\n      entry.dispose();\n    } else {\n      entry.forcedDispose();\n    }\n  }\n\n  void _updateHeroController(HeroController? newHeroController) {\n    if (_heroControllerFromScope != newHeroController) {\n      if (newHeroController != null) {\n        // Makes sure the same hero controller is not shared between two navigators.\n        assert(() {\n          // It is possible that the hero controller subscribes to an existing\n          // navigator. We are fine as long as that navigator gives up the hero\n          // controller at the end of the build.\n          if (newHeroController.navigator != null) {\n            final NavigatorState previousOwner = newHeroController.navigator!;\n            ServicesBinding.instance.addPostFrameCallback((Duration timestamp) {\n              // We only check if this navigator still owns the hero controller.\n              if (_heroControllerFromScope == newHeroController) {\n                final bool hasHeroControllerOwnerShip = _heroControllerFromScope!.navigator == this;\n                if (!hasHeroControllerOwnerShip ||\n                    previousOwner._heroControllerFromScope == newHeroController) {\n                  final NavigatorState otherOwner =\n                      hasHeroControllerOwnerShip\n                          ? previousOwner\n                          : _heroControllerFromScope!.navigator!;\n                  FlutterError.reportError(\n                    FlutterErrorDetails(\n                      exception: FlutterError(\n                        'A HeroController can not be shared by multiple Navigators. '\n                        'The Navigators that share the same HeroController are:\\n'\n                        '- $this\\n'\n                        '- $otherOwner\\n'\n                        'Please create a HeroControllerScope for each Navigator or '\n                        'use a HeroControllerScope.none to prevent subtree from '\n                        'receiving a HeroController.',\n                      ),\n                      library: 'widget library',\n                      stack: StackTrace.current,\n                    ),\n                  );\n                }\n              }\n            }, debugLabel: 'Navigator.checkHeroControllerOwnership');\n          }\n          return true;\n        }());\n        NavigatorObserver._navigators[newHeroController] = this;\n      }\n      // Only unsubscribe the hero controller when it is currently subscribe to\n      // this navigator.\n      if (_heroControllerFromScope?.navigator == this) {\n        NavigatorObserver._navigators[_heroControllerFromScope!] = null;\n      }\n      _heroControllerFromScope = newHeroController;\n      _updateEffectiveObservers();\n    }\n  }\n\n  void _updateEffectiveObservers() {\n    if (_heroControllerFromScope != null) {\n      _effectiveObservers = widget.observers + <NavigatorObserver>[_heroControllerFromScope!];\n    } else {\n      _effectiveObservers = widget.observers;\n    }\n  }\n\n  @protected\n  @override\n  void didUpdateWidget(Navigator oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(_debugCheckPageApiParameters());\n    if (oldWidget.observers != widget.observers) {\n      for (final NavigatorObserver observer in oldWidget.observers) {\n        NavigatorObserver._navigators[observer] = null;\n      }\n      for (final NavigatorObserver observer in widget.observers) {\n        assert(observer.navigator == null);\n        NavigatorObserver._navigators[observer] = this;\n      }\n      _updateEffectiveObservers();\n    }\n    if (oldWidget.pages != widget.pages && !restorePending) {\n      assert(() {\n        if (widget.pages.isEmpty) {\n          FlutterError.reportError(\n            FlutterErrorDetails(\n              exception: FlutterError(\n                'The Navigator.pages must not be empty to use the '\n                'Navigator.pages API',\n              ),\n              library: 'widget library',\n              stack: StackTrace.current,\n            ),\n          );\n        }\n        return true;\n      }());\n      _updatePages();\n    }\n\n    for (final _RouteEntry entry in _history) {\n      if (entry.route.navigator == this) {\n        entry.route.changedExternalState();\n      }\n    }\n  }\n\n  void _debugCheckDuplicatedPageKeys() {\n    assert(() {\n      final Set<Key> keyReservation = <Key>{};\n      for (final Page<dynamic> page in widget.pages) {\n        final LocalKey? key = page.key;\n        if (key != null) {\n          assert(!keyReservation.contains(key));\n          keyReservation.add(key);\n        }\n      }\n      return true;\n    }());\n  }\n\n  @protected\n  @override\n  void deactivate() {\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      NavigatorObserver._navigators[observer] = null;\n    }\n    _effectiveObservers = <NavigatorObserver>[];\n    super.deactivate();\n  }\n\n  @protected\n  @override\n  void activate() {\n    super.activate();\n    _updateEffectiveObservers();\n    for (final NavigatorObserver observer in _effectiveObservers) {\n      assert(observer.navigator == null);\n      NavigatorObserver._navigators[observer] = this;\n    }\n  }\n\n  @protected\n  @override\n  void dispose() {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_effectiveObservers.isEmpty);\n    _updateHeroController(null);\n    focusNode.dispose();\n    _forcedDisposeAllRouteEntries();\n    _rawNextPagelessRestorationScopeId.dispose();\n    _serializableHistory.dispose();\n    userGestureInProgressNotifier.dispose();\n    ServicesBinding.instance.accessibilityFocus.removeListener(_recordLastFocus);\n    _history.removeListener(_handleHistoryChanged);\n    _history.dispose();\n    super.dispose();\n    // don't unlock, so that the object becomes unusable\n    assert(_debugLocked);\n  }\n\n  /// The overlay this navigator uses for its visual presentation.\n  OverlayState? get overlay => _overlayKey.currentState;\n\n  Iterable<OverlayEntry> get _allRouteOverlayEntries {\n    return <OverlayEntry>[for (final _RouteEntry entry in _history) ...entry.route.overlayEntries];\n  }\n\n  _RouteEntry? _lastTopmostRoute;\n  String? _lastAnnouncedRouteName;\n\n  bool _debugUpdatingPage = false;\n  void _updatePages() {\n    assert(() {\n      assert(!_debugUpdatingPage);\n      _debugCheckDuplicatedPageKeys();\n      _debugUpdatingPage = true;\n      return true;\n    }());\n\n    // This attempts to diff the new pages list (widget.pages) with\n    // the old _RouteEntry(s) list (_history), and produces a new list of\n    // _RouteEntry(s) to be the new list of _history. This method roughly\n    // follows the same outline of RenderObjectElement.updateChildren.\n    //\n    // The cases it tries to optimize for are:\n    //  - the old list is empty\n    //  - All the pages in the new list can match the page-based routes in the old\n    //    list, and their orders are the same.\n    //  - there is an insertion or removal of one or more page-based route in\n    //    only one place in the list\n    // If a page-based route with a key is in both lists, it will be synced.\n    // Page-based routes without keys might be synced but there is no guarantee.\n\n    // The general approach is to sync the entire new list backwards, as follows:\n    // 1. Walk the lists from the bottom, syncing nodes, and record pageless routes,\n    //    until you no longer have matching nodes.\n    // 2. Walk the lists from the top, without syncing nodes, until you no\n    //    longer have matching nodes. We'll sync these nodes at the end. We\n    //    don't sync them now because we want to sync all the nodes in order\n    //    from beginning to end.\n    // At this point we narrowed the old and new lists to the point\n    // where the nodes no longer match.\n    // 3. Walk the narrowed part of the old list to get the list of\n    //    keys.\n    // 4. Walk the narrowed part of the new list forwards:\n    //     * Create a new _RouteEntry for non-keyed items and record them for\n    //       transitionDelegate.\n    //     * Sync keyed items with the source if it exists.\n    // 5. Walk the narrowed part of the old list again to records the\n    //    _RouteEntry(s), as well as pageless routes, needed to be removed for\n    //    transitionDelegate.\n    // 5. Walk the top of the list again, syncing the nodes and recording\n    //    pageless routes.\n    // 6. Use transitionDelegate for explicit decisions on how _RouteEntry(s)\n    //    transition in or off the screens.\n    // 7. Fill pageless routes back into the new history.\n\n    bool needsExplicitDecision = false;\n    int newPagesBottom = 0;\n    int oldEntriesBottom = 0;\n    int newPagesTop = widget.pages.length - 1;\n    int oldEntriesTop = _history.length - 1;\n\n    final List<_RouteEntry> newHistory = <_RouteEntry>[];\n    final Map<_RouteEntry?, List<_RouteEntry>> pageRouteToPagelessRoutes =\n        <_RouteEntry?, List<_RouteEntry>>{};\n\n    // Updates the bottom of the list.\n    _RouteEntry? previousOldPageRouteEntry;\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Records pageless route. The bottom most pageless routes will be\n      // stored in key = null.\n      if (!oldEntry.pageBased) {\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        oldEntriesBottom += 1;\n        continue;\n      }\n      if (newPagesBottom > newPagesTop) {\n        break;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      newPagesBottom += 1;\n      oldEntriesBottom += 1;\n    }\n\n    final List<_RouteEntry> unattachedPagelessRoutes = <_RouteEntry>[];\n    // Scans the top of the list until we found a page-based route that cannot be\n    // updated.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesTop];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        unattachedPagelessRoutes.add(oldEntry);\n        oldEntriesTop -= 1;\n        continue;\n      }\n      final Page<dynamic> newPage = widget.pages[newPagesTop];\n      if (!oldEntry.canUpdateFrom(newPage)) {\n        break;\n      }\n\n      // We found the page for all the consecutive pageless routes below. Attach these\n      // pageless routes to the page.\n      if (unattachedPagelessRoutes.isNotEmpty) {\n        pageRouteToPagelessRoutes.putIfAbsent(\n          oldEntry,\n          () => List<_RouteEntry>.from(unattachedPagelessRoutes),\n        );\n        unattachedPagelessRoutes.clear();\n      }\n\n      oldEntriesTop -= 1;\n      newPagesTop -= 1;\n    }\n    // Reverts the pageless routes that cannot be updated.\n    oldEntriesTop += unattachedPagelessRoutes.length;\n\n    // Scans middle of the old entries and records the page key to old entry map.\n    int oldEntriesBottomToScan = oldEntriesBottom;\n    final Map<LocalKey, _RouteEntry> pageKeyToOldEntry = <LocalKey, _RouteEntry>{};\n    // This set contains entries that are transitioning out but are still in\n    // the route stack.\n    final Set<_RouteEntry> phantomEntries = <_RouteEntry>{};\n    while (oldEntriesBottomToScan <= oldEntriesTop) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottomToScan];\n      oldEntriesBottomToScan += 1;\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      // Pageless routes will be recorded when we update the middle of the old\n      // list.\n      if (!oldEntry.pageBased) {\n        continue;\n      }\n\n      final Page<dynamic> page = oldEntry.route.settings as Page<dynamic>;\n      if (page.key == null) {\n        continue;\n      }\n\n      if (!oldEntry.willBePresent) {\n        phantomEntries.add(oldEntry);\n        continue;\n      }\n      assert(!pageKeyToOldEntry.containsKey(page.key));\n      pageKeyToOldEntry[page.key!] = oldEntry;\n    }\n\n    // Updates the middle of the list.\n    while (newPagesBottom <= newPagesTop) {\n      final Page<dynamic> nextPage = widget.pages[newPagesBottom];\n      newPagesBottom += 1;\n      if (nextPage.key == null ||\n          !pageKeyToOldEntry.containsKey(nextPage.key) ||\n          !pageKeyToOldEntry[nextPage.key]!.canUpdateFrom(nextPage)) {\n        // There is no matching key in the old history, we need to create a new\n        // route and wait for the transition delegate to decide how to add\n        // it into the history.\n        final _RouteEntry newEntry = _RouteEntry(\n          nextPage.createRoute(context),\n          pageBased: true,\n          initialState: _RouteLifecycle.staging,\n        );\n        needsExplicitDecision = true;\n        assert(\n          newEntry.route.settings == nextPage,\n          'The settings getter of a page-based Route must return a Page object. '\n          'Please set the settings to the Page in the Page.createRoute method.',\n        );\n        newHistory.add(newEntry);\n      } else {\n        // Removes the key from pageKeyToOldEntry to indicate it is taken.\n        final _RouteEntry matchingEntry = pageKeyToOldEntry.remove(nextPage.key)!;\n        assert(matchingEntry.canUpdateFrom(nextPage));\n        matchingEntry.route._updateSettings(nextPage);\n        newHistory.add(matchingEntry);\n      }\n    }\n\n    // Any remaining old routes that do not have a match will need to be removed.\n    final Map<RouteTransitionRecord?, RouteTransitionRecord> locationToExitingPageRoute =\n        <RouteTransitionRecord?, RouteTransitionRecord>{};\n    while (oldEntriesBottom <= oldEntriesTop) {\n      final _RouteEntry potentialEntryToRemove = _history[oldEntriesBottom];\n      oldEntriesBottom += 1;\n\n      if (!potentialEntryToRemove.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(potentialEntryToRemove);\n        if (previousOldPageRouteEntry!.isWaitingForExitingDecision &&\n            potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n        continue;\n      }\n\n      final Page<dynamic> potentialPageToRemove =\n          potentialEntryToRemove.route.settings as Page<dynamic>;\n      // Marks for transition delegate to remove if this old page does not have\n      // a key, was not taken during updating the middle of new page, or is\n      // already transitioning out.\n      if (potentialPageToRemove.key == null ||\n          pageKeyToOldEntry.containsKey(potentialPageToRemove.key) ||\n          phantomEntries.contains(potentialEntryToRemove)) {\n        locationToExitingPageRoute[previousOldPageRouteEntry] = potentialEntryToRemove;\n        // We only need a decision if it has not already been popped.\n        if (potentialEntryToRemove.willBePresent) {\n          potentialEntryToRemove.markNeedsExitingDecision();\n        }\n      }\n      previousOldPageRouteEntry = potentialEntryToRemove;\n    }\n\n    // We've scanned the whole list.\n    assert(oldEntriesBottom == oldEntriesTop + 1);\n    assert(newPagesBottom == newPagesTop + 1);\n    newPagesTop = widget.pages.length - 1;\n    oldEntriesTop = _history.length - 1;\n    // Verifies we either reach the bottom or the oldEntriesBottom must be updatable\n    // by newPagesBottom.\n    assert(() {\n      if (oldEntriesBottom <= oldEntriesTop) {\n        return newPagesBottom <= newPagesTop &&\n            _history[oldEntriesBottom].pageBased &&\n            _history[oldEntriesBottom].canUpdateFrom(widget.pages[newPagesBottom]);\n      } else {\n        return newPagesBottom > newPagesTop;\n      }\n    }());\n\n    // Updates the top of the list.\n    while ((oldEntriesBottom <= oldEntriesTop) && (newPagesBottom <= newPagesTop)) {\n      final _RouteEntry oldEntry = _history[oldEntriesBottom];\n      assert(oldEntry.currentState != _RouteLifecycle.disposed);\n      if (!oldEntry.pageBased) {\n        assert(previousOldPageRouteEntry != null);\n        final List<_RouteEntry> pagelessRoutes = pageRouteToPagelessRoutes.putIfAbsent(\n          previousOldPageRouteEntry,\n          () => <_RouteEntry>[],\n        );\n        pagelessRoutes.add(oldEntry);\n        continue;\n      }\n      previousOldPageRouteEntry = oldEntry;\n      final Page<dynamic> newPage = widget.pages[newPagesBottom];\n      assert(oldEntry.canUpdateFrom(newPage));\n      oldEntry.route._updateSettings(newPage);\n      newHistory.add(oldEntry);\n      oldEntriesBottom += 1;\n      newPagesBottom += 1;\n    }\n\n    // Finally, uses transition delegate to make explicit decision if needed.\n    needsExplicitDecision = needsExplicitDecision || locationToExitingPageRoute.isNotEmpty;\n    Iterable<_RouteEntry> results = newHistory;\n    if (needsExplicitDecision) {\n      results =\n          widget.transitionDelegate\n              ._transition(\n                newPageRouteHistory: newHistory,\n                locationToExitingPageRoute: locationToExitingPageRoute,\n                pageRouteToPagelessRoutes: pageRouteToPagelessRoutes,\n              )\n              .cast<_RouteEntry>();\n    }\n    _history.clear();\n    // Adds the leading pageless routes if there is any.\n    if (pageRouteToPagelessRoutes.containsKey(null)) {\n      _history.addAll(pageRouteToPagelessRoutes[null]!);\n    }\n    for (final _RouteEntry result in results) {\n      _history.add(result);\n      if (pageRouteToPagelessRoutes.containsKey(result)) {\n        _history.addAll(pageRouteToPagelessRoutes[result]!);\n      }\n    }\n    assert(() {\n      _debugUpdatingPage = false;\n      return true;\n    }());\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  bool _flushingHistory = false;\n\n  void _flushHistoryUpdates({bool rearrangeOverlay = true}) {\n    assert(_debugLocked && !_debugUpdatingPage);\n    _flushingHistory = true;\n    // Clean up the list, sending updates to the routes that changed. Notably,\n    // we don't send the didChangePrevious/didChangeNext updates to those that\n    // did not change at this point, because we're not yet sure exactly what the\n    // routes will be at the end of the day (some might get disposed).\n    int index = _history.length - 1;\n    _RouteEntry? next;\n    _RouteEntry? entry = _history[index];\n    _RouteEntry? previous = index > 0 ? _history[index - 1] : null;\n    bool canRemoveOrAdd =\n        false; // Whether there is a fully opaque route on top to silently remove or add route underneath.\n    Route<dynamic>?\n    poppedRoute; // The route that should trigger didPopNext on the top active route.\n    bool seenTopActiveRoute = false; // Whether we've seen the route that would get didPopNext.\n    final List<_RouteEntry> toBeDisposed = <_RouteEntry>[];\n    while (index >= 0) {\n      switch (entry!.currentState) {\n        case _RouteLifecycle.add:\n          assert(rearrangeOverlay);\n          entry.handleAdd(\n            navigator: this,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.adding);\n          continue;\n        case _RouteLifecycle.adding:\n          if (canRemoveOrAdd || next == null) {\n            entry.didAdd(navigator: this, isNewFirst: next == null);\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n        case _RouteLifecycle.push:\n        case _RouteLifecycle.pushReplace:\n        case _RouteLifecycle.replace:\n          assert(rearrangeOverlay);\n          entry.handlePush(\n            navigator: this,\n            previous: previous?.route,\n            previousPresent: _getRouteBefore(index - 1, _RouteEntry.isPresentPredicate)?.route,\n            isNewFirst: next == null,\n          );\n          assert(entry.currentState != _RouteLifecycle.push);\n          assert(entry.currentState != _RouteLifecycle.pushReplace);\n          assert(entry.currentState != _RouteLifecycle.replace);\n          if (entry.currentState == _RouteLifecycle.idle) {\n            continue;\n          }\n        case _RouteLifecycle.pushing: // Will exit this state when animation completes.\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n        case _RouteLifecycle.idle:\n          if (!seenTopActiveRoute && poppedRoute != null) {\n            entry.handleDidPopNext(poppedRoute);\n          }\n          seenTopActiveRoute = true;\n          // This route is idle, so we are allowed to remove subsequent (earlier)\n          // routes that are waiting to be removed silently:\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.pop:\n          if (!entry.handlePop(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          )) {\n            assert(entry.currentState == _RouteLifecycle.idle);\n            continue;\n          }\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.handleDidPopNext(poppedRoute);\n            }\n            poppedRoute = entry.route;\n          }\n          _observedRouteDeletions.add(\n            _NavigatorPopObservation(\n              entry.route,\n              _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n            ),\n          );\n          if (entry.currentState == _RouteLifecycle.dispose) {\n            // The pop finished synchronously. This can happen if transition\n            // duration is zero.\n            continue;\n          }\n          assert(entry.currentState == _RouteLifecycle.popping);\n          canRemoveOrAdd = true;\n        case _RouteLifecycle.popping:\n          // Will exit this state when animation completes.\n          break;\n        case _RouteLifecycle.complete:\n          entry.handleComplete();\n          assert(entry.currentState == _RouteLifecycle.remove);\n          continue;\n        case _RouteLifecycle.remove:\n          if (!seenTopActiveRoute) {\n            if (poppedRoute != null) {\n              entry.route.didPopNext(poppedRoute);\n            }\n            poppedRoute = null;\n          }\n          entry.handleRemoval(\n            navigator: this,\n            previousPresent: _getRouteBefore(index, _RouteEntry.willBePresentPredicate)?.route,\n          );\n          assert(entry.currentState == _RouteLifecycle.removing);\n          continue;\n        case _RouteLifecycle.removing:\n          if (!canRemoveOrAdd && next != null) {\n            // We aren't allowed to remove this route yet.\n            break;\n          }\n          if (entry.pageBased) {\n            widget.onDidRemovePage?.call(entry.route.settings as Page<Object?>);\n          }\n          entry.currentState = _RouteLifecycle.dispose;\n          continue;\n        case _RouteLifecycle.dispose:\n          // Delay disposal until didChangeNext/didChangePrevious have been sent.\n          toBeDisposed.add(_history.removeAt(index));\n          entry = next;\n        case _RouteLifecycle.disposing:\n        case _RouteLifecycle.disposed:\n        case _RouteLifecycle.staging:\n          assert(false);\n      }\n      index -= 1;\n      next = entry;\n      entry = previous;\n      previous = index > 0 ? _history[index - 1] : null;\n    }\n    // Informs navigator observers about route changes.\n    _flushObserverNotifications();\n\n    // Now that the list is clean, send the didChangeNext/didChangePrevious\n    // notifications.\n    _flushRouteAnnouncement();\n\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != null && _lastTopmostRoute != lastEntry) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didChangeTop(lastEntry.route, _lastTopmostRoute?.route);\n      }\n    }\n    _lastTopmostRoute = lastEntry;\n    // Announce route name changes.\n    if (widget.reportsRouteUpdateToEngine) {\n      final String? routeName = lastEntry?.route.settings.name;\n      if (routeName != null && routeName != _lastAnnouncedRouteName) {\n        SystemNavigator.routeInformationUpdated(uri: Uri.parse(routeName));\n        _lastAnnouncedRouteName = routeName;\n      }\n    }\n\n    // Lastly, removes the overlay entries of all marked entries and disposes\n    // them.\n    for (final _RouteEntry entry in toBeDisposed) {\n      _disposeRouteEntry(entry, graceful: true);\n    }\n    if (rearrangeOverlay) {\n      overlay?.rearrange(_allRouteOverlayEntries);\n    }\n    if (bucket != null) {\n      _serializableHistory.update(_history);\n    }\n    _flushingHistory = false;\n  }\n\n  void _flushObserverNotifications() {\n    if (_effectiveObservers.isEmpty) {\n      _observedRouteDeletions.clear();\n      _observedRouteAdditions.clear();\n      return;\n    }\n    while (_observedRouteAdditions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteAdditions.removeLast();\n      _effectiveObservers.forEach(observation.notify);\n    }\n\n    while (_observedRouteDeletions.isNotEmpty) {\n      final _NavigatorObservation observation = _observedRouteDeletions.removeFirst();\n      _effectiveObservers.forEach(observation.notify);\n    }\n  }\n\n  void _flushRouteAnnouncement() {\n    int index = _history.length - 1;\n    while (index >= 0) {\n      final _RouteEntry entry = _history[index];\n      if (!entry.suitableForAnnouncement) {\n        index -= 1;\n        continue;\n      }\n      final _RouteEntry? next = _getRouteAfter(\n        index + 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n\n      if (next?.route != entry.lastAnnouncedNextRoute) {\n        if (entry.shouldAnnounceChangeToNext(next?.route)) {\n          entry.route.didChangeNext(next?.route);\n        }\n        entry.lastAnnouncedNextRoute = next?.route;\n      }\n      final _RouteEntry? previous = _getRouteBefore(\n        index - 1,\n        _RouteEntry.suitableForTransitionAnimationPredicate,\n      );\n      if (previous?.route != entry.lastAnnouncedPreviousRoute) {\n        entry.route.didChangePrevious(previous?.route);\n        entry.lastAnnouncedPreviousRoute = previous?.route;\n      }\n      index -= 1;\n    }\n  }\n\n  _RouteEntry? _getRouteBefore(int index, _RouteEntryPredicate predicate) {\n    index = _getIndexBefore(index, predicate);\n    return index >= 0 ? _history[index] : null;\n  }\n\n  int _getIndexBefore(int index, _RouteEntryPredicate predicate) {\n    while (index >= 0 && !predicate(_history[index])) {\n      index -= 1;\n    }\n    return index;\n  }\n\n  _RouteEntry? _getRouteAfter(int index, _RouteEntryPredicate predicate) {\n    while (index < _history.length && !predicate(_history[index])) {\n      index += 1;\n    }\n    return index < _history.length ? _history[index] : null;\n  }\n\n  Route<T?>? _routeNamed<T>(String name, {required Object? arguments, bool allowNull = false}) {\n    assert(!_debugLocked);\n    if (allowNull && widget.onGenerateRoute == null) {\n      return null;\n    }\n    assert(() {\n      if (widget.onGenerateRoute == null) {\n        throw FlutterError(\n          'Navigator.onGenerateRoute was null, but the route named \"$name\" was referenced.\\n'\n          'To use the Navigator API with named routes (pushNamed, pushReplacementNamed, or '\n          'pushNamedAndRemoveUntil), the Navigator must be provided with an '\n          'onGenerateRoute handler.\\n'\n          'The Navigator was:\\n'\n          '  $this',\n        );\n      }\n      return true;\n    }());\n    final RouteSettings settings = RouteSettings(name: name, arguments: arguments);\n    Route<T?>? route = widget.onGenerateRoute!(settings) as Route<T?>?;\n    if (route == null && !allowNull) {\n      assert(() {\n        if (widget.onUnknownRoute == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onGenerateRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription(\n              'The onGenerateRoute callback must never return null, unless an onUnknownRoute '\n              'callback is provided as well.',\n            ),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n      route = widget.onUnknownRoute!(settings) as Route<T?>?;\n      assert(() {\n        if (route == null) {\n          throw FlutterError.fromParts(<DiagnosticsNode>[\n            ErrorSummary(\n              'Navigator.onUnknownRoute returned null when requested to build route \"$name\".',\n            ),\n            ErrorDescription('The onUnknownRoute callback must never return null.'),\n            DiagnosticsProperty<NavigatorState>(\n              'The Navigator was',\n              this,\n              style: DiagnosticsTreeStyle.errorProperty,\n            ),\n          ]);\n        }\n        return true;\n      }());\n    }\n    assert(route != null || allowNull);\n    return route;\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _aaronBurrSir() {\n  ///   navigator.pushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamed], which pushes a route that can be restored\n  ///    during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    return push<T?>(_routeNamed<T>(routeName, arguments: arguments)!);\n  }\n\n  /// Push a named route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openDetails() {\n  ///   navigator.restorablePushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamed<T extends Object?>(String routeName, {Object? arguments}) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startBike() {\n  ///   navigator.pushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacementNamed], which pushes a replacement route that\n  ///  can be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    return pushReplacement<T?, TO>(\n      _routeNamed<T>(routeName, arguments: arguments)!,\n      result: result,\n    );\n  }\n\n  /// Replace the current route of the navigator by pushing the route named\n  /// [routeName] and then disposing the previous route once the new route has\n  /// finished animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacementNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _startCar() {\n  ///   navigator.restorablePushReplacementNamed('/jouett/1781');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacementNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: routeName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _begin() {\n  ///   navigator.popAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePopAndPushNamed], which pushes a new route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> popAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return pushNamed<T>(routeName, arguments: arguments);\n  }\n\n  /// Pop the current route off the navigator and push a named route in its\n  /// place.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePopAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.navigator.popAndPushNamed}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _end() {\n  ///   navigator.restorablePopAndPushNamed('/nyc/1776');\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePopAndPushNamed<T extends Object?, TO extends Object?>(\n    String routeName, {\n    TO? result,\n    Object? arguments,\n  }) {\n    pop<TO>(result);\n    return restorablePushNamed(routeName, arguments: arguments);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@macro flutter.widgets.Navigator.pushNamed}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _handleOpenCalendar() {\n  ///   navigator.pushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushNamedAndRemoveUntil], which pushes a new route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    return pushAndRemoveUntil<T?>(_routeNamed<T>(newRouteName, arguments: arguments)!, predicate);\n  }\n\n  /// Push the route with the given name onto the navigator, and then remove all\n  /// the previous routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamedAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.arguments}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openCalendar() {\n  ///   navigator.restorablePushNamedAndRemoveUntil('/calendar', ModalRoute.withName('/'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushNamedAndRemoveUntil<T extends Object?>(\n    String newRouteName,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.named(\n      name: newRouteName,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  /// Push the given route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _openPage() {\n  ///   navigator.push<void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyPage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePush], which pushes a route that can be restored during\n  ///    state restoration.\n  @optionalTypeArgs\n  Future<T?> push<T extends Object?>(Route<T> route) {\n    _pushEntry(_RouteEntry(route, pageBased: false, initialState: _RouteLifecycle.push));\n    return route.popped;\n  }\n\n  bool _debugIsStaticCallback(Function callback) {\n    bool result = false;\n    assert(() {\n      // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n      result = kIsWeb || ui.PluginUtilities.getCallbackHandle(callback) != null;\n      return true;\n    }());\n    return result;\n  }\n\n  /// Push a new route onto the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.navigator.push}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePush<T extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntry(entry);\n    return entry.restorationId!;\n  }\n\n  void _pushEntry(_RouteEntry entry) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.currentState == _RouteLifecycle.push);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  void _afterNavigation(Route<dynamic>? route) {\n    if (!kReleaseMode) {\n      // Among other uses, performance tools use this event to ensure that perf\n      // stats reflect the time interval since the last navigation event\n      // occurred, ensuring that stats only reflect the current page.\n\n      Map<String, dynamic>? routeJsonable;\n      if (route != null) {\n        routeJsonable = <String, dynamic>{};\n\n        final String description;\n        if (route is TransitionRoute<dynamic>) {\n          final TransitionRoute<dynamic> transitionRoute = route;\n          description = transitionRoute.debugLabel;\n        } else {\n          description = '$route';\n        }\n        routeJsonable['description'] = description;\n\n        final RouteSettings settings = route.settings;\n        final Map<String, dynamic> settingsJsonable = <String, dynamic>{'name': settings.name};\n        if (settings.arguments != null) {\n          settingsJsonable['arguments'] = jsonEncode(\n            settings.arguments,\n            toEncodable: (Object? object) => '$object',\n          );\n        }\n        routeJsonable['settings'] = settingsJsonable;\n      }\n\n      developer.postEvent('Flutter.Navigation', <String, dynamic>{'route': routeJsonable});\n    }\n    _cancelActivePointers();\n  }\n\n  /// Replace the current route of the navigator by pushing the given route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doOpenPage() {\n  ///   navigator.pushReplacement<void, void>(\n  ///     MaterialPageRoute<void>(\n  ///       builder: (BuildContext context) => const MyHomePage(),\n  ///     ),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushReplacement], which pushes a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushReplacement<T extends Object?, TO extends Object?>(\n    Route<T> newRoute, {\n    TO? result,\n  }) {\n    assert(newRoute._navigator == null);\n    _pushReplacementEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.pushReplace),\n      result,\n    );\n    return newRoute.popped;\n  }\n\n  /// Replace the current route of the navigator by pushing a new route and\n  /// then disposing the previous route once the new route has finished\n  /// animating in.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushReplacement}\n  ///\n  /// {@macro flutter.widgets.navigator.pushReplacement}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_replacement.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushReplacement<T extends Object?, TO extends Object?>(\n    RestorableRouteBuilder<T> routeBuilder, {\n    TO? result,\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(routeBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: routeBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.pushReplace);\n    _pushReplacementEntry(entry, result);\n    return entry.restorationId!;\n  }\n\n  void _pushReplacementEntry<TO extends Object?>(_RouteEntry entry, TO? result) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(_history.isNotEmpty);\n    assert(\n      _history.any(_RouteEntry.isPresentPredicate),\n      'Navigator has no active routes to replace.',\n    );\n    assert(entry.currentState == _RouteLifecycle.pushReplace);\n    _history.lastWhere(_RouteEntry.isPresentPredicate).complete(result, isReplaced: true);\n    _history.add(entry);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Push the given route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushNamed.returnValue}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _resetAndOpenPage() {\n  ///   navigator.pushAndRemoveUntil<void>(\n  ///     MaterialPageRoute<void>(builder: (BuildContext context) => const MyHomePage()),\n  ///     ModalRoute.withName('/'),\n  ///   );\n  /// }\n  /// ```\n  /// {@end-tool}\n  ///\n  ///\n  /// See also:\n  ///\n  ///  * [restorablePushAndRemoveUntil], which pushes a route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  Future<T?> pushAndRemoveUntil<T extends Object?>(Route<T> newRoute, RoutePredicate predicate) {\n    assert(newRoute._navigator == null);\n    assert(newRoute.overlayEntries.isEmpty);\n    _pushEntryAndRemoveUntil(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.push),\n      predicate,\n    );\n    return newRoute.popped;\n  }\n\n  /// Push a new route onto the navigator, and then remove all the previous\n  /// routes until the `predicate` returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.restorablePushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.navigator.pushAndRemoveUntil}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  ///\n  /// {@tool dartpad}\n  /// Typical usage is as follows:\n  ///\n  /// ** See code in examples/api/lib/widgets/navigator/navigator_state.restorable_push_and_remove_until.0.dart **\n  /// {@end-tool}\n  @optionalTypeArgs\n  String restorablePushAndRemoveUntil<T extends Object?>(\n    RestorableRouteBuilder<T> newRouteBuilder,\n    RoutePredicate predicate, {\n    Object? arguments,\n  }) {\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.push);\n    _pushEntryAndRemoveUntil(entry, predicate);\n    return entry.restorationId!;\n  }\n\n  void _pushEntryAndRemoveUntil(_RouteEntry entry, RoutePredicate predicate) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.route._navigator == null);\n    assert(entry.route.overlayEntries.isEmpty);\n    assert(entry.currentState == _RouteLifecycle.push);\n    int index = _history.length - 1;\n    _history.add(entry);\n    while (index >= 0 && !predicate(_history[index].route)) {\n      if (_history[index].isPresent) {\n        _history[index].remove();\n      }\n      index -= 1;\n    }\n    _flushHistoryUpdates();\n\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// See also:\n  ///\n  ///  * [replaceRouteBelow], which is the same but identifies the route to be\n  ///    removed by reference to the route above it, rather than directly.\n  ///  * [restorableReplace], which adds a replacement route that can be\n  ///    restored during state restoration.\n  @optionalTypeArgs\n  void replace<T extends Object?>({required Route<dynamic> oldRoute, required Route<T> newRoute}) {\n    assert(!_debugLocked);\n    assert(oldRoute._navigator == this);\n    _replaceEntry(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      oldRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplace}\n  ///\n  /// {@macro flutter.widgets.navigator.replace}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplace<T extends Object?>({\n    required Route<dynamic> oldRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(oldRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntry(entry, oldRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntry(_RouteEntry entry, Route<dynamic> oldRoute) {\n    assert(!_debugLocked);\n    if (oldRoute == entry.route) {\n      return;\n    }\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(entry.currentState == _RouteLifecycle.replace);\n    assert(entry.route._navigator == null);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(oldRoute));\n    assert(index >= 0, 'This Navigator does not contain the specified oldRoute.');\n    assert(\n      _history[index].isPresent,\n      'The specified oldRoute has already been removed from the Navigator.',\n    );\n    final bool wasCurrent = oldRoute.isCurrent;\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(entry.route);\n    }\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// See also:\n  ///\n  ///  * [replace], which is the same but identifies the route to be removed\n  ///    directly.\n  ///  * [restorableReplaceRouteBelow], which adds a replacement route that can\n  ///    be restored during state restoration.\n  @optionalTypeArgs\n  void replaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required Route<T> newRoute,\n  }) {\n    assert(newRoute._navigator == null);\n    assert(anchorRoute._navigator == this);\n    _replaceEntryBelow(\n      _RouteEntry(newRoute, pageBased: false, initialState: _RouteLifecycle.replace),\n      anchorRoute,\n    );\n  }\n\n  /// Replaces a route on the navigator with a new route. The route to be\n  /// replaced is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.restorableReplaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.navigator.replaceRouteBelow}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePush}\n  ///\n  /// {@macro flutter.widgets.Navigator.restorablePushNamed.returnValue}\n  @optionalTypeArgs\n  String restorableReplaceRouteBelow<T extends Object?>({\n    required Route<dynamic> anchorRoute,\n    required RestorableRouteBuilder<T> newRouteBuilder,\n    Object? arguments,\n  }) {\n    assert(anchorRoute._navigator == this);\n    assert(\n      _debugIsStaticCallback(newRouteBuilder),\n      'The provided routeBuilder must be a static function.',\n    );\n    assert(\n      debugIsSerializableForRestoration(arguments),\n      'The arguments object must be serializable via the StandardMessageCodec.',\n    );\n    final _RouteEntry entry = _RestorationInformation.anonymous(\n      routeBuilder: newRouteBuilder,\n      arguments: arguments,\n      restorationScopeId: _nextPagelessRestorationScopeId,\n    ).toRouteEntry(this, initialState: _RouteLifecycle.replace);\n    _replaceEntryBelow(entry, anchorRoute);\n    return entry.restorationId!;\n  }\n\n  void _replaceEntryBelow(_RouteEntry entry, Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history.insert(index + 1, entry);\n    _history[index].remove(isReplaced: true);\n    _flushHistoryUpdates();\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Whether the navigator can be popped.\n  ///\n  /// {@macro flutter.widgets.navigator.canPop}\n  ///\n  /// See also:\n  ///\n  ///  * [Route.isFirst], which returns true for routes for which [canPop]\n  ///    returns false.\n  bool canPop() {\n    final Iterator<_RouteEntry> iterator = _history.where(_RouteEntry.isPresentPredicate).iterator;\n    if (!iterator.moveNext()) {\n      // We have no active routes, so we can't pop.\n      return false;\n    }\n    if (iterator.current.route.willHandlePopInternally) {\n      // The first route can handle pops itself, so we can pop.\n      return true;\n    }\n    if (!iterator.moveNext()) {\n      // There's only one route, so we can't pop.\n      return false;\n    }\n    return true; // there's at least two routes, so we can pop\n  }\n\n  /// Consults the current route's [Route.popDisposition] method, and acts\n  /// accordingly, potentially popping the route as a result; returns whether\n  /// the pop request should be considered handled.\n  ///\n  /// {@macro flutter.widgets.navigator.maybePop}\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides a [Form.canPop] boolean that enables the\n  ///    form to prevent any [pop]s initiated by the app's back button.\n  ///  * [ModalRoute], which provides a `scopedOnPopCallback` that can be used\n  ///    to define the route's `willPop` method.\n  @optionalTypeArgs\n  Future<bool> maybePop<T extends Object?>([T? result]) async {\n    final _RouteEntry? lastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry == null) {\n      return false;\n    }\n    assert(lastEntry.route._navigator == this);\n\n    // TODO(justinmc): When the deprecated willPop method is removed, delete\n    // this code and use only popDisposition, below.\n    if (await lastEntry.route.willPop() == RoutePopDisposition.doNotPop) {\n      return true;\n    }\n    if (!mounted) {\n      // Forget about this pop, we were disposed in the meantime.\n      return true;\n    }\n\n    final _RouteEntry? newLastEntry = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    if (lastEntry != newLastEntry) {\n      // Forget about this pop, something happened to our history in the meantime.\n      return true;\n    }\n\n    switch (lastEntry.route.popDisposition) {\n      case RoutePopDisposition.bubble:\n        return false;\n      case RoutePopDisposition.pop:\n        pop(result);\n        return true;\n      case RoutePopDisposition.doNotPop:\n        lastEntry.route.onPopInvokedWithResult(false, result);\n        return true;\n    }\n  }\n\n  /// Pop the top-most route off the navigator.\n  ///\n  /// {@macro flutter.widgets.navigator.pop}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage for closing a route is as follows:\n  ///\n  /// ```dart\n  /// void _handleClose() {\n  ///   navigator.pop();\n  /// }\n  /// ```\n  /// {@end-tool}\n  /// {@tool snippet}\n  ///\n  /// A dialog box might be closed with a result:\n  ///\n  /// ```dart\n  /// void _handleAccept() {\n  ///   navigator.pop(true); // dialog returns true\n  /// }\n  /// ```\n  /// {@end-tool}\n  @optionalTypeArgs\n  void pop<T extends Object?>([T? result]) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    final _RouteEntry entry = _history.lastWhere(_RouteEntry.isPresentPredicate);\n    if (entry.pageBased && widget.onPopPage != null) {\n      if (widget.onPopPage!(entry.route, result) &&\n          entry.currentState.index <= _RouteLifecycle.idle.index) {\n        // The entry may have been disposed if the pop finishes synchronously.\n        assert(entry.route._popCompleter.isCompleted);\n        entry.currentState = _RouteLifecycle.pop;\n      }\n      entry.route.onPopInvokedWithResult(true, result);\n    } else {\n      entry.pop<T>(result);\n      assert(entry.currentState == _RouteLifecycle.pop);\n    }\n    if (entry.currentState == _RouteLifecycle.pop) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n    assert(entry.currentState == _RouteLifecycle.idle || entry.route._popCompleter.isCompleted);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    _afterNavigation(entry.route);\n  }\n\n  /// Calls [pop] repeatedly until the predicate returns true.\n  ///\n  /// {@macro flutter.widgets.navigator.popUntil}\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// void _doLogout() {\n  ///   navigator.popUntil(ModalRoute.withName('/login'));\n  /// }\n  /// ```\n  /// {@end-tool}\n  void popUntil(RoutePredicate predicate) {\n    _RouteEntry? candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    while (candidate != null) {\n      if (predicate(candidate.route)) {\n        return;\n      }\n      pop();\n      candidate = _lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate);\n    }\n  }\n\n  /// Immediately remove `route` from the navigator, and [Route.dispose] it.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRoute}\n  void removeRoute(Route<dynamic> route) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(route._navigator == this);\n    final bool wasCurrent = route.isCurrent;\n    final _RouteEntry entry = _history.firstWhere(_RouteEntry.isRoutePredicate(route));\n    entry.remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n    if (wasCurrent) {\n      _afterNavigation(_lastRouteEntryWhereOrNull(_RouteEntry.isPresentPredicate)?.route);\n    }\n  }\n\n  /// Immediately remove a route from the navigator, and [Route.dispose] it. The\n  /// route to be removed is the one below the given `anchorRoute`.\n  ///\n  /// {@macro flutter.widgets.navigator.removeRouteBelow}\n  void removeRouteBelow(Route<dynamic> anchorRoute) {\n    assert(!_debugLocked);\n    assert(() {\n      _debugLocked = true;\n      return true;\n    }());\n    assert(anchorRoute._navigator == this);\n    final int anchorIndex = _history.indexWhere(_RouteEntry.isRoutePredicate(anchorRoute));\n    assert(anchorIndex >= 0, 'This Navigator does not contain the specified anchorRoute.');\n    assert(\n      _history[anchorIndex].isPresent,\n      'The specified anchorRoute has already been removed from the Navigator.',\n    );\n    int index = anchorIndex - 1;\n    while (index >= 0) {\n      if (_history[index].isPresent) {\n        break;\n      }\n      index -= 1;\n    }\n    assert(index >= 0, 'There are no routes below the specified anchorRoute.');\n    _history[index].remove();\n    _flushHistoryUpdates(rearrangeOverlay: false);\n    assert(() {\n      _debugLocked = false;\n      return true;\n    }());\n  }\n\n  /// Complete the lifecycle for a route that has been popped off the navigator.\n  ///\n  /// When the navigator pops a route, the navigator retains a reference to the\n  /// route in order to call [Route.dispose] if the navigator itself is removed\n  /// from the tree. When the route is finished with any exit animation, the\n  /// route should call this function to complete its lifecycle (e.g., to\n  /// receive a call to [Route.dispose]).\n  ///\n  /// The given `route` must have already received a call to [Route.didPop].\n  /// This function may be called directly from [Route.didPop] if [Route.didPop]\n  /// will return true.\n  void finalizeRoute(Route<dynamic> route) {\n    // FinalizeRoute may have been called while we were already locked as a\n    // responds to route.didPop(). Make sure to leave in the state we were in\n    // before the call.\n    bool? wasDebugLocked;\n    assert(() {\n      wasDebugLocked = _debugLocked;\n      _debugLocked = true;\n      return true;\n    }());\n    assert(_history.where(_RouteEntry.isRoutePredicate(route)).length == 1);\n    final int index = _history.indexWhere(_RouteEntry.isRoutePredicate(route));\n    final _RouteEntry entry = _history[index];\n    // For page-based route with zero transition, the finalizeRoute can be\n    // called on any life cycle above pop.\n    if (entry.pageBased && entry.currentState.index < _RouteLifecycle.pop.index) {\n      _observedRouteDeletions.add(\n        _NavigatorPopObservation(\n          route,\n          _getRouteBefore(index - 1, _RouteEntry.willBePresentPredicate)?.route,\n        ),\n      );\n    } else {\n      assert(entry.currentState == _RouteLifecycle.popping);\n    }\n    entry.finalize();\n    // finalizeRoute can be called during _flushHistoryUpdates if a pop\n    // finishes synchronously.\n    if (!_flushingHistory) {\n      _flushHistoryUpdates(rearrangeOverlay: false);\n    }\n\n    assert(() {\n      _debugLocked = wasDebugLocked!;\n      return true;\n    }());\n  }\n\n  @optionalTypeArgs\n  Route<T>? _getRouteById<T>(String id) {\n    return _firstRouteEntryWhereOrNull((_RouteEntry entry) => entry.restorationId == id)?.route\n        as Route<T>?;\n  }\n\n  int get _userGesturesInProgress => _userGesturesInProgressCount;\n  int _userGesturesInProgressCount = 0;\n  set _userGesturesInProgress(int value) {\n    _userGesturesInProgressCount = value;\n    userGestureInProgressNotifier.value = _userGesturesInProgress > 0;\n  }\n\n  /// Whether a route is currently being manipulated by the user, e.g.\n  /// as during an iOS back gesture.\n  ///\n  /// See also:\n  ///\n  ///  * [userGestureInProgressNotifier], which notifies its listeners if\n  ///    the value of [userGestureInProgress] changes.\n  bool get userGestureInProgress => userGestureInProgressNotifier.value;\n\n  /// Notifies its listeners if the value of [userGestureInProgress] changes.\n  final ValueNotifier<bool> userGestureInProgressNotifier = ValueNotifier<bool>(false);\n\n  /// The navigator is being controlled by a user gesture.\n  ///\n  /// For example, called when the user beings an iOS back gesture.\n  ///\n  /// When the gesture finishes, call [didStopUserGesture].\n  void didStartUserGesture() {\n    _userGesturesInProgress += 1;\n    if (_userGesturesInProgress == 1) {\n      final int routeIndex = _getIndexBefore(\n        _history.length - 1,\n        _RouteEntry.willBePresentPredicate,\n      );\n      final Route<dynamic> route = _history[routeIndex].route;\n      Route<dynamic>? previousRoute;\n      if (!route.willHandlePopInternally && routeIndex > 0) {\n        previousRoute = _getRouteBefore(routeIndex - 1, _RouteEntry.willBePresentPredicate)!.route;\n      }\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStartUserGesture(route, previousRoute);\n      }\n    }\n  }\n\n  /// A user gesture completed.\n  ///\n  /// Notifies the navigator that a gesture regarding which the navigator was\n  /// previously notified with [didStartUserGesture] has completed.\n  void didStopUserGesture() {\n    assert(_userGesturesInProgress > 0);\n    _userGesturesInProgress -= 1;\n    if (_userGesturesInProgress == 0) {\n      for (final NavigatorObserver observer in _effectiveObservers) {\n        observer.didStopUserGesture();\n      }\n    }\n  }\n\n  final Set<int> _activePointers = <int>{};\n\n  void _handlePointerDown(PointerDownEvent event) {\n    _activePointers.add(event.pointer);\n  }\n\n  void _handlePointerUpOrCancel(PointerEvent event) {\n    _activePointers.remove(event.pointer);\n  }\n\n  void _cancelActivePointers() {\n    // TODO(abarth): This mechanism is far from perfect. See https://github.com/flutter/flutter/issues/4770\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.idle) {\n      // If we're between frames (SchedulerPhase.idle) then absorb any\n      // subsequent pointers from this frame. The absorbing flag will be\n      // reset in the next frame, see build().\n      final RenderAbsorbPointer? absorber =\n          _overlayKey.currentContext?.findAncestorRenderObjectOfType<RenderAbsorbPointer>();\n      setState(() {\n        absorber?.absorbing = true;\n        // We do this in setState so that we'll reset the absorbing value back\n        // to false on the next frame.\n      });\n    }\n    _activePointers.toList().forEach(WidgetsBinding.instance.cancelPointer);\n  }\n\n  /// Gets first route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _firstRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        return element;\n      }\n    }\n    return null;\n  }\n\n  /// Gets last route entry satisfying the predicate, or null if not found.\n  _RouteEntry? _lastRouteEntryWhereOrNull(_RouteEntryPredicate test) {\n    _RouteEntry? result;\n    for (final _RouteEntry element in _history) {\n      if (test(element)) {\n        result = element;\n      }\n    }\n    return result;\n  }\n\n  @protected\n  @override\n  Widget build(BuildContext context) {\n    assert(!_debugLocked);\n    assert(_history.isNotEmpty);\n\n    // Hides the HeroControllerScope for the widget subtree so that the other\n    // nested navigator underneath will not pick up the hero controller above\n    // this level.\n    return HeroControllerScope.none(\n      child: NotificationListener<NavigationNotification>(\n        onNotification: (NavigationNotification notification) {\n          // If the state of this Navigator does not change whether or not the\n          // whole framework can pop, propagate the Notification as-is.\n          if (notification.canHandlePop || !canPop()) {\n            return false;\n          }\n          // Otherwise, dispatch a new Notification with the correct canPop and\n          // stop the propagation of the old Notification.\n          const NavigationNotification nextNotification = NavigationNotification(\n            canHandlePop: true,\n          );\n          nextNotification.dispatch(context);\n          return true;\n        },\n        child: Listener(\n          onPointerDown: _handlePointerDown,\n          onPointerUp: _handlePointerUpOrCancel,\n          onPointerCancel: _handlePointerUpOrCancel,\n          child: AbsorbPointer(\n            absorbing: false, // it's mutated directly by _cancelActivePointers above\n            child: FocusTraversalGroup(\n              policy: FocusTraversalGroup.maybeOf(context),\n              child: Focus(\n                focusNode: focusNode,\n                autofocus: true,\n                skipTraversal: true,\n                includeSemantics: false,\n                child: UnmanagedRestorationScope(\n                  bucket: bucket,\n                  child: Overlay(\n                    key: _overlayKey,\n                    clipBehavior: widget.clipBehavior,\n                    initialEntries:\n                        overlay == null\n                            ? _allRouteOverlayEntries.toList(growable: false)\n                            : const <OverlayEntry>[],\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nenum _RouteRestorationType { named, anonymous }\n\nabstract class _RestorationInformation {\n  _RestorationInformation(this.type);\n  factory _RestorationInformation.named({\n    required String name,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _NamedRestorationInformation;\n  factory _RestorationInformation.anonymous({\n    required RestorableRouteBuilder<Object?> routeBuilder,\n    required Object? arguments,\n    required int restorationScopeId,\n  }) = _AnonymousRestorationInformation;\n\n  factory _RestorationInformation.fromSerializableData(Object data) {\n    final List<Object?> casted = data as List<Object?>;\n    assert(casted.isNotEmpty);\n    final _RouteRestorationType type = _RouteRestorationType.values[casted[0]! as int];\n    switch (type) {\n      case _RouteRestorationType.named:\n        return _NamedRestorationInformation.fromSerializableData(casted.sublist(1));\n      case _RouteRestorationType.anonymous:\n        return _AnonymousRestorationInformation.fromSerializableData(casted.sublist(1));\n    }\n  }\n\n  final _RouteRestorationType type;\n  int get restorationScopeId;\n  Object? _serializableData;\n\n  bool get isRestorable => true;\n\n  Object getSerializableData() {\n    _serializableData ??= computeSerializableData();\n    return _serializableData!;\n  }\n\n  @mustCallSuper\n  List<Object> computeSerializableData() {\n    return <Object>[type.index];\n  }\n\n  @protected\n  Route<dynamic> createRoute(NavigatorState navigator);\n\n  _RouteEntry toRouteEntry(\n    NavigatorState navigator, {\n    _RouteLifecycle initialState = _RouteLifecycle.add,\n  }) {\n    final Route<Object?> route = createRoute(navigator);\n    return _RouteEntry(\n      route,\n      pageBased: false,\n      initialState: initialState,\n      restorationInformation: this,\n    );\n  }\n}\n\nclass _NamedRestorationInformation extends _RestorationInformation {\n  _NamedRestorationInformation({\n    required this.name,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.named);\n\n  _NamedRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      name = data[1]! as String,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.named);\n\n  @override\n  List<Object> computeSerializableData() {\n    return super.computeSerializableData()\n      ..addAll(<Object>[restorationScopeId, name, if (arguments != null) arguments!]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final String name;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> route = navigator._routeNamed<dynamic>(name, arguments: arguments)!;\n    return route;\n  }\n}\n\nclass _AnonymousRestorationInformation extends _RestorationInformation {\n  _AnonymousRestorationInformation({\n    required this.routeBuilder,\n    required this.arguments,\n    required this.restorationScopeId,\n  }) : super(_RouteRestorationType.anonymous);\n\n  _AnonymousRestorationInformation.fromSerializableData(List<Object?> data)\n    : assert(data.length > 1),\n      restorationScopeId = data[0]! as int,\n      routeBuilder =\n          ui.PluginUtilities.getCallbackFromHandle(\n                ui.CallbackHandle.fromRawHandle(data[1]! as int),\n              )!\n              as RestorableRouteBuilder,\n      arguments = data.elementAtOrNull(2),\n      super(_RouteRestorationType.anonymous);\n\n  @override\n  // TODO(goderbauer): remove the kIsWeb check when https://github.com/flutter/flutter/issues/33615 is resolved.\n  bool get isRestorable => !kIsWeb;\n\n  @override\n  List<Object> computeSerializableData() {\n    assert(isRestorable);\n    final ui.CallbackHandle? handle = ui.PluginUtilities.getCallbackHandle(routeBuilder);\n    assert(handle != null);\n    return super.computeSerializableData()..addAll(<Object>[\n      restorationScopeId,\n      handle!.toRawHandle(),\n      if (arguments != null) arguments!,\n    ]);\n  }\n\n  @override\n  final int restorationScopeId;\n  final RestorableRouteBuilder<Object?> routeBuilder;\n  final Object? arguments;\n\n  @override\n  Route<dynamic> createRoute(NavigatorState navigator) {\n    final Route<dynamic> result = routeBuilder(navigator.context, arguments);\n    return result;\n  }\n}\n\nclass _HistoryProperty extends RestorableProperty<Map<String?, List<Object>>?> {\n  // Routes not associated with a page are stored under key 'null'.\n  Map<String?, List<Object>>? _pageToPagelessRoutes;\n\n  // Updating.\n\n  void update(_History history) {\n    assert(isRegistered);\n    final bool wasUninitialized = _pageToPagelessRoutes == null;\n    bool needsSerialization = wasUninitialized;\n    _pageToPagelessRoutes ??= <String, List<Object>>{};\n    _RouteEntry? currentPage;\n    List<Object> newRoutesForCurrentPage = <Object>[];\n    List<Object> oldRoutesForCurrentPage = _pageToPagelessRoutes![null] ?? const <Object>[];\n    bool restorationEnabled = true;\n\n    final Map<String?, List<Object>> newMap = <String?, List<Object>>{};\n    final Set<String?> removedPages = _pageToPagelessRoutes!.keys.toSet();\n\n    for (final _RouteEntry entry in history) {\n      if (!entry.isPresentForRestoration) {\n        entry.restorationEnabled = false;\n        continue;\n      }\n\n      assert(entry.isPresentForRestoration);\n      if (entry.pageBased) {\n        needsSerialization =\n            needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n        _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n        currentPage = entry;\n        restorationEnabled = entry.restorationId != null;\n        entry.restorationEnabled = restorationEnabled;\n        if (restorationEnabled) {\n          assert(entry.restorationId != null);\n          newRoutesForCurrentPage = <Object>[];\n          oldRoutesForCurrentPage = _pageToPagelessRoutes![entry.restorationId] ?? const <Object>[];\n        } else {\n          newRoutesForCurrentPage = const <Object>[];\n          oldRoutesForCurrentPage = const <Object>[];\n        }\n        continue;\n      }\n\n      assert(!entry.pageBased);\n      restorationEnabled =\n          restorationEnabled && (entry.restorationInformation?.isRestorable ?? false);\n      entry.restorationEnabled = restorationEnabled;\n      if (restorationEnabled) {\n        assert(entry.restorationId != null);\n        assert(currentPage == null || currentPage.restorationId != null);\n        assert(entry.restorationInformation != null);\n        final Object serializedData = entry.restorationInformation!.getSerializableData();\n        needsSerialization =\n            needsSerialization ||\n            oldRoutesForCurrentPage.length <= newRoutesForCurrentPage.length ||\n            oldRoutesForCurrentPage[newRoutesForCurrentPage.length] != serializedData;\n        newRoutesForCurrentPage.add(serializedData);\n      }\n    }\n    needsSerialization =\n        needsSerialization || newRoutesForCurrentPage.length != oldRoutesForCurrentPage.length;\n    _finalizeEntry(newRoutesForCurrentPage, currentPage, newMap, removedPages);\n\n    needsSerialization = needsSerialization || removedPages.isNotEmpty;\n\n    assert(\n      wasUninitialized || _debugMapsEqual(_pageToPagelessRoutes!, newMap) != needsSerialization,\n    );\n\n    if (needsSerialization) {\n      _pageToPagelessRoutes = newMap;\n      notifyListeners();\n    }\n  }\n\n  void _finalizeEntry(\n    List<Object> routes,\n    _RouteEntry? page,\n    Map<String?, List<Object>> pageToRoutes,\n    Set<String?> pagesToRemove,\n  ) {\n    assert(page == null || page.pageBased);\n    assert(!pageToRoutes.containsKey(page?.restorationId));\n    if (routes.isNotEmpty) {\n      assert(page == null || page.restorationId != null);\n      final String? restorationId = page?.restorationId;\n      pageToRoutes[restorationId] = routes;\n      pagesToRemove.remove(restorationId);\n    }\n  }\n\n  bool _debugMapsEqual(Map<String?, List<Object>> a, Map<String?, List<Object>> b) {\n    if (!setEquals(a.keys.toSet(), b.keys.toSet())) {\n      return false;\n    }\n    for (final String? key in a.keys) {\n      if (!listEquals(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void clear() {\n    assert(isRegistered);\n    if (_pageToPagelessRoutes == null) {\n      return;\n    }\n    _pageToPagelessRoutes = null;\n    notifyListeners();\n  }\n\n  // Restoration.\n\n  bool get hasData => _pageToPagelessRoutes != null;\n\n  List<_RouteEntry> restoreEntriesForPage(_RouteEntry? page, NavigatorState navigator) {\n    assert(isRegistered);\n    assert(page == null || page.pageBased);\n    final List<_RouteEntry> result = <_RouteEntry>[];\n    if (_pageToPagelessRoutes == null || (page != null && page.restorationId == null)) {\n      return result;\n    }\n    final List<Object>? serializedData = _pageToPagelessRoutes![page?.restorationId];\n    if (serializedData == null) {\n      return result;\n    }\n    for (final Object data in serializedData) {\n      result.add(_RestorationInformation.fromSerializableData(data).toRouteEntry(navigator));\n    }\n    return result;\n  }\n\n  // RestorableProperty overrides.\n\n  @override\n  Map<String?, List<Object>>? createDefaultValue() {\n    return null;\n  }\n\n  @override\n  Map<String?, List<Object>>? fromPrimitives(Object? data) {\n    final Map<dynamic, dynamic> casted = data! as Map<dynamic, dynamic>;\n    return casted.map<String?, List<Object>>(\n      (dynamic key, dynamic value) => MapEntry<String?, List<Object>>(\n        key as String?,\n        List<Object>.from(value as List<dynamic>),\n      ),\n    );\n  }\n\n  @override\n  void initWithValue(Map<String?, List<Object>>? value) {\n    _pageToPagelessRoutes = value;\n  }\n\n  @override\n  Object? toPrimitives() {\n    return _pageToPagelessRoutes;\n  }\n\n  @override\n  bool get enabled => hasData;\n}\n\n/// A callback that given a [BuildContext] finds a [NavigatorState].\n///\n/// Used by [RestorableRouteFuture.navigatorFinder] to determine the navigator\n/// to which a new route should be added.\ntypedef NavigatorFinderCallback = NavigatorState Function(BuildContext context);\n\n/// A callback that given some `arguments` and a `navigator` adds a new\n/// restorable route to that `navigator` and returns the opaque ID of that\n/// new route.\n///\n/// Usually, this callback calls one of the imperative methods on the Navigator\n/// that have \"restorable\" in the name and returns their return value.\n///\n/// Used by [RestorableRouteFuture.onPresent].\ntypedef RoutePresentationCallback = String Function(NavigatorState navigator, Object? arguments);\n\n/// A callback to handle the result of a completed [Route].\n///\n/// The return value of the route (which can be null for e.g. void routes) is\n/// passed to the callback.\n///\n/// Used by [RestorableRouteFuture.onComplete].\ntypedef RouteCompletionCallback<T> = void Function(T result);\n\n/// Gives access to a [Route] object and its return value that was added to a\n/// navigator via one of its \"restorable\" API methods.\n///\n/// When a [State] object wants access to the return value of a [Route] object\n/// it has pushed onto the [Navigator], a [RestorableRouteFuture] ensures that\n/// it will also have access to that value after state restoration.\n///\n/// To show a new route on the navigator defined by the [navigatorFinder], call\n/// [present], which will invoke the [onPresent] callback. The [onPresent]\n/// callback must add a new route to the navigator provided to it using one\n/// of the \"restorable\" API methods. When the newly added route completes, the\n/// [onComplete] callback executes. It is given the return value of the route,\n/// which may be null.\n///\n/// While the route added via [present] is shown on the navigator, it can be\n/// accessed via the [route] getter.\n///\n/// If the property is restored to a state in which [present] had been called on\n/// it, but the route has not completed yet, the [RestorableRouteFuture] will\n/// obtain the restored route object from the navigator again and call\n/// [onComplete] once it completes.\n///\n/// The [RestorableRouteFuture] can only keep track of one active [route].\n/// When [present] has been called to add a route, it may only be called again\n/// after the previously added route has completed.\n///\n/// {@tool dartpad}\n/// This example uses a [RestorableRouteFuture] in the `_MyHomeState` to push a\n/// new `MyCounter` route and to retrieve its return value.\n///\n/// ** See code in examples/api/lib/widgets/navigator/restorable_route_future.0.dart **\n/// {@end-tool}\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n  /// Creates a [RestorableRouteFuture].\n  RestorableRouteFuture({\n    this.navigatorFinder = _defaultNavigatorFinder,\n    required this.onPresent,\n    this.onComplete,\n  });\n\n  /// A callback that given the [BuildContext] of the [State] object to which\n  /// this property is registered returns the [NavigatorState] of the navigator\n  /// to which the route instantiated in [onPresent] is added.\n  final NavigatorFinderCallback navigatorFinder;\n\n  /// A callback that add a new [Route] to the provided navigator.\n  ///\n  /// The callback must use one of the API methods on the [NavigatorState] that\n  /// have \"restorable\" in their name (e.g. [NavigatorState.restorablePush],\n  /// [NavigatorState.restorablePushNamed], etc.) and return the opaque ID\n  /// returned by those methods.\n  ///\n  /// This callback is invoked when [present] is called with the `arguments`\n  /// Object that was passed to that method and the [NavigatorState] obtained\n  /// from [navigatorFinder].\n  final RoutePresentationCallback onPresent;\n\n  /// A callback that is invoked when the [Route] added via [onPresent]\n  /// completes.\n  ///\n  /// The return value of that route is passed to this method.\n  final RouteCompletionCallback<T>? onComplete;\n\n  /// Shows the route created by [onPresent] and invoke [onComplete] when it\n  /// completes.\n  ///\n  /// The `arguments` object is passed to [onPresent] and can be used to\n  /// customize the route. It must be serializable via the\n  /// [StandardMessageCodec]. Often, a [Map] is used to pass key-value pairs.\n  void present([Object? arguments]) {\n    assert(!isPresent);\n    assert(isRegistered);\n    final String routeId = onPresent(_navigator, arguments);\n    _hookOntoRouteFuture(routeId);\n    notifyListeners();\n  }\n\n  /// Whether the [Route] created by [present] is currently shown.\n  ///\n  /// Returns true after [present] has been called until the [Route] completes.\n  bool get isPresent => route != null;\n\n  /// The route that [present] added to the Navigator.\n  ///\n  /// Returns null when currently no route is shown\n  Route<T>? get route => _route;\n  Route<T>? _route;\n\n  @override\n  String? createDefaultValue() => null;\n\n  @override\n  void initWithValue(String? value) {\n    if (value != null) {\n      _hookOntoRouteFuture(value);\n    }\n  }\n\n  @override\n  Object? toPrimitives() {\n    assert(route != null);\n    assert(enabled);\n    return route?.restorationScopeId.value;\n  }\n\n  @override\n  String fromPrimitives(Object? data) {\n    assert(data != null);\n    return data! as String;\n  }\n\n  bool _disposed = false;\n\n  @override\n  void dispose() {\n    super.dispose();\n    _route?.restorationScopeId.removeListener(notifyListeners);\n    _disposed = true;\n  }\n\n  @override\n  bool get enabled => route?.restorationScopeId.value != null;\n\n  NavigatorState get _navigator {\n    final NavigatorState navigator = navigatorFinder(state.context);\n    return navigator;\n  }\n\n  void _hookOntoRouteFuture(String id) {\n    _route = _navigator._getRouteById<T>(id);\n    assert(_route != null);\n    route!.restorationScopeId.addListener(notifyListeners);\n    route!.popped.then((dynamic result) {\n      if (_disposed) {\n        return;\n      }\n      _route?.restorationScopeId.removeListener(notifyListeners);\n      _route = null;\n      notifyListeners();\n      onComplete?.call(result as T);\n    });\n  }\n\n  static NavigatorState _defaultNavigatorFinder(BuildContext context) => Navigator.of(context);\n}\n\n/// A notification that a change in navigation has taken place.\n///\n/// Specifically, this notification indicates that at least one of the following\n/// has occurred:\n///\n///  * That route stack of a [Navigator] has changed in any way.\n///  * The ability to pop has changed, such as controlled by [PopScope].\nclass NavigationNotification extends Notification {\n  /// Creates a notification that some change in navigation has happened.\n  const NavigationNotification({required this.canHandlePop});\n\n  /// Indicates that the originator of this [Notification] is capable of\n  /// handling a navigation pop.\n  final bool canHandlePop;\n\n  @override\n  String toString() {\n    return 'NavigationNotification canHandlePop: $canHandlePop';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 9: RestorableRouteFuture\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 9: RestorableRouteFuture\n\nWelcome to the final chapter of our Flutter navigation series! We've covered a lot, from the basics of the [Navigator](01_navigator_.md) and [Route](02_route_.md)s to more advanced topics like [Page](04_page_.md)s, [RoutePredicate](05_routepredicate_.md)s, and [TransitionDelegate](08_transitiondelegate_.md).\n\nToday, we'll look at a specialized helper class called **RestorableRouteFuture**. This abstraction is less about the core mechanics of navigation and more about enhancing your app's ability to *remember* where the user was and what they were doing if the app is interrupted and later restored by the operating system.\n\n## Why do we need RestorableRouteFuture?\n\nImagine your app is running, and the user navigates through a few screens. Then, they tap a button that opens a dialog (which is also a [Route](02_route_.md)). While that dialog is open, the operating system decides it needs to free up memory and closes your app in the background (this is common on mobile devices). Later, the user reopens your app, and the OS tries to restore it to the exact state it was in.\n\nBy default, the [Navigator](01_navigator_.md) can often restore the history stack (if configured to do so with `restorationScopeId` and, for Page-based navigation, `Page.restorationId`). However, if you pushed a route imperatively (using methods like `Navigator.push`) and then needed to get a *result* back from it (like a value selected in a dialog), simply restoring the route stack doesn't automatically provide you with the *original Future* that the `push` call returned. If you were awaiting that Future (`await Navigator.push(...)`) to process the result, your code might break after restoration if the screen is rebuilt without the original Future being available.\n\n**RestorableRouteFuture** is designed to solve this problem when you're using state restoration. It helps you maintain a connection to the route you pushed and get access to its return value even after the app is restored.\n\nThink of it like this:\n\nWhen you imperatively push a route that returns a value (like a dialog that returns the user's selection):\n\n```dart\n// Without RestorableRouteFuture, before restoration\nObject? result = await Navigator.push(context, MySelectionDialogRoute());\n// Do something with result\n```\n\nIf the app restarts and restores the dialog route, the screen that was originally calling this code is rebuilt. The `await Navigator.push` line was already \"completed\" (or interrupted) by the time of restoration. The screen needs a way to re-establish its connection to the dialog route and get its result when the dialog is eventually closed.\n\nThat's where **RestorableRouteFuture** comes in. It acts as a persistent \"handle\" to a route pushed imperatively using the *restorable* Navigator methods, ensuring you can still get the return value after state restoration.\n\n## Core Concept: The Persistent Handle\n\n`RestorableRouteFuture` doesn't push the route itself. Instead, it works together with the *restorable* methods on `NavigatorState`, specifically:\n\n*   `NavigatorState.restorablePush`\n*   `NavigatorState.restorablePushNamed`\n*   `NavigatorState.restorablePushReplacement`\n*   `NavigatorState.restorablePushReplacementNamed`\n*   `NavigatorState.restorablePopAndPushNamed`\n*   `NavigatorState.restorablePushAndRemoveUntil`\n*   `NavigatorState.restorablePushNamedAndRemoveUntil`\n*   `NavigatorState.restorableReplace`\n*   `NavigatorState.restorableReplaceRouteBelow`\n\nThese methods, unlike their non-restorable counterparts (`push`, `pushNamed`, etc.), return an opaque `String` ID instead of a `Future`. This ID is the key to state restoration. The [Navigator](01_navigator_.md) can use this ID to later find the corresponding route if it's restored.\n\nThis ID is what `RestorableRouteFuture` stores during state restoration.\n\nThe `RestorableRouteFuture` helps orchestrate this process:\n\n1.  You register a `RestorableRouteFuture` as part of your state object that needs to push a restorable route and receive its result.\n2.  When you want to push the route, you call `myRestorableRouteFuture.present(arguments)`.\n3.  Behind the scenes, `present` calls a callback (`onPresent`) that *you* provide. This `onPresent` callback is responsible for calling one of the `NavigatorState.restorable...` methods and returning the `String` ID it gives back.\n4.  `RestorableRouteFuture` stores this ID.\n5.  The restorable Navigator method pushes or manages the route and returns the ID.\n6.  If the app is interrupted and restored, the `RestorableRouteFuture` (being a restorable property) restores the stored ID.\n7.  When your widget (that owns the `RestorableRouteFuture`) is rebuilt, the `RestorableRouteFuture` uses the restored ID to find the corresponding route within the restored [Navigator](01_navigator_.md).\n8.  It then hooks onto that route's `popped` Future.\n9.  When the route eventually completes (e.g., the dialog is dismissed), the `RestorableRouteFuture`'s `onComplete` callback (which *you* provided) is triggered with the route's result.\n\n## Use Case: Pushing a Restorable Dialog and Getting a Result\n\nLet's walk through the core use case: showing a dialog that needs to return a value and ensuring this works correctly with state restoration.\n\nFirst, we need a simple dialog route that returns a value (e.g., a boolean). We'll use a simple `showDialog` for this, as `showDialog` internally creates a `DialogRoute`, which is restorable.\n\n```dart\n// A simple dialog that returns a boolean value\nFuture<bool?> showConfirmationDialog(BuildContext context) {\n  return showDialog<bool>( // showDialog returns a Future<T>\n    context: context,\n    builder: (BuildContext context) {\n      return AlertDialog(\n        title: const Text('Confirm?'),\n        actions: <Widget>[\n          TextButton(\n            child: const Text('Cancel'),\n            onPressed: () {\n              Navigator.pop(context, false); // Pop with result false\n            },\n          ),\n          TextButton(\n            child: const Text('OK'),\n            onPressed: () {\n              Navigator.pop(context, true); // Pop with result true\n            },\n          ),\n        ],\n      );\n    },\n  );\n}\n```\n\nNext, we need a widget that will push this dialog and process its result, and this widget needs to support state restoration itself. This requires extending `StatefulWidget` and using `RestorationMixin`. The state object will hold the `RestorableRouteFuture`.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'confirmation_dialog.dart'; // Contains showConfirmationDialog\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  State<MainScreen> createState() => _MainScreenState();\n}\n\n// Our state object with RestorationMixin\nclass _MainScreenState extends State<MainScreen> with RestorationMixin {\n  // Declare our RestorableRouteFuture property\n  // <bool?> indicates it's tracking a Future<bool?>\n  late final RestorableRouteFuture<bool?> _dialogRouteFuture;\n\n  String _lastDialogResult = 'No dialog shown yet.';\n\n  @override\n  String? get restorationId => 'mainScreen'; // Provide a restoration ID for the state\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    // Initialize the RestorableRouteFuture during state restoration\n    _dialogRouteFuture = RestorableRouteFuture<bool?>(\n      // navigatorFinder: (context) => Navigator.of(context), // Default, can be omitted\n      onPresent: (navigator, arguments) {\n        // This callback is called by _dialogRouteFuture.present()\n\n        // We call the restorable dialog function here\n        // If using a custom restorable route, you'd call\n        // navigator.restorablePush() or navigator.restorablePushNamed()\n\n        // showDialog internally uses a restorable DialogRoute, so we just call it\n        final Future<bool?> dialogFuture = showConfirmationDialog(context);\n\n        // We need to find the DialogRoute itself to get its restoration ID.\n        // This is a bit indirect because showDialog hides the route creation.\n        // A common pattern is to find the route by type or name after the push.\n        // Since showDialog adds a ModalRoute, we can try finding the top ModalRoute.\n        // NOTE: This might need adjustment for more complex scenarios with nested routes.\n        final ModalRoute<bool?>? pushedRoute = ModalRoute.of<bool?>(context);\n\n        // The restorable methods on NavigatorState return the ID directly.\n        // If showDialog didn't hide the route like this, onPresent\n        // would look more like this:\n        //\n        // final String id = navigator.restorablePush<bool?>(myStaticRouteBuilder, arguments: arguments);\n        // return id;\n\n        // For showDialog, we need its internal restoration ID IF it has one.\n        // DialogRoute is restorable and sets restorationId if Navigator allows.\n        final String? routeId = pushedRoute?.restorationScopeId.value;\n\n        if (routeId == null) {\n           // If restoration is not active or route is not restorable,\n           // we can't get an ID. Handle gracefully, maybe just link future directly.\n           // For this example, we'll assert or return empty ID if not getting one.\n           assert(false, 'DialogRoute is not restorable or Navigator is not configured for restoration.');\n           // If your route builder was truly static and used navigator.restorablePush,\n           // you would have the id here already.\n        }\n\n        // showDialog returns the future, but present expects the route ID.\n        // This highlights that RestorableRouteFuture is often best used\n        // with the *restorable* Navigator methods that return IDs.\n        // Since showDialog is convenient, and DialogRoute is restorable,\n        // we can cheat a bit if the route is findable and has an ID.\n\n        // Correct way with restorablePush if you had a static dialog route builder:\n        /*\n        @pragma('vm:entry-point')\n        static Route<bool?> _myConfirmationDialogRoute(BuildContext context, Object? arguments) {\n           return DialogRoute<bool?>(\n             context: context,\n             builder: (context) => AlertDialog(...),\n             settings: arguments as RouteSettings? // Example of using arguments\n           );\n        }\n        // Inside onPresent:\n        final String id = navigator.restorablePush<bool?>(_myConfirmationDialogRoute, arguments: null);\n        return id;\n        */\n\n        // Back to showDialog example - we need the ID from the route it made.\n        // This is less robust than using the restorable methods that return IDs.\n        // Let's assume for example purposes that showDialog ensures the route\n        // gets an ID if the Navigator is restorabe AND we can find it reliably.\n        // The ModalRoute.of(context) trick works best if the Navigator *just* pushed it.\n        if (pushedRoute != null && pushedRoute.restorationScopeId.value != null) {\n             return pushedRoute.restorationScopeId.value!;\n        }\n\n        // Fallback/Error if not getting an ID - the RestorableRouteFuture\n        // won't be able to reconnect after restoration in this case.\n        print('Warning: Could not get a restorable ID for the dialog route.');\n        return ''; // Indicate no restorable ID\n      },\n      onComplete: (bool? result) {\n        // This callback is called when the dialog is popped\n        setState(() {\n          _lastDialogResult = 'Dialog completed with: ${result ?? 'null'}';\n        });\n      },\n    );\n\n    // Register the RestorableRouteFuture property with the RestorationMixin\n    registerForRestoration(_dialogRouteFuture, 'dialog_future');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Restorable Dialog Example')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(_lastDialogResult),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              onPressed: () {\n                // Check if the dialog is already on screen (restored or newly pushed)\n                if (!_dialogRouteFuture.isPresent) {\n                   // Push the restorable dialog using the RestorableRouteFuture\n                   _dialogRouteFuture.present(); // Optionally pass arguments here\n                } else {\n                   print('Dialog is already present.');\n                }\n              },\n              child: const Text('Show Restorable Dialog'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\nTo make this runnable and test restoration, wrap your `MainScreen` in a `MaterialApp` or `WidgetsApp` that has `useInheritedMediaQuery: true` (for dialogs) and sets a `restorationScopeId`.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'main_screen.dart'; // Contains MainScreen\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      restorationScopeId: 'app', // Important: Enable restoration for the app\n      useInheritedMediaQuery: true, // Usually needed for dialogs\n      home: const MainScreen(),\n    );\n  }\n}\n```\n\nTo test state restoration:\n\n1.  Run the app.\n2.  Tap the \"Show Restorable Dialog\" button.\n3.  From the dialog, either tap OK/Cancel OR send the app to the background (e.g., Home button on Android, swipe up on iOS) and wait for the system to potentially kill the app process.\n4.  (On Android, typically use \"Don't keep activities\" developer option for reliable process killing).\n5.  Reopen the app using the multitasking switcher.\n6.  If restoration occurred, the dialog should reappear. Dismiss it using OK/Cancel.\n7.  The text now showing `_lastDialogResult` should update based on the selected value.\n\nIf you had used `await Navigator.push(context, ...)` directly without `RestorableRouteFuture`, and the app process was killed while the dialog was open, when the app is restored and the `MainScreen` is rebuilt, there would be no active Future to `await`, and your `onComplete` logic might never run correctly. `RestorableRouteFuture` bridges this gap by finding the restored route and re-attaching the completion logic.\n\n## RestorableRouteFuture Under the Hood (Simplified)\n\n`RestorableRouteFuture<T>` is a subclass of `RestorableProperty<String?>`. This means it's designed to be registered with a `RestorationMixin` and it saves/restores a nullable `String`. This `String` is the opaque ID returned by the `NavigatorState.restorable...` methods.\n\n```dart\n// Simplified structure\nclass RestorableRouteFuture<T> extends RestorableProperty<String?> {\n   final NavigatorFinderCallback navigatorFinder;\n   final RoutePresentationCallback onPresent;\n   final RouteCompletionCallback<T>? onComplete;\n\n   String? _restoredRouteId; // The ID saved/restored\n\n   Route<T>? _currentRoute; // The actual Route object found via the ID\n\n   // Called by RestorationMixin\n   @override\n   String? createDefaultValue() => null;\n\n   @override\n   void initWithValue(String? value) {\n       if (value != null) {\n          _restoredRouteId = value;\n          _hookOntoRouteFuture(_restoredRouteId!); // Try to find the route\n       }\n   }\n\n   @override\n   Object? toPrimitives() {\n       // Save the ID if the route is currently present and restorable\n       return _currentRoute?.restorationScopeId.value;\n   }\n\n   @override\n   String fromPrimitives(Object? data) {\n       // Restore the ID\n       return data! as String;\n   }\n\n   void present([Object? arguments]) {\n       assert(!isPresent); // Must not push if already tracking a route\n       assert(isRegistered); // Must be registered\n\n       final NavigatorState navigator = navigatorFinder(state.context);\n\n       // Calls the user-provided callback to push the route and get its ID\n       final String routeId = onPresent(navigator, arguments);\n\n       _hookOntoRouteFuture(routeId); // Store the ID and hook onto the future\n       notifyListeners(); // Notify the property has changed (saved the ID)\n   }\n\n   // Hook onto the route's popped future\n   void _hookOntoRouteFuture(String id) {\n       // Find the route in the navigator using the ID\n       _currentRoute = _navigator._getRouteById<T>(id);\n       assert(_currentRoute != null); // Must find the route!\n\n       // Add listener to notify if restoration ID changes (e.g., route becomes non-restorable)\n       _currentRoute!.restorationScopeId.addListener(notifyListeners);\n\n       // Listen for the route completion (when it's popped)\n       _currentRoute!.popped.then((dynamic result) {\n           if (_disposed) return; // Avoid errors if the property is disposed\n\n           // Clean up listeners and references\n           _currentRoute?.restorationScopeId.removeListener(notifyListeners);\n           _currentRoute = null;\n           notifyListeners(); // Notify that the route is no longer present\n\n           // Call the user-provided completion callback\n           onComplete?.call(result as T);\n       });\n   }\n\n   bool get isPresent => _currentRoute != null;\n\n   Route<T>? get route => _currentRoute;\n\n}\n```\n\n```mermaid\nsequenceDiagram\n    participant AppState as YourState (with RestorationMixin)\n    participant RestorableRouteFuture\n    participant User\n    participant MainScreenWidget\n    participant ElevatedButton\n    participant NavigatorState\n    participant RestorableRoute (e.g., DialogRoute)\n    participant RestorableProperty\n\n    alt Initial Push (No Restoration)\n        User->>MainScreenWidget: App starts\n        MainScreenWidget->>AppState: Build\n        AppState->>RestorableRouteFuture: Register as RestorableProperty\n        ElevatedButton->>AppState: Tap \"Show Dialog\"\n        AppState->>RestorableRouteFuture: present()\n        RestorableRouteFuture->>AppState: navigatorFinder(context)\n        AppState->>NavigatorState: Get NavigatorState\n        RestorableRouteFuture->>AppState: onPresent(NavigatorState, arguments)\n        AppState->>NavigatorState: Call restorablePush/showDialog (creates RestorableRoute)\n        NavigatorState->>RestorableRoute: Create Route\n        RestorableRoute->>NavigatorState: Get Restoration ID from self\n        NavigatorState->>AppState: Return Restoration ID (\"dialog-id-123\")\n        AppState->>RestorableRouteFuture: Returns \"dialog-id-123\" to present()\n        RestorableRouteFuture->>RestorableRouteFuture: Store ID (\"dialog-id-123\")\n        RestorableRouteFuture->>RestorableRouteFuture: _hookOntoRouteFuture(\"dialog-id-123\")\n        RestorableRouteFuture->>NavigatorState: _getRouteById(\"dialog-id-123\")\n        NavigatorState-->>RestorableRouteFuture: Return RestorableRoute object\n        RestorableRouteFuture->>RestorableRouteFuture: Store RestorableRoute object (_currentRoute)\n        RestorableRouteFuture->>RestorableProperty: notifyListeners() (Saves ID)\n        NavigatorState->>Overlay: Show RestorableRoute content\n    end\n\n    alt App Interrupted & Restored\n        User->>OperatingSystem: Background/Close App\n        OperatingSystem->>Restoration: Save state (includes Navigator history and RestorableProperty IDs)\n        User->>OperatingSystem: Reopen App\n        OperatingSystem->>Restoration: Restore state\n        Restoration->>AppState: Restore RestorableProperty (RestorableRouteFuture)\n        RestorableProperty->>RestorableRouteFuture: initWithValue(\"dialog-id-123\")\n        RestorableRouteFuture->>RestorableRouteFuture: _hookOntoRouteFuture(\"dialog-id-123\")\n        RestorableRouteFuture->>NavigatorState: _getRouteById(\"dialog-id-123\")\n        NavigatorState-->>RestorableRouteFuture: Return *restored* RestorableRoute object\n        RestorableRouteFuture->>RestorableRouteFuture: Store RestorableRoute object (_currentRoute)\n        RestorableRouteFuture->>RestorableProperty: notifyListeners()\n        NavigatorState->>Overlay: Rebuild restored RestorableRoute content\n    end\n\n    alt Dialog Completed (After Initial Push or Restoration)\n        User->>RestorableRoute: Interact and tap OK/Cancel\n        RestorableRoute->>NavigatorState: Navigator.pop(result)\n        NavigatorState->>RestorableRoute: didPop(result)\n        RestorableRoute->>RestorableRoute: Completes Future<T>\n        RestorableRouteFuture->>RestorableRoute: Future completes successfully\n        RestorableRouteFuture->>RestorableRouteFuture: _currentRoute.restorationScopeId -> removeListener\n        RestorableRouteFuture->>RestorableRouteFuture: _currentRoute = null\n        RestorableRouteFuture->>RestorableProperty: notifyListeners() (Clears saved ID)\n        RestorableRouteFuture->>AppState: onComplete(result)\n        AppState->>AppState: Update UI with result\n    end\n```\n\nThis diagram shows that `RestorableRouteFuture`'s job is to store the restorable ID when `present()` is called and, crucially, use that stored ID to find the corresponding *restored* route after the app restarts. It then hooks onto that restored route's completion `Future` so that the `onComplete` callback fires correctly.\n\n## Conclusion\n\n`RestorableRouteFuture` is a specialized helper class for managing navigation in Flutter apps that utilize state restoration. It's designed to work with the `NavigatorState.restorable...` methods to provide a persistent handle to routes pushed imperatively. This ensures that you can reliably receive the result of a route (like a dialog) even if the app process is killed and restored while that route is active. By registering a `RestorableRouteFuture` as a restorable property in your state, you enable your widget to correctly process results from routes pushed with state restoration in mind, bridging the gap between imperative navigation calls and the declarative nature of state restoration.\n\nThis concludes our exploration of Flutter's navigation concepts! You've now encountered the major pieces of the navigation puzzle, from basic stack management to advanced techniques for state restoration and customizable transitions. Happy navigating!"}