{"\nFor the project `flutter`:\n\nCodebase Context:\n--- File Index 0: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\n\n\nAnalyze the codebase context.\nIdentify the top 5-10 core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n- 0 # packages/flutter/lib/src/widgets/router.dart\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization\n  description: |\n    Another core concept, similar to a blueprint for objects.\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to 10 abstractions\n```": "```yaml\n- name: |\n    Router\n  description: |\n    Imagine the Router as the traffic controller for your app's screens. It listens for where the user wants to go (like entering a URL or pressing the back button), figures out what screen the code needs to build based on that location, and then tells the Navigator (the actual screen manager) to display the correct screen. It also helps save and restore the app's location if needed.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    RouteInformation\n  description: |\n    Think of RouteInformation as a note that tells the app where it is and what it's doing. It contains the location (like a web address) and any extra details or state associated with that location (like text in a search bar or scroll position). This information is exchanged between the Router and the RouteInformationProvider.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    RouteInformationProvider\n  description: |\n    This is like a sensor that detects changes in the app's location. It could be monitoring browser history on the web or system intents on a mobile device. When it senses a change, it provides the new RouteInformation to the Router so the app can update its screens accordingly. It also helps save the current route information for state restoration.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    RouteInformationParser\n  description: |\n    Consider this as a translator. Given a piece of RouteInformation (like a web address and some state), it translates that into a format that the RouterDelegate can understand and use to build the correct screen configuration. It also works in reverse to create RouteInformation from the current screen configuration for things like state restoration.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    RouterDelegate\n  description: |\n    This is the main builder of your app's screen layout based on the parsed route information. It receives the configuration from the RouteInformationParser and is responsible for creating the widgets, typically a Navigator, that display the screens. It also handles requests from the back button to navigate backward through the screens.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    BackButtonDispatcher\n  description: |\n    This abstraction is like the central handler for the system back button. When the user presses the back button on platforms that support it (like Android), this dispatcher receives the event and forwards it to the RouterDelegate, which then decides if it can handle the back navigation request. It supports nesting for complex navigation hierarchies.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    RootBackButtonDispatcher\n  description: |\n    This is the primary back button handler for the main Router in your app. It specifically listens for the system's pop route notifications and passes them along to the Router it's associated with. Think of it as the top-level receiver for back press events.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    ChildBackButtonDispatcher\n  description: |\n    This is used for nested Routers. It receives back button notifications from its parent BackButtonDispatcher and can claim priority to handle the event. This allows nested parts of your app to manage their own back navigation independently from the main app flow.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n- name: |\n    PopNavigatorRouterDelegateMixin\n  description: |\n    This is a helper for RouterDelegates that build a Navigator. By mixing this in, the RouterDelegate can easily handle back button events by telling the Navigator to try and pop the current screen. This simplifies hooking up the back button to the standard navigation behavior.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/router.dart\n```", "\nBased on the following abstractions and relevant code snippets from the project `flutter`:\n\nList of Abstraction Indices and Names:\n0 # Router\n\n1 # RouteInformation\n\n2 # RouteInformationProvider\n\n3 # RouteInformationParser\n\n4 # RouterDelegate\n\n5 # BackButtonDispatcher\n\n6 # RootBackButtonDispatcher\n\n7 # ChildBackButtonDispatcher\n\n8 # PopNavigatorRouterDelegateMixin\n\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\\n- Index 0: Router\n (Relevant file indices: [0])\\n  Description: Imagine the Router as the traffic controller for your app's screens. It listens for where the user wants to go (like entering a URL or pressing the back button), figures out what screen the code needs to build based on that location, and then tells the Navigator (the actual screen manager) to display the correct screen. It also helps save and restore the app's location if needed.\n\\n- Index 1: RouteInformation\n (Relevant file indices: [0])\\n  Description: Think of RouteInformation as a note that tells the app where it is and what it's doing. It contains the location (like a web address) and any extra details or state associated with that location (like text in a search bar or scroll position). This information is exchanged between the Router and the RouteInformationProvider.\n\\n- Index 2: RouteInformationProvider\n (Relevant file indices: [0])\\n  Description: This is like a sensor that detects changes in the app's location. It could be monitoring browser history on the web or system intents on a mobile device. When it senses a change, it provides the new RouteInformation to the Router so the app can update its screens accordingly. It also helps save the current route information for state restoration.\n\\n- Index 3: RouteInformationParser\n (Relevant file indices: [0])\\n  Description: Consider this as a translator. Given a piece of RouteInformation (like a web address and some state), it translates that into a format that the RouterDelegate can understand and use to build the correct screen configuration. It also works in reverse to create RouteInformation from the current screen configuration for things like state restoration.\n\\n- Index 4: RouterDelegate\n (Relevant file indices: [0])\\n  Description: This is the main builder of your app's screen layout based on the parsed route information. It receives the configuration from the RouteInformationParser and is responsible for creating the widgets, typically a Navigator, that display the screens. It also handles requests from the back button to navigate backward through the screens.\n\\n- Index 5: BackButtonDispatcher\n (Relevant file indices: [0])\\n  Description: This abstraction is like the central handler for the system back button. When the user presses the back button on platforms that support it (like Android), this dispatcher receives the event and forwards it to the RouterDelegate, which then decides if it can handle the back navigation request. It supports nesting for complex navigation hierarchies.\n\\n- Index 6: RootBackButtonDispatcher\n (Relevant file indices: [0])\\n  Description: This is the primary back button handler for the main Router in your app. It specifically listens for the system's pop route notifications and passes them along to the Router it's associated with. Think of it as the top-level receiver for back press events.\n\\n- Index 7: ChildBackButtonDispatcher\n (Relevant file indices: [0])\\n  Description: This is used for nested Routers. It receives back button notifications from its parent BackButtonDispatcher and can claim priority to handle the event. This allows nested parts of your app to manage their own back navigation independently from the main app flow.\n\\n- Index 8: PopNavigatorRouterDelegateMixin\n (Relevant file indices: [0])\\n  Description: This is a helper for RouterDelegates that build a Navigator. By mixing this in, the RouterDelegate can easily handle back button events by telling the Navigator to try and pop the current screen. This simplifies hooking up the back button to the standard navigation behavior.\n\\n\\nRelevant File Snippets (Referenced by Index and Path):\\n--- File: 0 # packages/flutter/lib/src/widgets/router.dart ---\\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project.\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\"\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\"\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  The Flutter `router` system is like a **traffic controller** for your app's screens.\n  It works by taking *route information* (like a web address or a back button press),\n  *parsing* it to understand where the user wants to go, and then *delegating*\n  the task of building the correct screens to display. It also helps manage the\n  system's back button behavior.\nrelationships:\n  - from_abstraction: 0 # Router\n    to_abstraction: 1 # RouteInformation\n    label: \"Uses\"\n  - from_abstraction: 0 # Router\n    to_abstraction: 2 # RouteInformationProvider\n    label: \"Listens to\"\n  - from_abstraction: 0 # Router\n    to_abstraction: 3 # RouteInformationParser\n    label: \"Uses\"\n  - from_abstraction: 0 # Router\n    to_abstraction: 4 # RouterDelegate\n    label: \"Uses\"\n  - from_abstraction: 0 # Router\n    to_abstraction: 5 # BackButtonDispatcher\n    label: \"Uses\"\n  - from_abstraction: 2 # RouteInformationProvider\n    to_abstraction: 1 # RouteInformation\n    label: \"Provides\"\n  - from_abstraction: 3 # RouteInformationParser\n    to_abstraction: 1 # RouteInformation\n    label: \"Receives\"\n  - from_abstraction: 3 # RouteInformationParser\n    to_abstraction: 4 # RouterDelegate\n    label: \"Outputs config for\"\n  - from_abstraction: 4 # RouterDelegate\n    to_abstraction: 1 # RouteInformation\n    label: \"Provides current\"\n  - from_abstraction: 5 # BackButtonDispatcher\n    to_abstraction: 4 # RouterDelegate\n    label: \"Notifies of pop\"\n  - from_abstraction: 6 # RootBackButtonDispatcher\n    to_abstraction: 5 # BackButtonDispatcher\n    label: \"Is a type of\"\n  - from_abstraction: 7 # ChildBackButtonDispatcher\n    to_abstraction: 5 # BackButtonDispatcher\n    label: \"Is a type of\"\n  - from_abstraction: 8 # PopNavigatorRouterDelegateMixin\n    to_abstraction: 4 # RouterDelegate\n    label: \"Extends\"\n```", "\nGiven the following project abstractions and their relationships for the project ```` flutter ````:\n\nAbstractions (Index # Name):\n- 0 # Router\n\n- 1 # RouteInformation\n\n- 2 # RouteInformationProvider\n\n- 3 # RouteInformationParser\n\n- 4 # RouterDelegate\n\n- 5 # BackButtonDispatcher\n\n- 6 # RootBackButtonDispatcher\n\n- 7 # ChildBackButtonDispatcher\n\n- 8 # PopNavigatorRouterDelegateMixin\n\n\nContext about relationships and project summary:\nProject Summary:\nThe Flutter `router` system is like a **traffic controller** for your app's screens.\nIt works by taking *route information* (like a web address or a back button press),\n*parsing* it to understand where the user wants to go, and then *delegating*\nthe task of building the correct screens to display. It also helps manage the\nsystem's back button behavior.\n\n\nRelationships (Indices refer to abstractions above):\n- From 0 (Router\n) to 1 (RouteInformation\n): Uses\n- From 0 (Router\n) to 2 (RouteInformationProvider\n): Listens to\n- From 0 (Router\n) to 3 (RouteInformationParser\n): Uses\n- From 0 (Router\n) to 4 (RouterDelegate\n): Uses\n- From 0 (Router\n) to 5 (BackButtonDispatcher\n): Uses\n- From 2 (RouteInformationProvider\n) to 1 (RouteInformation\n): Provides\n- From 3 (RouteInformationParser\n) to 1 (RouteInformation\n): Receives\n- From 3 (RouteInformationParser\n) to 4 (RouterDelegate\n): Outputs config for\n- From 4 (RouterDelegate\n) to 1 (RouteInformation\n): Provides current\n- From 5 (BackButtonDispatcher\n) to 4 (RouterDelegate\n): Notifies of pop\n- From 6 (RootBackButtonDispatcher\n) to 5 (BackButtonDispatcher\n): Is a type of\n- From 7 (ChildBackButtonDispatcher\n) to 5 (BackButtonDispatcher\n): Is a type of\n- From 8 (PopNavigatorRouterDelegateMixin\n) to 4 (RouterDelegate\n): Extends\n\n\nIf you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 1 # RouteInformation # Start with the core piece of data being handled\n- 2 # RouteInformationProvider # Explain where the information comes from\n- 3 # RouteInformationParser # Show how the information is understood\n- 4 # RouterDelegate # Introduce the class responsible for building the UI based on parsed info\n- 0 # Router # Explain the central orchestrator that ties the pieces together\n- 5 # BackButtonDispatcher # Discuss how back button presses are handled\n- 6 # RootBackButtonDispatcher # Introduce a specific type of dispatcher\n- 7 # ChildBackButtonDispatcher # Introduce another specific type of dispatcher\n- 8 # PopNavigatorRouterDelegateMixin # Explain a convenience mixin for delegate implementation\n```", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteInformation\n\". This is Chapter 1.\n\nConcept Details:\n- Name: RouteInformation\n\n- Description:\nThink of RouteInformation as a note that tells the app where it is and what it's doing. It contains the location (like a web address) and any extra details or state associated with that location (like text in a search bar or scroll position). This information is exchanged between the Router and the RouteInformationProvider.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: RouteInformation\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteInformationProvider\n\". This is Chapter 2.\n\nConcept Details:\n- Name: RouteInformationProvider\n\n- Description:\nThis is like a sensor that detects changes in the app's location. It could be monitoring browser history on the web or system intents on a mobile device. When it senses a change, it provides the new RouteInformation to the Router so the app can update its screens accordingly. It also helps save the current route information for state restoration.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2: RouteInformationProvider\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteInformationParser\n\". This is Chapter 3.\n\nConcept Details:\n- Name: RouteInformationParser\n\n- Description:\nConsider this as a translator. Given a piece of RouteInformation (like a web address and some state), it translates that into a format that the RouterDelegate can understand and use to build the correct screen configuration. It also works in reverse to create RouteInformation from the current screen configuration for things like state restoration.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3: RouteInformationParser\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouterDelegate\n\". This is Chapter 4.\n\nConcept Details:\n- Name: RouterDelegate\n\n- Description:\nThis is the main builder of your app's screen layout based on the parsed route information. It receives the configuration from the RouteInformationParser and is responsible for creating the widgets, typically a Navigator, that display the screens. It also handles requests from the back button to navigate backward through the screens.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4: RouterDelegate\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Router\n\". This is Chapter 5.\n\nConcept Details:\n- Name: Router\n\n- Description:\nImagine the Router as the traffic controller for your app's screens. It listens for where the user wants to go (like entering a URL or pressing the back button), figures out what screen the code needs to build based on that location, and then tells the Navigator (the actual screen manager) to display the correct screen. It also helps save and restore the app's location if needed.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n---\n# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5: Router\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5: Router\n\nWelcome back to our Flutter routing deep dive! In the previous chapters, we've explored some key players:\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The note telling us where to go and what data is needed.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The sensor that detects external route changes and gives us the `RouteInformation`.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The translator that turns `RouteInformation` into a structured app configuration.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The builder that takes the structured configuration and builds the UI, usually with a `Navigator`.\n\nBut who brings all these pieces together? Who is in charge of the whole routing process, listening to the [RouteInformationProvider](02_routeinformationprovider_.md), using the [RouteInformationParser](03_routeinformationparser_.md), and commanding the [RouterDelegate](04_routerdelegate_.md)?\n\nMeet the `Router` widget!\n\n## What is the Router Widget?\n\nThe `Router` widget is the **central hub** or the **orchestrator** of the Flutter routing system. It's the widget you place in your widget tree that ties together the [RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), and [RouterDelegate](04_routerdelegate_.md).\n\nThink of it as the conductor of an orchestra:\n\n*   It listens to the **[RouteInformationProvider](02_routeinformationprovider_.md)** (like listening to a signal from outside, such as a browser URL change).\n*   It hands that signal ([RouteInformation](01_routeinformation_.md)) to the **[RouteInformationParser](03_routeinformationparser_.md)** (like asking the translator to figure out what the signal means).\n*   It takes the result from the parser (the structured app configuration) and gives it to the **[RouterDelegate](04_routerdelegate_.md)** (like telling the builder exactly what to display).\n*   It also allows the [RouterDelegate](04_routerdelegate_.md) to report its current state and uses the [RouteInformationParser](03_routeinformationparser_.md) to convert that back to [RouteInformation](01_routeinformation_.md) for things like browser history.\n*   It coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) to handle system back button presses by telling the [RouterDelegate](04_routerdelegate_.md) to `popRoute`.\n\nEssentially, the `Router` widget is the glue that makes the Declarative Router system work. It's rarely something you interact with directly *after* setting it up; its job is to manage the delegates you provide.\n\nHere's a simplified flow showing the `Router` in the middle:\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Router as Router Widget\n    participant Parser as RouteInformationParser\n    participant Config as App Configuration\n    participant Delegate as RouterDelegate\n    participant UI as App UI (Navigator/Pages)\n\n    Provider->>Router: New RouteInformation available\n    Router->>Parser: parse(RouteInformation)\n    alt Parser completes\n        Parser-->>Router: Returns Config\n        Router->>Delegate: setNewRoutePath(Config)\n        Delegate-->>Router: Notifies Router (state changed)\n        Router->>Router: setState (Triggers rebuild)\n        Router->>Delegate: build()\n        Delegate-->>UI: Builds/Updates UI\n        Delegate->>Router: currentConfiguration\n        Router->>Parser: restore(Config)\n        Parser-->>Router: Returns RouteInformation\n        Router->>Provider: routerReportsNewRouteInformation(RouteInformation)\n    end\n```\n\nThis diagram shows the core cycle: The provider gets information, gives it to the Router, the Router passes it to the parser, the parser gives back configuration, the Router gives that to the delegate, the delegate updates its state and notifies the Router, the Router tells the delegate to build the UI, and finally, the Router gets the current state back from the delegate to report to the provider (for things like browser history).\n\n## Why Do We Need the Router Widget?\n\nWhile each delegate ([RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), [RouterDelegate](04_routerdelegate_.md), and [BackButtonDispatcher](06_backbuttondispatcher_.md)) has a specific responsibility, they need a manager to coordinate them. The `Router` widget provides this management layer.\n\nIt handles the complex asynchronous interactions (like waiting for the parser to finish) and ensures that when one delegate signals a change (like the provider getting a new route or the delegate's state changing), the correct methods on the other delegates are called in the right order.\n\nSetting up your routing with the `Router` looks like this (using `MaterialApp.router`, which internally uses a `Router` widget):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume this file contains our custom delegates and config\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n\n      // Provide our custom delegates!\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n      // backButtonDispatcher: RootBackButtonDispatcher(), // From Chapter 7\n    );\n  }\n}\n```\n\nHere, you don't explicitly write `Router(...)`, but `MaterialApp.router` is a convenience widget that does it for you. You pass in your custom implementations of the delegates we've discussed. The `MaterialApp.router` (or `WidgetsBinding.builder`) is a common place to set up the root `Router` for your application.\n\nYou *can* create a `Router` widget directly in your tree if you need nested routing, but for a basic app, the one provided by `MaterialApp.router` is usually sufficient.\n\n## How the Router Widget Works (Internal View)\n\nLet's peek inside the `_RouterState` class, which implements the state for the `Router` widget. This is where the connections between the delegates happen.\n\nWe've seen snippets of this in previous chapters, but let's review the core interactions:\n\n1.  **Receiving Route Information:** When the [RouteInformationProvider](02_routeinformationprovider_.md) notifies its listeners (which the `Router` state is), the `_handleRouteInformationProviderNotification` method is called:\n\n    ```dart\n    // Snippet from _RouterState._handleRouteInformationProviderNotification\n    void _handleRouteInformationProviderNotification() {\n      _routeParsePending = true; // Mark that we need to parse\n      _processRouteInformation(\n        widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n        () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n      );\n    }\n    ```\n    This gets the latest [RouteInformation](01_routeinformation_.md) from the provider and calls `_processRouteInformation`.\n\n2.  **Processing Route Information:** The `_processRouteInformation` calls the [RouteInformationParser](03_routeinformationparser_.md):\n\n    ```dart\n    // Snippet from _RouterState._processRouteInformation\n    void _processRouteInformation(\n      RouteInformation information,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter, // How to call the delegate\n    ) {\n      // ... setup ...\n\n      // Call the parser!\n      widget.routeInformationParser!\n          .parseRouteInformationWithDependencies(information, context)\n          .then<void>( // When parsing completes...\n              _processParsedRouteInformation( // ...process the result\n                  _currentRouterTransaction, delegateRouteSetter));\n    }\n    ```\n    This waits for the `parseRouteInformationWithDependencies` future to complete.\n\n3.  **Calling the RouterDelegate:** Once the parser returns the structured configuration (`T`), `_processParsedRouteInformation` is called, which then calls the appropriate setter on the [RouterDelegate](04_routerdelegate_.md) (`setNewRoutePath`, `setInitialRoutePath`, or `setRestoredRoutePath`):\n\n    ```dart\n    // Snippet from _RouterState._processParsedRouteInformation\n    _RouteSetter<T> _processParsedRouteInformation(\n      Object? transaction,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n    ) {\n      return (T data) async { // 'data' is the parsed config\n        // Call the delegate's method!\n        await delegateRouteSetter()(data);\n         // If successful, trigger a rebuild\n        _rebuild();\n      };\n    }\n    ```\n\n4.  **Listening to the RouterDelegate:** The `Router` also listens to the [RouterDelegate](04_routerdelegate_.md). This is set up in `initState`:\n\n    ```dart\n    // Snippet from _RouterState.initState\n    @override\n    void initState() {\n      super.initState();\n      // ... other listeners ...\n      // Listen to the delegate!\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n    }\n    ```\n    And when the delegate calls `notifyListeners()`, `_handleRouterDelegateNotification` runs:\n\n    ```dart\n    // Snippet from _RouterState._handleRouterDelegateNotification\n    void _handleRouterDelegateNotification() {\n      // Rebuild the Router\n      setState(() { /* routerDelegate wants to rebuild */ });\n      // And potentially report the new route information\n      _maybeNeedToReportRouteInformation();\n    }\n    ```\n    This rebuild is what causes the delegate's `build` method to be called, updating the UI. The call to `_maybeNeedToReportRouteInformation` triggers the reverse process (Configuration -> [RouteInformation](01_routeinformation_.md) -> [RouteInformationProvider](02_routeinformationprovider_.md)).\n\n5.  **Handling Back Button:** The `Router` also listens to the [BackButtonDispatcher](06_backbuttondispatcher_.md) (set up in `initState`). When notified, it calls the delegate's `popRoute` method:\n\n    ```dart\n    // Snippet from _RouterState._handleBackButtonDispatcherNotification\n    Future<bool> _handleBackButtonDispatcherNotification() {\n      _currentRouterTransaction = Object(); // Start a new transaction\n      // Call the delegate's popRoute!\n      return widget.routerDelegate.popRoute().then<bool>(\n        _handleRoutePopped(_currentRouterTransaction), // Process the result\n      );\n    }\n    ```\n\nThese internal methods show how the `Router` is constantly listening for changes from the [RouteInformationProvider](02_routeinformationprovider_.md), orchestrating the parsing and delegate updates, and listening back to the [RouterDelegate](04_routerdelegate_.md) and [BackButtonDispatcher](06_backbuttondispatcher_.md) to manage the overall routing state and UI.\n\nThe `build` method of the `Router` simply provides an `InheritedWidget` (`_RouterScope`) so descendant widgets can access the router's delegates (using `Router.of(context)`) and then calls `widget.routerDelegate.build(context)` to get the actual UI tree:\n\n```dart\n// Snippet from _RouterState.build\n@override\nWidget build(BuildContext context) {\n  return UnmanagedRestorationScope(\n    bucket: bucket,\n    child: _RouterScope(\n      // Provides delegates via InheritedWidget\n      routeInformationProvider: widget.routeInformationProvider,\n      bac...tonDispatcher: widget.backButtonDispatcher,\n      ro...InformationParser: widget.routeInformationParser,\n      r...Delegate: widget.routerDelegate,\n      routerState: this,\n      child: Builder(\n        // *** Calls the delegate's build method! ***\n        builder: widget.routerDelegate.build,\n      ),\n    ),\n  );\n}\n```\n\nThis reinforces that the `Router`'s job isn't to build the screen content itself, but to provide the context (via `_RouterScope`) and tell the `RouterDelegate` when and where to build.\n\n## Conclusion\n\nThe `Router` widget is the central figure in Flutter's Declarative Router system. It's the orchestrator that receives route information, delegates the parsing to the [RouteInformationParser](03_routeinformationparser_.md), passes the resulting configuration to the [RouterDelegate](04_routerdelegate_.md) to build the UI, and coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) for back button handling. While you often interact with it indirectly through convenience widgets like `MaterialApp.router`, understanding its role as the connector between all the delegates is key to grasping how the system functions.\n\nIn the next chapter, we'll look closer at the [BackButtonDispatcher](06_backbuttondispatcher_.md), which the `Router` listens to for those important system back button presses.\n\n[Next Chapter: BackButtonDispatcher](06_backbuttondispatcher_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"BackButtonDispatcher\n\". This is Chapter 6.\n\nConcept Details:\n- Name: BackButtonDispatcher\n\n- Description:\nThis abstraction is like the central handler for the system back button. When the user presses the back button on platforms that support it (like Android), this dispatcher receives the event and forwards it to the RouterDelegate, which then decides if it can handle the back navigation request. It supports nesting for complex navigation hierarchies.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n---\n# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)\n---\n# Chapter 5: Router\n\nWelcome back to our Flutter routing deep dive! In the previous chapters, we've explored some key players:\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The note telling us where to go and what data is needed.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The sensor that detects external route changes and gives us the `RouteInformation`.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The translator that turns `RouteInformation` into a structured app configuration.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The builder that takes the structured configuration and builds the UI, usually with a `Navigator`.\n\nBut who brings all these pieces together? Who is in charge of the whole routing process, listening to the [RouteInformationProvider](02_routeinformationprovider_.md), using the [RouteInformationParser](03_routeinformationparser_.md), and commanding the [RouterDelegate](04_routerdelegate_.md)?\n\nMeet the `Router` widget!\n\n## What is the Router Widget?\n\nThe `Router` widget is the **central hub** or the **orchestrator** of the Flutter routing system. It's the widget you place in your widget tree that ties together the [RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), and [RouterDelegate](04_routerdelegate_.md).\n\nThink of it as the conductor of an orchestra:\n\n*   It listens to the **[RouteInformationProvider](02_routeinformationprovider_.md)** (like listening to a signal from outside, such as a browser URL change).\n*   It hands that signal ([RouteInformation](01_routeinformation_.md)) to the **[RouteInformationParser](03_routeinformationparser_.md)** (like asking the translator to figure out what the signal means).\n*   It takes the result from the parser (the structured app configuration) and gives it to the **[RouterDelegate](04_routerdelegate_.md)** (like telling the builder exactly what to display).\n*   It also allows the [RouterDelegate](04_routerdelegate_.md) to report its current state and uses the [RouteInformationParser](03_routeinformationparser_.md) to convert that back to [RouteInformation](01_routeinformation_.md) for things like browser history.\n*   It coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) to handle system back button presses by telling the [RouterDelegate](04_routerdelegate_.md) to `popRoute`.\n\nEssentially, the `Router` widget is the glue that makes the Declarative Router system work. It's rarely something you interact with directly *after* setting it up; its job is to manage the delegates you provide.\n\nHere's a simplified flow showing the `Router` in the middle:\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Router as Router Widget\n    participant Parser as RouteInformationParser\n    participant Config as App Configuration\n    participant Delegate as RouterDelegate\n    participant UI as App UI (Navigator/Pages)\n\n    Provider->>Router: New RouteInformation available\n    Router->>Parser: parse(RouteInformation)\n    alt Parser completes\n        Parser-->>Router: Returns Config\n        Router->>Delegate: setNewRoutePath(Config)\n        Delegate-->>Router: Notifies Router (state changed)\n        Router->>Router: setState (Triggers rebuild)\n        Router->>Delegate: build()\n        Delegate-->>UI: Builds/Updates UI\n        Delegate->>Router: currentConfiguration\n        Router->>Parser: restore(Config)\n        Parser-->>Router: Returns RouteInformation\n        Router->>Provider: routerReportsNewRouteInformation(RouteInformation)\n    end\n```\n\nThis diagram shows the core cycle: The provider gets information, gives it to the Router, the Router passes it to the parser, the parser gives back configuration, the Router gives that to the delegate, the delegate updates its state and notifies the Router, the Router tells the delegate to build the UI, and finally, the Router gets the current state back from the delegate to report to the provider (for things like browser history).\n\n## Why Do We Need the Router Widget?\n\nWhile each delegate ([RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), [RouterDelegate](04_routerdelegate_.md), and [BackButtonDispatcher](06_backbuttondispatcher_.md)) has a specific responsibility, they need a manager to coordinate them. The `Router` widget provides this management layer.\n\nIt handles the complex asynchronous interactions (like waiting for the parser to finish) and ensures that when one delegate signals a change (like the provider getting a new route or the delegate's state changing), the correct methods on the other delegates are called in the right order.\n\nSetting up your routing with the `Router` looks like this (using `MaterialApp.router`, which internally uses a `Router` widget):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume this file contains our custom delegates and config\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n\n      // Provide our custom delegates!\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n      // backButtonDispatcher: RootBackButtonDispatcher(), // From Chapter 7\n    );\n  }\n}\n```\n\nHere, you don't explicitly write `Router(...)`, but `MaterialApp.router` is a convenience widget that does it for you. You pass in your custom implementations of the delegates we've discussed. The `MaterialApp.router` (or `WidgetsBinding.builder`) is a common place to set up the root `Router` for your application.\n\nYou *can* create a `Router` widget directly in your tree if you need nested routing, but for a basic app, the one provided by `MaterialApp.router` is usually sufficient.\n\n## How the Router Widget Works (Internal View)\n\nLet's peek inside the `_RouterState` class, which implements the state for the `Router` widget. This is where the connections between the delegates happen.\n\nWe've seen snippets of this in previous chapters, but let's review the core interactions:\n\n1.  **Receiving Route Information:** When the [RouteInformationProvider](02_routeinformationprovider_.md) notifies its listeners (which the `Router` state is), the `_handleRouteInformationProviderNotification` method is called:\n\n    ```dart\n    // Snippet from _RouterState._handleRouteInformationProviderNotification\n    void _handleRouteInformationProviderNotification() {\n      _routeParsePending = true; // Mark that we need to parse\n      _processRouteInformation(\n        widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n        () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n      );\n    }\n    ```\n    This gets the latest [RouteInformation](01_routeinformation_.md) from the provider and calls `_processRouteInformation`.\n\n2.  **Processing Route Information:** The `_processRouteInformation` calls the [RouteInformationParser](03_routeinformationparser_.md):\n\n    ```dart\n    // Snippet from _RouterState._processRouteInformation\n    void _processRouteInformation(\n      RouteInformation information,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter, // How to call the delegate\n    ) {\n      // ... setup ...\n\n      // Call the parser!\n      widget.routeInformationParser!\n          .parseRouteInformationWithDependencies(information, context)\n          .then<void>( // When parsing completes...\n              _processParsedRouteInformation( // ...process the result\n                  _currentRouterTransaction, delegateRouteSetter));\n    }\n    ```\n    This waits for the `parseRouteInformationWithDependencies` future to complete.\n\n3.  **Calling the RouterDelegate:** Once the parser returns the structured configuration (`T`), `_processParsedRouteInformation` is called, which then calls the appropriate setter on the [RouterDelegate](04_routerdelegate_.md) (`setNewRoutePath`, `setInitialRoutePath`, or `setRestoredRoutePath`):\n\n    ```dart\n    // Snippet from _RouterState._processParsedRouteInformation\n    _RouteSetter<T> _processParsedRouteInformation(\n      Object? transaction,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n    ) {\n      return (T data) async { // 'data' is the parsed config\n        // Call the delegate's method!\n        await delegateRouteSetter()(data);\n         // If successful, trigger a rebuild\n        _rebuild();\n      };\n    }\n    ```\n\n4.  **Listening to the RouterDelegate:** The `Router` also listens to the [RouterDelegate](04_routerdelegate_.md). This is set up in `initState`:\n\n    ```dart\n    // Snippet from _RouterState.initState\n    @override\n    void initState() {\n      super.initState();\n      // ... other listeners ...\n      // Listen to the delegate!\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n    }\n    ```\n    And when the delegate calls `notifyListeners()`, `_handleRouterDelegateNotification` runs:\n\n    ```dart\n    // Snippet from _RouterState._handleRouterDelegateNotification\n    void _handleRouterDelegateNotification() {\n      // Rebuild the Router\n      setState(() { /* routerDelegate wants to rebuild */ });\n      // And potentially report the new route information\n      _maybeNeedToReportRouteInformation();\n    }\n    ```\n    This rebuild is what causes the delegate's `build` method to be called, updating the UI. The call to `_maybeNeedToReportRouteInformation` triggers the reverse process (Configuration -> [RouteInformation](01_routeinformation_.md) -> [RouteInformationProvider](02_routeinformationprovider_.md)).\n\n5.  **Handling Back Button:** The `Router` also listens to the [BackButtonDispatcher](06_backbuttondispatcher_.md) (set up in `initState`). When notified, it calls the delegate's `popRoute` method:\n\n    ```dart\n    // Snippet from _RouterState._handleBackButtonDispatcherNotification\n    Future<bool> _handleBackButtonDispatcherNotification() {\n      _currentRouterTransaction = Object(); // Start a new transaction\n      // Call the delegate's popRoute!\n      return widget.routerDelegate.popRoute().then<bool>(\n        _handleRoutePopped(_currentRouterTransaction), // Process the result\n      );\n    }\n    ```\n\nThese internal methods show how the `Router` is constantly listening for changes from the [RouteInformationProvider](02_routeinformationprovider_.md), orchestrating the parsing and delegate updates, and listening back to the [RouterDelegate](04_routerdelegate_.md) and [BackButtonDispatcher](06_backbuttondispatcher_.md) to manage the overall routing state and UI.\n\nThe `build` method of the `Router` simply provides an `InheritedWidget` (`_RouterScope`) so descendant widgets can access the router's delegates (using `Router.of(context)`) and then calls `widget.routerDelegate.build(context)` to get the actual UI tree:\n\n```dart\n// Snippet from _RouterState.build\n@override\nWidget build(BuildContext context) {\n  return UnmanagedRestorationScope(\n    bucket: bucket,\n    child: _RouterScope(\n      // Provides delegates via InheritedWidget\n      routeInformationProvider: widget.routeInformationProvider,\n      bac...tonDispatcher: widget.backButtonDispatcher,\n      ro...InformationParser: widget.routeInformationParser,\n      r...Delegate: widget.routerDelegate,\n      routerState: this,\n      child: Builder(\n        // *** Calls the delegate's build method! ***\n        builder: widget.routerDelegate.build,\n      ),\n    ),\n  );\n}\n```\n\nThis reinforces that the `Router`'s job isn't to build the screen content itself, but to provide the context (via `_RouterScope`) and tell the `RouterDelegate` when and where to build.\n\n## Conclusion\n\nThe `Router` widget is the central figure in Flutter's Declarative Router system. It's the orchestrator that receives route information, delegates the parsing to the [RouteInformationParser](03_routeinformationparser_.md), passes the resulting configuration to the [RouterDelegate](04_routerdelegate_.md) to build the UI, and coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) for back button handling. While you often interact with it indirectly through convenience widgets like `MaterialApp.router`, understanding its role as the connector between all the delegates is key to grasping how the system functions.\n\nIn the next chapter, we'll look closer at the [BackButtonDispatcher](06_backbuttondispatcher_.md), which the `Router` listens to for those important system back button presses.\n\n[Next Chapter: BackButtonDispatcher](06_backbuttondispatcher_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6: BackButtonDispatcher\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6: BackButtonDispatcher\n\nWelcome back! In the last five chapters, we've built a good understanding of how Flutter's Declarative Router manages navigation using:\n\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The \"where and what\" note.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The \"sensor\" for external route changes.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The \"translator\" from raw notes to structured app configurations.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The \"builder\" that uses the configuration to show screens, often via a `Navigator`.\n*   [Chapter 5: Router](05_router_.md): The \"orchestrator\" that connects all the delegates.\n\nNow, what about that important system back button? On platforms like Android, users expect the back button to work intuitively \u2013 usually closing the current screen or going back to the previous step. How does our declarative routing system handle this?\n\nThis is where the `BackButtonDispatcher` comes in!\n\n## What is a BackButtonDispatcher?\n\nThink of the `BackButtonDispatcher` as the **system back button listener**. It's a mechanism that receives notifications when the user presses the hardware or software back button provided by the operating system (like on Android phones).\n\nWhen the `BackButtonDispatcher` catches a back button event, it doesn't handle it directly. Instead, its main job is to **forward** this event to the **[Router](05_router_.md)**. The [Router](05_router_.md) then tells the **[RouterDelegate](04_routerdelegate_.md)** to attempt to handle the back action.\n\nThe `BackButtonDispatcher` also supports **nesting**. This means if you have multiple [Router](05_router_.md)s for different parts of your UI (e.g., a main app [Router](05_router_.md) and a separate [Router](05_router_.md) for a flow within a tab), the back button event can be dispatched correctly to the most relevant [Router](05_router_.md) and its delegate.\n\nIts main purposes are:\n\n1.  **Receive System Back Button Events:** Listen for the platform-specific signal that the user wants to go back.\n2.  **Dispatch to the Router:** Notify the **[Router](05_router_.md)** that a back request has occurred.\n3.  **Coordinate Hierarchies:** Allow nested [Router](05_router_.md)s to participate in back button handling.\n\nHere's a simple flow:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant Dispatcher as BackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>Dispatcher: Sends back button event\n    Dispatcher->>Dispatcher: Receives event\n    Dispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>Dispatcher: Returns true/false\n    Dispatcher-->>System: Communicates handling status (affects whether app exits etc.)\n```\n\nThis flow shows that the `BackButtonDispatcher` is the critical first step in the Flutter routing system's response to a back button press.\n\n## Why Do We Need a BackButtonDispatcher?\n\nWithout a `BackButtonDispatcher`, Flutter wouldn't have a standardized way to receive back button events from the underlying operating system. Each platform might signal this differently, and the `BackButtonDispatcher` provides a common interface.\n\nFurthermore, since back button behavior can depend on the current screen and state (which is managed by your `RouterDelegate` in conjunction with a `Navigator`), the `BackButtonDispatcher` is needed to effectively forward this request to the component best equipped to handle it \u2013 your `RouterDelegate`.\n\nIt separates the *detection* of the back button press from the *logic* of what happens when it's pressed, keeping responsibilities clear.\n\n## How to Use a BackButtonDispatcher\n\nYou typically don't build your own custom `BackButtonDispatcher` from scratch for a basic app. Flutter provides standard implementations that you simply provide to your `Router` (or `MaterialApp.router`).\n\nFor the main, top-level `Router` in your app, you'll almost always use the `RootBackButtonDispatcher`. We'll cover `RootBackButtonDispatcher` in more detail in [Chapter 7](07_rootbackbuttondispatcher_.md), but for now, just know that it's the concrete class that listens to the platform's default back button messages.\n\nHere's how you integrate it into your `MaterialApp.router` setup:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the BackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Using the root dispatcher\n\n    );\n  }\n}\n```\n\nBy providing a `RootBackButtonDispatcher` to the `backButtonDispatcher` property, you're telling the `Router` widget: \"Use this object to listen for system back button presses.\"\n\nWhen the user presses the back button, the `RootBackButtonDispatcher` catches it and notifies the `Router`. The `Router` then calls your `RouterDelegate`'s `popRoute` method. As we saw in [Chapter 4](04_routerdelegate_.md), if you use the `PopNavigatorRouterDelegateMixin`, your `popRoute` method will automatically try to pop the top-most page from the `Navigator`.\n\nSo, in essence, providing a `RootBackButtonDispatcher` and using `PopNavigatorRouterDelegateMixin` in your `RouterDelegate` gives you standard back button behavior that pops screens from your primary `Navigator`.\n\n## Internal View (How Flutter Uses It)\n\nLet's see how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) interacts with the `BackButtonDispatcher`.\n\nThe `Router`'s internal state (`_RouterState`) registers itself as a listener with the `BackButtonDispatcher` in its `initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router registers as a listener to the back button dispatcher!\n  widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n  // ... rest of initState ...\n}\n```\n\nThis means when the `BackButtonDispatcher` receives a back button event and calls its `invokeCallback` method, the `_handleBackButtonDispatcherNotification` method in the `_RouterState` will be executed.\n\nWhat does `_handleBackButtonDispatcherNotification` do? It's responsible for telling the **[RouterDelegate](04_routerdelegate_.md)** to handle the pop request:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  // Create a new transaction object (used internally to track simultaneous requests)\n  _currentRouterTransaction = Object();\n  // *** Call the delegate's popRoute method! ***\n  return widget.routerDelegate.popRoute().then<bool>(\n    // Process the result from popRoute (true/false)\n    _handleRoutePopped(_currentRouterTransaction),\n  );\n}\n```\n\nLet's break this down:\n\n1.  When the `BackButtonDispatcher` notifies the `Router`, `_handleBackButtonDispatcherNotification` is called.\n2.  Crucially, it calls `widget.routerDelegate.popRoute()`. This redirects the responsibility of handling the back action to the `RouterDelegate`.\n3.  The `RouterDelegate`'s `popRoute` method (which, with `PopNavigatorRouterDelegateMixin`, calls `Navigator.maybePop()`) attempts to handle the back event. It returns a `Future<bool>`: `true` if it successfully popped something, `false` otherwise.\n4.  The `.then<bool>` structure waits for this `Future<bool>` to complete. The result (`true` or `false`) is then passed to `_handleRoutePopped`.\n\nThe `_handleRoutePopped` method simply processes the result:\n\n```dart\n// Snippet from _RouterState._handleRoutePopped\n_AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n  return (bool data) { // 'data' is the true/false result from popRoute()\n    if (transaction != _currentRouterTransaction) {\n      // If a new transaction started while we were waiting for popRoute,\n      // assume this pop was handled to avoid unwanted bubbling.\n      return SynchronousFuture<bool>(true);\n    }\n    // Trigger a rebuild of the Router (which calls the delegate's build)\n    _rebuild();\n    // Return the actual result (true/false) so the dispatcher knows if it was handled\n    return SynchronousFuture<bool>(data);\n  };\n}\n```\n\nThis method:\n\n1.  Receives the boolean result `data` from the `RouterDelegate.popRoute()`.\n2.  If the pop was handled (`data` is `true`), it calls `_rebuild()`, which causes the `Router` to rebuild, reflecting the popped page (e.g., the `Navigator` with one less page).\n3.  It returns the `data` result (`true` or `false`) back up the chain. This result goes back to the `BackButtonDispatcher`, which can use it to signal to the platform whether the event was fully handled by Flutter (preventing the OS from, say, closing the entire app).\n\nThese internal steps illustrate how the `BackButtonDispatcher` acts as the initial trigger for back button handling, forwarding the request to the **[Router](05_router_.md)**, which then relies on the **[RouterDelegate](04_routerdelegate_.md)** to perform the actual logic.\n\n## Conclusion\n\nThe `BackButtonDispatcher` is the abstraction responsible for catching system back button presses and initiating the backward navigation process within your Flutter app's routing system. It acts as a listener for platform-specific back events and effectively notifies the **[Router](05_router_.md)**, which then directs the responsibility to the **[RouterDelegate](04_routerdelegate_.md)**'s `popRoute` method. By using a `RootBackButtonDispatcher` at the top level of your app and implementing `popRoute` (often with the help of `PopNavigatorRouterDelegateMixin`), you ensure that the system back button interacts correctly with your app's navigation stack.\n\nIn the next two chapters, we'll look closer at the common implementations: [RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md) and [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md).\n\n[Next Chapter: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RootBackButtonDispatcher\n\". This is Chapter 7.\n\nConcept Details:\n- Name: RootBackButtonDispatcher\n\n- Description:\nThis is the primary back button handler for the main Router in your app. It specifically listens for the system's pop route notifications and passes them along to the Router it's associated with. Think of it as the top-level receiver for back press events.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n---\n# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)\n---\n# Chapter 5: Router\n\nWelcome back to our Flutter routing deep dive! In the previous chapters, we've explored some key players:\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The note telling us where to go and what data is needed.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The sensor that detects external route changes and gives us the `RouteInformation`.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The translator that turns `RouteInformation` into a structured app configuration.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The builder that takes the structured configuration and builds the UI, usually with a `Navigator`.\n\nBut who brings all these pieces together? Who is in charge of the whole routing process, listening to the [RouteInformationProvider](02_routeinformationprovider_.md), using the [RouteInformationParser](03_routeinformationparser_.md), and commanding the [RouterDelegate](04_routerdelegate_.md)?\n\nMeet the `Router` widget!\n\n## What is the Router Widget?\n\nThe `Router` widget is the **central hub** or the **orchestrator** of the Flutter routing system. It's the widget you place in your widget tree that ties together the [RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), and [RouterDelegate](04_routerdelegate_.md).\n\nThink of it as the conductor of an orchestra:\n\n*   It listens to the **[RouteInformationProvider](02_routeinformationprovider_.md)** (like listening to a signal from outside, such as a browser URL change).\n*   It hands that signal ([RouteInformation](01_routeinformation_.md)) to the **[RouteInformationParser](03_routeinformationparser_.md)** (like asking the translator to figure out what the signal means).\n*   It takes the result from the parser (the structured app configuration) and gives it to the **[RouterDelegate](04_routerdelegate_.md)** (like telling the builder exactly what to display).\n*   It also allows the [RouterDelegate](04_routerdelegate_.md) to report its current state and uses the [RouteInformationParser](03_routeinformationparser_.md) to convert that back to [RouteInformation](01_routeinformation_.md) for things like browser history.\n*   It coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) to handle system back button presses by telling the [RouterDelegate](04_routerdelegate_.md) to `popRoute`.\n\nEssentially, the `Router` widget is the glue that makes the Declarative Router system work. It's rarely something you interact with directly *after* setting it up; its job is to manage the delegates you provide.\n\nHere's a simplified flow showing the `Router` in the middle:\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Router as Router Widget\n    participant Parser as RouteInformationParser\n    participant Config as App Configuration\n    participant Delegate as RouterDelegate\n    participant UI as App UI (Navigator/Pages)\n\n    Provider->>Router: New RouteInformation available\n    Router->>Parser: parse(RouteInformation)\n    alt Parser completes\n        Parser-->>Router: Returns Config\n        Router->>Delegate: setNewRoutePath(Config)\n        Delegate-->>Router: Notifies Router (state changed)\n        Router->>Router: setState (Triggers rebuild)\n        Router->>Delegate: build()\n        Delegate-->>UI: Builds/Updates UI\n        Delegate->>Router: currentConfiguration\n        Router->>Parser: restore(Config)\n        Parser-->>Router: Returns RouteInformation\n        Router->>Provider: routerReportsNewRouteInformation(RouteInformation)\n    end\n```\n\nThis diagram shows the core cycle: The provider gets information, gives it to the Router, the Router passes it to the parser, the parser gives back configuration, the Router gives that to the delegate, the delegate updates its state and notifies the Router, the Router tells the delegate to build the UI, and finally, the Router gets the current state back from the delegate to report to the provider (for things like browser history).\n\n## Why Do We Need the Router Widget?\n\nWhile each delegate ([RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), [RouterDelegate](04_routerdelegate_.md), and [BackButtonDispatcher](06_backbuttondispatcher_.md)) has a specific responsibility, they need a manager to coordinate them. The `Router` widget provides this management layer.\n\nIt handles the complex asynchronous interactions (like waiting for the parser to finish) and ensures that when one delegate signals a change (like the provider getting a new route or the delegate's state changing), the correct methods on the other delegates are called in the right order.\n\nSetting up your routing with the `Router` looks like this (using `MaterialApp.router`, which internally uses a `Router` widget):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume this file contains our custom delegates and config\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n\n      // Provide our custom delegates!\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n      // backButtonDispatcher: RootBackButtonDispatcher(), // From Chapter 7\n    );\n  }\n}\n```\n\nHere, you don't explicitly write `Router(...)`, but `MaterialApp.router` is a convenience widget that does it for you. You pass in your custom implementations of the delegates we've discussed. The `MaterialApp.router` (or `WidgetsBinding.builder`) is a common place to set up the root `Router` for your application.\n\nYou *can* create a `Router` widget directly in your tree if you need nested routing, but for a basic app, the one provided by `MaterialApp.router` is usually sufficient.\n\n## How the Router Widget Works (Internal View)\n\nLet's peek inside the `_RouterState` class, which implements the state for the `Router` widget. This is where the connections between the delegates happen.\n\nWe've seen snippets of this in previous chapters, but let's review the core interactions:\n\n1.  **Receiving Route Information:** When the [RouteInformationProvider](02_routeinformationprovider_.md) notifies its listeners (which the `Router` state is), the `_handleRouteInformationProviderNotification` method is called:\n\n    ```dart\n    // Snippet from _RouterState._handleRouteInformationProviderNotification\n    void _handleRouteInformationProviderNotification() {\n      _routeParsePending = true; // Mark that we need to parse\n      _processRouteInformation(\n        widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n        () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n      );\n    }\n    ```\n    This gets the latest [RouteInformation](01_routeinformation_.md) from the provider and calls `_processRouteInformation`.\n\n2.  **Processing Route Information:** The `_processRouteInformation` calls the [RouteInformationParser](03_routeinformationparser_.md):\n\n    ```dart\n    // Snippet from _RouterState._processRouteInformation\n    void _processRouteInformation(\n      RouteInformation information,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter, // How to call the delegate\n    ) {\n      // ... setup ...\n\n      // Call the parser!\n      widget.routeInformationParser!\n          .parseRouteInformationWithDependencies(information, context)\n          .then<void>( // When parsing completes...\n              _processParsedRouteInformation( // ...process the result\n                  _currentRouterTransaction, delegateRouteSetter));\n    }\n    ```\n    This waits for the `parseRouteInformationWithDependencies` future to complete.\n\n3.  **Calling the RouterDelegate:** Once the parser returns the structured configuration (`T`), `_processParsedRouteInformation` is called, which then calls the appropriate setter on the [RouterDelegate](04_routerdelegate_.md) (`setNewRoutePath`, `setInitialRoutePath`, or `setRestoredRoutePath`):\n\n    ```dart\n    // Snippet from _RouterState._processParsedRouteInformation\n    _RouteSetter<T> _processParsedRouteInformation(\n      Object? transaction,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n    ) {\n      return (T data) async { // 'data' is the parsed config\n        // Call the delegate's method!\n        await delegateRouteSetter()(data);\n         // If successful, trigger a rebuild\n        _rebuild();\n      };\n    }\n    ```\n\n4.  **Listening to the RouterDelegate:** The `Router` also listens to the [RouterDelegate](04_routerdelegate_.md). This is set up in `initState`:\n\n    ```dart\n    // Snippet from _RouterState.initState\n    @override\n    void initState() {\n      super.initState();\n      // ... other listeners ...\n      // Listen to the delegate!\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n    }\n    ```\n    And when the delegate calls `notifyListeners()`, `_handleRouterDelegateNotification` runs:\n\n    ```dart\n    // Snippet from _RouterState._handleRouterDelegateNotification\n    void _handleRouterDelegateNotification() {\n      // Rebuild the Router\n      setState(() { /* routerDelegate wants to rebuild */ });\n      // And potentially report the new route information\n      _maybeNeedToReportRouteInformation();\n    }\n    ```\n    This rebuild is what causes the delegate's `build` method to be called, updating the UI. The call to `_maybeNeedToReportRouteInformation` triggers the reverse process (Configuration -> [RouteInformation](01_routeinformation_.md) -> [RouteInformationProvider](02_routeinformationprovider_.md)).\n\n5.  **Handling Back Button:** The `Router` also listens to the [BackButtonDispatcher](06_backbuttondispatcher_.md) (set up in `initState`). When notified, it calls the delegate's `popRoute` method:\n\n    ```dart\n    // Snippet from _RouterState._handleBackButtonDispatcherNotification\n    Future<bool> _handleBackButtonDispatcherNotification() {\n      _currentRouterTransaction = Object(); // Start a new transaction\n      // Call the delegate's popRoute!\n      return widget.routerDelegate.popRoute().then<bool>(\n        _handleRoutePopped(_currentRouterTransaction), // Process the result\n      );\n    }\n    ```\n\nThese internal methods show how the `Router` is constantly listening for changes from the [RouteInformationProvider](02_routeinformationprovider_.md), orchestrating the parsing and delegate updates, and listening back to the [RouterDelegate](04_routerdelegate_.md) and [BackButtonDispatcher](06_backbuttondispatcher_.md) to manage the overall routing state and UI.\n\nThe `build` method of the `Router` simply provides an `InheritedWidget` (`_RouterScope`) so descendant widgets can access the router's delegates (using `Router.of(context)`) and then calls `widget.routerDelegate.build(context)` to get the actual UI tree:\n\n```dart\n// Snippet from _RouterState.build\n@override\nWidget build(BuildContext context) {\n  return UnmanagedRestorationScope(\n    bucket: bucket,\n    child: _RouterScope(\n      // Provides delegates via InheritedWidget\n      routeInformationProvider: widget.routeInformationProvider,\n      bac...tonDispatcher: widget.backButtonDispatcher,\n      ro...InformationParser: widget.routeInformationParser,\n      r...Delegate: widget.routerDelegate,\n      routerState: this,\n      child: Builder(\n        // *** Calls the delegate's build method! ***\n        builder: widget.routerDelegate.build,\n      ),\n    ),\n  );\n}\n```\n\nThis reinforces that the `Router`'s job isn't to build the screen content itself, but to provide the context (via `_RouterScope`) and tell the `RouterDelegate` when and where to build.\n\n## Conclusion\n\nThe `Router` widget is the central figure in Flutter's Declarative Router system. It's the orchestrator that receives route information, delegates the parsing to the [RouteInformationParser](03_routeinformationparser_.md), passes the resulting configuration to the [RouterDelegate](04_routerdelegate_.md) to build the UI, and coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) for back button handling. While you often interact with it indirectly through convenience widgets like `MaterialApp.router`, understanding its role as the connector between all the delegates is key to grasping how the system functions.\n\nIn the next chapter, we'll look closer at the [BackButtonDispatcher](06_backbuttondispatcher_.md), which the `Router` listens to for those important system back button presses.\n\n[Next Chapter: BackButtonDispatcher](06_backbuttondispatcher_.md)\n---\n# Chapter 6: BackButtonDispatcher\n\nWelcome back! In the last five chapters, we've built a good understanding of how Flutter's Declarative Router manages navigation using:\n\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The \"where and what\" note.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The \"sensor\" for external route changes.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The \"translator\" from raw notes to structured app configurations.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The \"builder\" that uses the configuration to show screens, often via a `Navigator`.\n*   [Chapter 5: Router](05_router_.md): The \"orchestrator\" that connects all the delegates.\n\nNow, what about that important system back button? On platforms like Android, users expect the back button to work intuitively \u2013 usually closing the current screen or going back to the previous step. How does our declarative routing system handle this?\n\nThis is where the `BackButtonDispatcher` comes in!\n\n## What is a BackButtonDispatcher?\n\nThink of the `BackButtonDispatcher` as the **system back button listener**. It's a mechanism that receives notifications when the user presses the hardware or software back button provided by the operating system (like on Android phones).\n\nWhen the `BackButtonDispatcher` catches a back button event, it doesn't handle it directly. Instead, its main job is to **forward** this event to the **[Router](05_router_.md)**. The [Router](05_router_.md) then tells the **[RouterDelegate](04_routerdelegate_.md)** to attempt to handle the back action.\n\nThe `BackButtonDispatcher` also supports **nesting**. This means if you have multiple [Router](05_router_.md)s for different parts of your UI (e.g., a main app [Router](05_router_.md) and a separate [Router](05_router_.md) for a flow within a tab), the back button event can be dispatched correctly to the most relevant [Router](05_router_.md) and its delegate.\n\nIts main purposes are:\n\n1.  **Receive System Back Button Events:** Listen for the platform-specific signal that the user wants to go back.\n2.  **Dispatch to the Router:** Notify the **[Router](05_router_.md)** that a back request has occurred.\n3.  **Coordinate Hierarchies:** Allow nested [Router](05_router_.md)s to participate in back button handling.\n\nHere's a simple flow:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant Dispatcher as BackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>Dispatcher: Sends back button event\n    Dispatcher->>Dispatcher: Receives event\n    Dispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>Dispatcher: Returns true/false\n    Dispatcher-->>System: Communicates handling status (affects whether app exits etc.)\n```\n\nThis flow shows that the `BackButtonDispatcher` is the critical first step in the Flutter routing system's response to a back button press.\n\n## Why Do We Need a BackButtonDispatcher?\n\nWithout a `BackButtonDispatcher`, Flutter wouldn't have a standardized way to receive back button events from the underlying operating system. Each platform might signal this differently, and the `BackButtonDispatcher` provides a common interface.\n\nFurthermore, since back button behavior can depend on the current screen and state (which is managed by your `RouterDelegate` in conjunction with a `Navigator`), the `BackButtonDispatcher` is needed to effectively forward this request to the component best equipped to handle it \u2013 your `RouterDelegate`.\n\nIt separates the *detection* of the back button press from the *logic* of what happens when it's pressed, keeping responsibilities clear.\n\n## How to Use a BackButtonDispatcher\n\nYou typically don't build your own custom `BackButtonDispatcher` from scratch for a basic app. Flutter provides standard implementations that you simply provide to your `Router` (or `MaterialApp.router`).\n\nFor the main, top-level `Router` in your app, you'll almost always use the `RootBackButtonDispatcher`. We'll cover `RootBackButtonDispatcher` in more detail in [Chapter 7](07_rootbackbuttondispatcher_.md), but for now, just know that it's the concrete class that listens to the platform's default back button messages.\n\nHere's how you integrate it into your `MaterialApp.router` setup:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the BackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Using the root dispatcher\n\n    );\n  }\n}\n```\n\nBy providing a `RootBackButtonDispatcher` to the `backButtonDispatcher` property, you're telling the `Router` widget: \"Use this object to listen for system back button presses.\"\n\nWhen the user presses the back button, the `RootBackButtonDispatcher` catches it and notifies the `Router`. The `Router` then calls your `RouterDelegate`'s `popRoute` method. As we saw in [Chapter 4](04_routerdelegate_.md), if you use the `PopNavigatorRouterDelegateMixin`, your `popRoute` method will automatically try to pop the top-most page from the `Navigator`.\n\nSo, in essence, providing a `RootBackButtonDispatcher` and using `PopNavigatorRouterDelegateMixin` in your `RouterDelegate` gives you standard back button behavior that pops screens from your primary `Navigator`.\n\n## Internal View (How Flutter Uses It)\n\nLet's see how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) interacts with the `BackButtonDispatcher`.\n\nThe `Router`'s internal state (`_RouterState`) registers itself as a listener with the `BackButtonDispatcher` in its `initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router registers as a listener to the back button dispatcher!\n  widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n  // ... rest of initState ...\n}\n```\n\nThis means when the `BackButtonDispatcher` receives a back button event and calls its `invokeCallback` method, the `_handleBackButtonDispatcherNotification` method in the `_RouterState` will be executed.\n\nWhat does `_handleBackButtonDispatcherNotification` do? It's responsible for telling the **[RouterDelegate](04_routerdelegate_.md)** to handle the pop request:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  // Create a new transaction object (used internally to track simultaneous requests)\n  _currentRouterTransaction = Object();\n  // *** Call the delegate's popRoute method! ***\n  return widget.routerDelegate.popRoute().then<bool>(\n    // Process the result from popRoute (true/false)\n    _handleRoutePopped(_currentRouterTransaction),\n  );\n}\n```\n\nLet's break this down:\n\n1.  When the `BackButtonDispatcher` notifies the `Router`, `_handleBackButtonDispatcherNotification` is called.\n2.  Crucially, it calls `widget.routerDelegate.popRoute()`. This redirects the responsibility of handling the back action to the `RouterDelegate`.\n3.  The `RouterDelegate`'s `popRoute` method (which, with `PopNavigatorRouterDelegateMixin`, calls `Navigator.maybePop()`) attempts to handle the back event. It returns a `Future<bool>`: `true` if it successfully popped something, `false` otherwise.\n4.  The `.then<bool>` structure waits for this `Future<bool>` to complete. The result (`true` or `false`) is then passed to `_handleRoutePopped`.\n\nThe `_handleRoutePopped` method simply processes the result:\n\n```dart\n// Snippet from _RouterState._handleRoutePopped\n_AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n  return (bool data) { // 'data' is the true/false result from popRoute()\n    if (transaction != _currentRouterTransaction) {\n      // If a new transaction started while we were waiting for popRoute,\n      // assume this pop was handled to avoid unwanted bubbling.\n      return SynchronousFuture<bool>(true);\n    }\n    // Trigger a rebuild of the Router (which calls the delegate's build)\n    _rebuild();\n    // Return the actual result (true/false) so the dispatcher knows if it was handled\n    return SynchronousFuture<bool>(data);\n  };\n}\n```\n\nThis method:\n\n1.  Receives the boolean result `data` from the `RouterDelegate.popRoute()`.\n2.  If the pop was handled (`data` is `true`), it calls `_rebuild()`, which causes the `Router` to rebuild, reflecting the popped page (e.g., the `Navigator` with one less page).\n3.  It returns the `data` result (`true` or `false`) back up the chain. This result goes back to the `BackButtonDispatcher`, which can use it to signal to the platform whether the event was fully handled by Flutter (preventing the OS from, say, closing the entire app).\n\nThese internal steps illustrate how the `BackButtonDispatcher` acts as the initial trigger for back button handling, forwarding the request to the **[Router](05_router_.md)**, which then relies on the **[RouterDelegate](04_routerdelegate_.md)** to perform the actual logic.\n\n## Conclusion\n\nThe `BackButtonDispatcher` is the abstraction responsible for catching system back button presses and initiating the backward navigation process within your Flutter app's routing system. It acts as a listener for platform-specific back events and effectively notifies the **[Router](05_router_.md)**, which then directs the responsibility to the **[RouterDelegate](04_routerdelegate_.md)**'s `popRoute` method. By using a `RootBackButtonDispatcher` at the top level of your app and implementing `popRoute` (often with the help of `PopNavigatorRouterDelegateMixin`), you ensure that the system back button interacts correctly with your app's navigation stack.\n\nIn the next two chapters, we'll look closer at the common implementations: [RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md) and [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md).\n\n[Next Chapter: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7: RootBackButtonDispatcher\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7: RootBackButtonDispatcher\n\nWelcome back! In the last chapter, we learned about the [BackButtonDispatcher](06_backbuttondispatcher_.md), the mechanism that listens for system back button presses and forwards them to the [Router](05_router_.md). We saw that it's how Flutter handles those important \"go back\" requests from the operating system, especially on platforms like Android.\n\nNow, we're going to look at a specific and very common type of [BackButtonDispatcher](06_backbuttondispatcher_.md): the `RootBackButtonDispatcher`.\n\n## What is a RootBackButtonDispatcher?\n\nThink of the `RootBackButtonDispatcher` as the **primary listener for system back buttons for your app's main navigation**. It's the one that sits at the highest level of your routing setup and is the first to hear when the user presses the device's back button.\n\nIts main job is simple:\n\n1.  **Listen to the Platform:** It registers with the underlying operating system to receive notifications whenever the global \"pop route\" event occurs (which happens when the user presses the back button).\n2.  **Notify the Router:** When it receives such a notification, it immediately tells the **[Router](05_router_.md)** it's associated with that a back request has happened.\n\nIt doesn't decide *what* happens when the back button is pressed; that's the job of the [RouterDelegate](04_routerdelegate_.md). The `RootBackButtonDispatcher` is solely responsible for *detecting* the system event and ensuring the top-level [Router](05_router_.md) is informed.\n\nIt's called \"Root\" because it's intended for the main, un-nested [Router](05_router_.md) at the root of your application's navigation hierarchy.\n\nHere's the flow we saw in [Chapter 6](06_backbuttondispatcher_.md), specifically with the `RootBackButtonDispatcher`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant RootDispatcher as RootBackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>RootDispatcher: Sends back button event\n    RootDispatcher->>RootDispatcher: Receives event\n    RootDispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>RootDispatcher: Returns true/false\n    RootDispatcher-->>System: Communicates handling status\n```\n\n## Why Do We Use a RootBackButtonDispatcher?\n\nFor most standard Flutter applications using the declarative router, you need *one* object that is responsible for catching the system back button event at the highest level. The `RootBackButtonDispatcher` is the built-in, standard way to achieve this.\n\nIf you don't provide any [BackButtonDispatcher](06_backbuttondispatcher_.md) to your root [Router](05_router_.md) (like the one managed by `MaterialApp.router`), system back button presses might not be handled correctly by your declarative routing system. You need an object connected to the `Router` that is specifically listening for these events.\n\nUsing `RootBackButtonDispatcher` gives you:\n\n*   **Standard Platform Integration:** It knows how to hook into the platform's native back button events.\n*   **Initial Back Button Handling Trigger:** It serves as the starting point for the back button event processing chain (RootDispatcher -> [Router](05_router_.md) -> [RouterDelegate](04_routerdelegate_.md)).\n\n## How to Use RootBackButtonDispatcher\n\nAs we briefly saw in the previous chapter, using `RootBackButtonDispatcher` is straightforward. You instantiate it and provide it to the `backButtonDispatcher` property of your main `Router` widget. Since `MaterialApp.router` creates the main `Router` for you, you provide it there:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the RootBackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Simple instantiation\n\n    );\n  }\n}\n```\n\nThat's it! You don't need to configure the `RootBackButtonDispatcher` any further for basic usage. By passing `RootBackButtonDispatcher()` to the `backButtonDispatcher` property, you are giving the `Router` the listener it needs to react to system back button pushes.\n\nThe `RootBackButtonDispatcher` itself doesn't require any arguments or complex setup for this purpose. It simply plugs into the platform's back button event system.\n\nRemember from [Chapter 4](04_routerdelegate_.md) that your `MyAppRouterDelegate` should implement the `popRoute` method (usually by mixing in `PopNavigatorRouterDelegateMixin`) for the back button press to actually do something like pop a screen from a `Navigator`. The `RootBackButtonDispatcher` just gets the event to the `Router`, and the `Router` passes it to the delegate's `popRoute`.\n\n## Internal View (How Flutter Uses RootBackButtonDispatcher)\n\nLet's dive a little deeper into the code to see how `RootBackButtonDispatcher` achieves its goal.\n\nThe `RootBackButtonDispatcher` class inherits from the base `BackButtonDispatcher` and also `WidgetsBindingObserver`:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  // ... methods below ...\n}\n```\nBy mixing in `WidgetsBindingObserver`, the `RootBackButtonDispatcher` can listen to system events delivered via the `WidgetsBinding.instance`.\n\nWhen the `Router` associated with this dispatcher starts up, it calls `addCallback` on the `RootBackButtonDispatcher` (as we saw in [Chapter 6](06_backbuttondispatcher_.md)'s internal view).\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (_RouterState.initState)\nwidget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n```\n\nThe `RootBackButtonDispatcher` overrides the `addCallback` method to start listening to the `WidgetsBinding` if it's the first callback being added:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid addCallback(ValueGetter<Future<bool>> callback) {\n  if (!hasCallbacks) { // hasCallbacks comes from the base BackButtonDispatcher\n    WidgetsBinding.instance.addObserver(this); // Starts listening to platform events!\n  }\n  super.addCallback(callback); // Add the provided callback (from the Router)\n}\n```\n\nThis `WidgetsBinding.instance.addObserver(this)` call is key. It registers the `RootBackButtonDispatcher` instance to receive important system event notifications, including `didPopRoute`.\n\nWhen the user presses the system back button, the Flutter engine on the platform side catches it and signals the framework through `WidgetsBinding`. This triggers the `didPopRoute` method *on the registered observer* (our `RootBackButtonDispatcher` instance):\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nFuture<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n```\n\nHere's what happens in `didPopRoute`:\n\n1.  It calls `invokeCallback`. This method, inherited from the base `BackButtonDispatcher`, is designed to call the callbacks that have been `addCallback`-ed to it.\n2.  As we saw earlier, the `Router` added a callback (`_handleBackButtonDispatcherNotification`) that triggers the `routerDelegate.popRoute()`.\n3.  So, the `didPopRoute` call effectively results in our `Router`'s `_handleBackButtonDispatcherNotification` being executed, which in turn calls our custom `RouterDelegate`'s `popRoute` method.\n4.  The result of `routerDelegate.popRoute()` (true/false future) is then returned by `invokeCallback` and subsequently by `didPopRoute`. This result goes back to the `WidgetsBinding`, indicating whether Flutter handled the pop request internally or if the underlying platform should proceed with its default behavior (like closing the app).\n\nThe `removeCallback` method in `RootBackButtonDispatcher` does cleanup, removing the observer if no more callbacks are listening:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid removeCallback(ValueGetter<Future<bool>> callback) {\n  super.removeCallback(callback);\n  if (!hasCallbacks) {\n    WidgetsBinding.instance.removeObserver(this); // Stop listening to platform events\n  }\n}\n```\n\nThis internal structure shows that the `RootBackButtonDispatcher` is a specialized `BackButtonDispatcher` that uses `WidgetsBindingObserver` to be the initial point of contact for system back button events, forwarding them through the generic `invokeCallback` mechanism to the registered listeners (the `Router`).\n\n## Conclusion\n\nThe `RootBackButtonDispatcher` is the standard, top-level component for receiving system back button presses in Flutter's declarative routing system. By providing an instance of `RootBackButtonDispatcher` to your root `Router`, you ensure that the system back button events are caught and properly dispatched to your `RouterDelegate`'s `popRoute` method for handling (typically popping a screen from a `Navigator`). It acts as the crucial bridge between the platform's back button mechanism and your application's routing logic.\n\nIn the next chapter, we'll look at the [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md), which is used when you have nested `Router`s and need more fine-grained control over which part of your UI handles the back button.\n\n[Next Chapter: ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"ChildBackButtonDispatcher\n\". This is Chapter 8.\n\nConcept Details:\n- Name: ChildBackButtonDispatcher\n\n- Description:\nThis is used for nested Routers. It receives back button notifications from its parent BackButtonDispatcher and can claim priority to handle the event. This allows nested parts of your app to manage their own back navigation independently from the main app flow.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n---\n# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)\n---\n# Chapter 5: Router\n\nWelcome back to our Flutter routing deep dive! In the previous chapters, we've explored some key players:\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The note telling us where to go and what data is needed.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The sensor that detects external route changes and gives us the `RouteInformation`.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The translator that turns `RouteInformation` into a structured app configuration.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The builder that takes the structured configuration and builds the UI, usually with a `Navigator`.\n\nBut who brings all these pieces together? Who is in charge of the whole routing process, listening to the [RouteInformationProvider](02_routeinformationprovider_.md), using the [RouteInformationParser](03_routeinformationparser_.md), and commanding the [RouterDelegate](04_routerdelegate_.md)?\n\nMeet the `Router` widget!\n\n## What is the Router Widget?\n\nThe `Router` widget is the **central hub** or the **orchestrator** of the Flutter routing system. It's the widget you place in your widget tree that ties together the [RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), and [RouterDelegate](04_routerdelegate_.md).\n\nThink of it as the conductor of an orchestra:\n\n*   It listens to the **[RouteInformationProvider](02_routeinformationprovider_.md)** (like listening to a signal from outside, such as a browser URL change).\n*   It hands that signal ([RouteInformation](01_routeinformation_.md)) to the **[RouteInformationParser](03_routeinformationparser_.md)** (like asking the translator to figure out what the signal means).\n*   It takes the result from the parser (the structured app configuration) and gives it to the **[RouterDelegate](04_routerdelegate_.md)** (like telling the builder exactly what to display).\n*   It also allows the [RouterDelegate](04_routerdelegate_.md) to report its current state and uses the [RouteInformationParser](03_routeinformationparser_.md) to convert that back to [RouteInformation](01_routeinformation_.md) for things like browser history.\n*   It coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) to handle system back button presses by telling the [RouterDelegate](04_routerdelegate_.md) to `popRoute`.\n\nEssentially, the `Router` widget is the glue that makes the Declarative Router system work. It's rarely something you interact with directly *after* setting it up; its job is to manage the delegates you provide.\n\nHere's a simplified flow showing the `Router` in the middle:\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Router as Router Widget\n    participant Parser as RouteInformationParser\n    participant Config as App Configuration\n    participant Delegate as RouterDelegate\n    participant UI as App UI (Navigator/Pages)\n\n    Provider->>Router: New RouteInformation available\n    Router->>Parser: parse(RouteInformation)\n    alt Parser completes\n        Parser-->>Router: Returns Config\n        Router->>Delegate: setNewRoutePath(Config)\n        Delegate-->>Router: Notifies Router (state changed)\n        Router->>Router: setState (Triggers rebuild)\n        Router->>Delegate: build()\n        Delegate-->>UI: Builds/Updates UI\n        Delegate->>Router: currentConfiguration\n        Router->>Parser: restore(Config)\n        Parser-->>Router: Returns RouteInformation\n        Router->>Provider: routerReportsNewRouteInformation(RouteInformation)\n    end\n```\n\nThis diagram shows the core cycle: The provider gets information, gives it to the Router, the Router passes it to the parser, the parser gives back configuration, the Router gives that to the delegate, the delegate updates its state and notifies the Router, the Router tells the delegate to build the UI, and finally, the Router gets the current state back from the delegate to report to the provider (for things like browser history).\n\n## Why Do We Need the Router Widget?\n\nWhile each delegate ([RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), [RouterDelegate](04_routerdelegate_.md), and [BackButtonDispatcher](06_backbuttondispatcher_.md)) has a specific responsibility, they need a manager to coordinate them. The `Router` widget provides this management layer.\n\nIt handles the complex asynchronous interactions (like waiting for the parser to finish) and ensures that when one delegate signals a change (like the provider getting a new route or the delegate's state changing), the correct methods on the other delegates are called in the right order.\n\nSetting up your routing with the `Router` looks like this (using `MaterialApp.router`, which internally uses a `Router` widget):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume this file contains our custom delegates and config\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n\n      // Provide our custom delegates!\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n      // backButtonDispatcher: RootBackButtonDispatcher(), // From Chapter 7\n    );\n  }\n}\n```\n\nHere, you don't explicitly write `Router(...)`, but `MaterialApp.router` is a convenience widget that does it for you. You pass in your custom implementations of the delegates we've discussed. The `MaterialApp.router` (or `WidgetsBinding.builder`) is a common place to set up the root `Router` for your application.\n\nYou *can* create a `Router` widget directly in your tree if you need nested routing, but for a basic app, the one provided by `MaterialApp.router` is usually sufficient.\n\n## How the Router Widget Works (Internal View)\n\nLet's peek inside the `_RouterState` class, which implements the state for the `Router` widget. This is where the connections between the delegates happen.\n\nWe've seen snippets of this in previous chapters, but let's review the core interactions:\n\n1.  **Receiving Route Information:** When the [RouteInformationProvider](02_routeinformationprovider_.md) notifies its listeners (which the `Router` state is), the `_handleRouteInformationProviderNotification` method is called:\n\n    ```dart\n    // Snippet from _RouterState._handleRouteInformationProviderNotification\n    void _handleRouteInformationProviderNotification() {\n      _routeParsePending = true; // Mark that we need to parse\n      _processRouteInformation(\n        widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n        () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n      );\n    }\n    ```\n    This gets the latest [RouteInformation](01_routeinformation_.md) from the provider and calls `_processRouteInformation`.\n\n2.  **Processing Route Information:** The `_processRouteInformation` calls the [RouteInformationParser](03_routeinformationparser_.md):\n\n    ```dart\n    // Snippet from _RouterState._processRouteInformation\n    void _processRouteInformation(\n      RouteInformation information,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter, // How to call the delegate\n    ) {\n      // ... setup ...\n\n      // Call the parser!\n      widget.routeInformationParser!\n          .parseRouteInformationWithDependencies(information, context)\n          .then<void>( // When parsing completes...\n              _processParsedRouteInformation( // ...process the result\n                  _currentRouterTransaction, delegateRouteSetter));\n    }\n    ```\n    This waits for the `parseRouteInformationWithDependencies` future to complete.\n\n3.  **Calling the RouterDelegate:** Once the parser returns the structured configuration (`T`), `_processParsedRouteInformation` is called, which then calls the appropriate setter on the [RouterDelegate](04_routerdelegate_.md) (`setNewRoutePath`, `setInitialRoutePath`, or `setRestoredRoutePath`):\n\n    ```dart\n    // Snippet from _RouterState._processParsedRouteInformation\n    _RouteSetter<T> _processParsedRouteInformation(\n      Object? transaction,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n    ) {\n      return (T data) async { // 'data' is the parsed config\n        // Call the delegate's method!\n        await delegateRouteSetter()(data);\n         // If successful, trigger a rebuild\n        _rebuild();\n      };\n    }\n    ```\n\n4.  **Listening to the RouterDelegate:** The `Router` also listens to the [RouterDelegate](04_routerdelegate_.md). This is set up in `initState`:\n\n    ```dart\n    // Snippet from _RouterState.initState\n    @override\n    void initState() {\n      super.initState();\n      // ... other listeners ...\n      // Listen to the delegate!\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n    }\n    ```\n    And when the delegate calls `notifyListeners()`, `_handleRouterDelegateNotification` runs:\n\n    ```dart\n    // Snippet from _RouterState._handleRouterDelegateNotification\n    void _handleRouterDelegateNotification() {\n      // Rebuild the Router\n      setState(() { /* routerDelegate wants to rebuild */ });\n      // And potentially report the new route information\n      _maybeNeedToReportRouteInformation();\n    }\n    ```\n    This rebuild is what causes the delegate's `build` method to be called, updating the UI. The call to `_maybeNeedToReportRouteInformation` triggers the reverse process (Configuration -> [RouteInformation](01_routeinformation_.md) -> [RouteInformationProvider](02_routeinformationprovider_.md)).\n\n5.  **Handling Back Button:** The `Router` also listens to the [BackButtonDispatcher](06_backbuttondispatcher_.md) (set up in `initState`). When notified, it calls the delegate's `popRoute` method:\n\n    ```dart\n    // Snippet from _RouterState._handleBackButtonDispatcherNotification\n    Future<bool> _handleBackButtonDispatcherNotification() {\n      _currentRouterTransaction = Object(); // Start a new transaction\n      // Call the delegate's popRoute!\n      return widget.routerDelegate.popRoute().then<bool>(\n        _handleRoutePopped(_currentRouterTransaction), // Process the result\n      );\n    }\n    ```\n\nThese internal methods show how the `Router` is constantly listening for changes from the [RouteInformationProvider](02_routeinformationprovider_.md), orchestrating the parsing and delegate updates, and listening back to the [RouterDelegate](04_routerdelegate_.md) and [BackButtonDispatcher](06_backbuttondispatcher_.md) to manage the overall routing state and UI.\n\nThe `build` method of the `Router` simply provides an `InheritedWidget` (`_RouterScope`) so descendant widgets can access the router's delegates (using `Router.of(context)`) and then calls `widget.routerDelegate.build(context)` to get the actual UI tree:\n\n```dart\n// Snippet from _RouterState.build\n@override\nWidget build(BuildContext context) {\n  return UnmanagedRestorationScope(\n    bucket: bucket,\n    child: _RouterScope(\n      // Provides delegates via InheritedWidget\n      routeInformationProvider: widget.routeInformationProvider,\n      bac...tonDispatcher: widget.backButtonDispatcher,\n      ro...InformationParser: widget.routeInformationParser,\n      r...Delegate: widget.routerDelegate,\n      routerState: this,\n      child: Builder(\n        // *** Calls the delegate's build method! ***\n        builder: widget.routerDelegate.build,\n      ),\n    ),\n  );\n}\n```\n\nThis reinforces that the `Router`'s job isn't to build the screen content itself, but to provide the context (via `_RouterScope`) and tell the `RouterDelegate` when and where to build.\n\n## Conclusion\n\nThe `Router` widget is the central figure in Flutter's Declarative Router system. It's the orchestrator that receives route information, delegates the parsing to the [RouteInformationParser](03_routeinformationparser_.md), passes the resulting configuration to the [RouterDelegate](04_routerdelegate_.md) to build the UI, and coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) for back button handling. While you often interact with it indirectly through convenience widgets like `MaterialApp.router`, understanding its role as the connector between all the delegates is key to grasping how the system functions.\n\nIn the next chapter, we'll look closer at the [BackButtonDispatcher](06_backbuttondispatcher_.md), which the `Router` listens to for those important system back button presses.\n\n[Next Chapter: BackButtonDispatcher](06_backbuttondispatcher_.md)\n---\n# Chapter 6: BackButtonDispatcher\n\nWelcome back! In the last five chapters, we've built a good understanding of how Flutter's Declarative Router manages navigation using:\n\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The \"where and what\" note.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The \"sensor\" for external route changes.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The \"translator\" from raw notes to structured app configurations.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The \"builder\" that uses the configuration to show screens, often via a `Navigator`.\n*   [Chapter 5: Router](05_router_.md): The \"orchestrator\" that connects all the delegates.\n\nNow, what about that important system back button? On platforms like Android, users expect the back button to work intuitively \u2013 usually closing the current screen or going back to the previous step. How does our declarative routing system handle this?\n\nThis is where the `BackButtonDispatcher` comes in!\n\n## What is a BackButtonDispatcher?\n\nThink of the `BackButtonDispatcher` as the **system back button listener**. It's a mechanism that receives notifications when the user presses the hardware or software back button provided by the operating system (like on Android phones).\n\nWhen the `BackButtonDispatcher` catches a back button event, it doesn't handle it directly. Instead, its main job is to **forward** this event to the **[Router](05_router_.md)**. The [Router](05_router_.md) then tells the **[RouterDelegate](04_routerdelegate_.md)** to attempt to handle the back action.\n\nThe `BackButtonDispatcher` also supports **nesting**. This means if you have multiple [Router](05_router_.md)s for different parts of your UI (e.g., a main app [Router](05_router_.md) and a separate [Router](05_router_.md) for a flow within a tab), the back button event can be dispatched correctly to the most relevant [Router](05_router_.md) and its delegate.\n\nIts main purposes are:\n\n1.  **Receive System Back Button Events:** Listen for the platform-specific signal that the user wants to go back.\n2.  **Dispatch to the Router:** Notify the **[Router](05_router_.md)** that a back request has occurred.\n3.  **Coordinate Hierarchies:** Allow nested [Router](05_router_.md)s to participate in back button handling.\n\nHere's a simple flow:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant Dispatcher as BackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>Dispatcher: Sends back button event\n    Dispatcher->>Dispatcher: Receives event\n    Dispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>Dispatcher: Returns true/false\n    Dispatcher-->>System: Communicates handling status (affects whether app exits etc.)\n```\n\nThis flow shows that the `BackButtonDispatcher` is the critical first step in the Flutter routing system's response to a back button press.\n\n## Why Do We Need a BackButtonDispatcher?\n\nWithout a `BackButtonDispatcher`, Flutter wouldn't have a standardized way to receive back button events from the underlying operating system. Each platform might signal this differently, and the `BackButtonDispatcher` provides a common interface.\n\nFurthermore, since back button behavior can depend on the current screen and state (which is managed by your `RouterDelegate` in conjunction with a `Navigator`), the `BackButtonDispatcher` is needed to effectively forward this request to the component best equipped to handle it \u2013 your `RouterDelegate`.\n\nIt separates the *detection* of the back button press from the *logic* of what happens when it's pressed, keeping responsibilities clear.\n\n## How to Use a BackButtonDispatcher\n\nYou typically don't build your own custom `BackButtonDispatcher` from scratch for a basic app. Flutter provides standard implementations that you simply provide to your `Router` (or `MaterialApp.router`).\n\nFor the main, top-level `Router` in your app, you'll almost always use the `RootBackButtonDispatcher`. We'll cover `RootBackButtonDispatcher` in more detail in [Chapter 7](07_rootbackbuttondispatcher_.md), but for now, just know that it's the concrete class that listens to the platform's default back button messages.\n\nHere's how you integrate it into your `MaterialApp.router` setup:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the BackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Using the root dispatcher\n\n    );\n  }\n}\n```\n\nBy providing a `RootBackButtonDispatcher` to the `backButtonDispatcher` property, you're telling the `Router` widget: \"Use this object to listen for system back button presses.\"\n\nWhen the user presses the back button, the `RootBackButtonDispatcher` catches it and notifies the `Router`. The `Router` then calls your `RouterDelegate`'s `popRoute` method. As we saw in [Chapter 4](04_routerdelegate_.md), if you use the `PopNavigatorRouterDelegateMixin`, your `popRoute` method will automatically try to pop the top-most page from the `Navigator`.\n\nSo, in essence, providing a `RootBackButtonDispatcher` and using `PopNavigatorRouterDelegateMixin` in your `RouterDelegate` gives you standard back button behavior that pops screens from your primary `Navigator`.\n\n## Internal View (How Flutter Uses It)\n\nLet's see how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) interacts with the `BackButtonDispatcher`.\n\nThe `Router`'s internal state (`_RouterState`) registers itself as a listener with the `BackButtonDispatcher` in its `initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router registers as a listener to the back button dispatcher!\n  widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n  // ... rest of initState ...\n}\n```\n\nThis means when the `BackButtonDispatcher` receives a back button event and calls its `invokeCallback` method, the `_handleBackButtonDispatcherNotification` method in the `_RouterState` will be executed.\n\nWhat does `_handleBackButtonDispatcherNotification` do? It's responsible for telling the **[RouterDelegate](04_routerdelegate_.md)** to handle the pop request:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  // Create a new transaction object (used internally to track simultaneous requests)\n  _currentRouterTransaction = Object();\n  // *** Call the delegate's popRoute method! ***\n  return widget.routerDelegate.popRoute().then<bool>(\n    // Process the result from popRoute (true/false)\n    _handleRoutePopped(_currentRouterTransaction),\n  );\n}\n```\n\nLet's break this down:\n\n1.  When the `BackButtonDispatcher` notifies the `Router`, `_handleBackButtonDispatcherNotification` is called.\n2.  Crucially, it calls `widget.routerDelegate.popRoute()`. This redirects the responsibility of handling the back action to the `RouterDelegate`.\n3.  The `RouterDelegate`'s `popRoute` method (which, with `PopNavigatorRouterDelegateMixin`, calls `Navigator.maybePop()`) attempts to handle the back event. It returns a `Future<bool>`: `true` if it successfully popped something, `false` otherwise.\n4.  The `.then<bool>` structure waits for this `Future<bool>` to complete. The result (`true` or `false`) is then passed to `_handleRoutePopped`.\n\nThe `_handleRoutePopped` method simply processes the result:\n\n```dart\n// Snippet from _RouterState._handleRoutePopped\n_AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n  return (bool data) { // 'data' is the true/false result from popRoute()\n    if (transaction != _currentRouterTransaction) {\n      // If a new transaction started while we were waiting for popRoute,\n      // assume this pop was handled to avoid unwanted bubbling.\n      return SynchronousFuture<bool>(true);\n    }\n    // Trigger a rebuild of the Router (which calls the delegate's build)\n    _rebuild();\n    // Return the actual result (true/false) so the dispatcher knows if it was handled\n    return SynchronousFuture<bool>(data);\n  };\n}\n```\n\nThis method:\n\n1.  Receives the boolean result `data` from the `RouterDelegate.popRoute()`.\n2.  If the pop was handled (`data` is `true`), it calls `_rebuild()`, which causes the `Router` to rebuild, reflecting the popped page (e.g., the `Navigator` with one less page).\n3.  It returns the `data` result (`true` or `false`) back up the chain. This result goes back to the `BackButtonDispatcher`, which can use it to signal to the platform whether the event was fully handled by Flutter (preventing the OS from, say, closing the entire app).\n\nThese internal steps illustrate how the `BackButtonDispatcher` acts as the initial trigger for back button handling, forwarding the request to the **[Router](05_router_.md)**, which then relies on the **[RouterDelegate](04_routerdelegate_.md)** to perform the actual logic.\n\n## Conclusion\n\nThe `BackButtonDispatcher` is the abstraction responsible for catching system back button presses and initiating the backward navigation process within your Flutter app's routing system. It acts as a listener for platform-specific back events and effectively notifies the **[Router](05_router_.md)**, which then directs the responsibility to the **[RouterDelegate](04_routerdelegate_.md)**'s `popRoute` method. By using a `RootBackButtonDispatcher` at the top level of your app and implementing `popRoute` (often with the help of `PopNavigatorRouterDelegateMixin`), you ensure that the system back button interacts correctly with your app's navigation stack.\n\nIn the next two chapters, we'll look closer at the common implementations: [RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md) and [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md).\n\n[Next Chapter: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)\n---\n# Chapter 7: RootBackButtonDispatcher\n\nWelcome back! In the last chapter, we learned about the [BackButtonDispatcher](06_backbuttondispatcher_.md), the mechanism that listens for system back button presses and forwards them to the [Router](05_router_.md). We saw that it's how Flutter handles those important \"go back\" requests from the operating system, especially on platforms like Android.\n\nNow, we're going to look at a specific and very common type of [BackButtonDispatcher](06_backbuttondispatcher_.md): the `RootBackButtonDispatcher`.\n\n## What is a RootBackButtonDispatcher?\n\nThink of the `RootBackButtonDispatcher` as the **primary listener for system back buttons for your app's main navigation**. It's the one that sits at the highest level of your routing setup and is the first to hear when the user presses the device's back button.\n\nIts main job is simple:\n\n1.  **Listen to the Platform:** It registers with the underlying operating system to receive notifications whenever the global \"pop route\" event occurs (which happens when the user presses the back button).\n2.  **Notify the Router:** When it receives such a notification, it immediately tells the **[Router](05_router_.md)** it's associated with that a back request has happened.\n\nIt doesn't decide *what* happens when the back button is pressed; that's the job of the [RouterDelegate](04_routerdelegate_.md). The `RootBackButtonDispatcher` is solely responsible for *detecting* the system event and ensuring the top-level [Router](05_router_.md) is informed.\n\nIt's called \"Root\" because it's intended for the main, un-nested [Router](05_router_.md) at the root of your application's navigation hierarchy.\n\nHere's the flow we saw in [Chapter 6](06_backbuttondispatcher_.md), specifically with the `RootBackButtonDispatcher`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant RootDispatcher as RootBackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>RootDispatcher: Sends back button event\n    RootDispatcher->>RootDispatcher: Receives event\n    RootDispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>RootDispatcher: Returns true/false\n    RootDispatcher-->>System: Communicates handling status\n```\n\n## Why Do We Use a RootBackButtonDispatcher?\n\nFor most standard Flutter applications using the declarative router, you need *one* object that is responsible for catching the system back button event at the highest level. The `RootBackButtonDispatcher` is the built-in, standard way to achieve this.\n\nIf you don't provide any [BackButtonDispatcher](06_backbuttondispatcher_.md) to your root [Router](05_router_.md) (like the one managed by `MaterialApp.router`), system back button presses might not be handled correctly by your declarative routing system. You need an object connected to the `Router` that is specifically listening for these events.\n\nUsing `RootBackButtonDispatcher` gives you:\n\n*   **Standard Platform Integration:** It knows how to hook into the platform's native back button events.\n*   **Initial Back Button Handling Trigger:** It serves as the starting point for the back button event processing chain (RootDispatcher -> [Router](05_router_.md) -> [RouterDelegate](04_routerdelegate_.md)).\n\n## How to Use RootBackButtonDispatcher\n\nAs we briefly saw in the previous chapter, using `RootBackButtonDispatcher` is straightforward. You instantiate it and provide it to the `backButtonDispatcher` property of your main `Router` widget. Since `MaterialApp.router` creates the main `Router` for you, you provide it there:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the RootBackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Simple instantiation\n\n    );\n  }\n}\n```\n\nThat's it! You don't need to configure the `RootBackButtonDispatcher` any further for basic usage. By passing `RootBackButtonDispatcher()` to the `backButtonDispatcher` property, you are giving the `Router` the listener it needs to react to system back button pushes.\n\nThe `RootBackButtonDispatcher` itself doesn't require any arguments or complex setup for this purpose. It simply plugs into the platform's back button event system.\n\nRemember from [Chapter 4](04_routerdelegate_.md) that your `MyAppRouterDelegate` should implement the `popRoute` method (usually by mixing in `PopNavigatorRouterDelegateMixin`) for the back button press to actually do something like pop a screen from a `Navigator`. The `RootBackButtonDispatcher` just gets the event to the `Router`, and the `Router` passes it to the delegate's `popRoute`.\n\n## Internal View (How Flutter Uses RootBackButtonDispatcher)\n\nLet's dive a little deeper into the code to see how `RootBackButtonDispatcher` achieves its goal.\n\nThe `RootBackButtonDispatcher` class inherits from the base `BackButtonDispatcher` and also `WidgetsBindingObserver`:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  // ... methods below ...\n}\n```\nBy mixing in `WidgetsBindingObserver`, the `RootBackButtonDispatcher` can listen to system events delivered via the `WidgetsBinding.instance`.\n\nWhen the `Router` associated with this dispatcher starts up, it calls `addCallback` on the `RootBackButtonDispatcher` (as we saw in [Chapter 6](06_backbuttondispatcher_.md)'s internal view).\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (_RouterState.initState)\nwidget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n```\n\nThe `RootBackButtonDispatcher` overrides the `addCallback` method to start listening to the `WidgetsBinding` if it's the first callback being added:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid addCallback(ValueGetter<Future<bool>> callback) {\n  if (!hasCallbacks) { // hasCallbacks comes from the base BackButtonDispatcher\n    WidgetsBinding.instance.addObserver(this); // Starts listening to platform events!\n  }\n  super.addCallback(callback); // Add the provided callback (from the Router)\n}\n```\n\nThis `WidgetsBinding.instance.addObserver(this)` call is key. It registers the `RootBackButtonDispatcher` instance to receive important system event notifications, including `didPopRoute`.\n\nWhen the user presses the system back button, the Flutter engine on the platform side catches it and signals the framework through `WidgetsBinding`. This triggers the `didPopRoute` method *on the registered observer* (our `RootBackButtonDispatcher` instance):\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nFuture<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n```\n\nHere's what happens in `didPopRoute`:\n\n1.  It calls `invokeCallback`. This method, inherited from the base `BackButtonDispatcher`, is designed to call the callbacks that have been `addCallback`-ed to it.\n2.  As we saw earlier, the `Router` added a callback (`_handleBackButtonDispatcherNotification`) that triggers the `routerDelegate.popRoute()`.\n3.  So, the `didPopRoute` call effectively results in our `Router`'s `_handleBackButtonDispatcherNotification` being executed, which in turn calls our custom `RouterDelegate`'s `popRoute` method.\n4.  The result of `routerDelegate.popRoute()` (true/false future) is then returned by `invokeCallback` and subsequently by `didPopRoute`. This result goes back to the `WidgetsBinding`, indicating whether Flutter handled the pop request internally or if the underlying platform should proceed with its default behavior (like closing the app).\n\nThe `removeCallback` method in `RootBackButtonDispatcher` does cleanup, removing the observer if no more callbacks are listening:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid removeCallback(ValueGetter<Future<bool>> callback) {\n  super.removeCallback(callback);\n  if (!hasCallbacks) {\n    WidgetsBinding.instance.removeObserver(this); // Stop listening to platform events\n  }\n}\n```\n\nThis internal structure shows that the `RootBackButtonDispatcher` is a specialized `BackButtonDispatcher` that uses `WidgetsBindingObserver` to be the initial point of contact for system back button events, forwarding them through the generic `invokeCallback` mechanism to the registered listeners (the `Router`).\n\n## Conclusion\n\nThe `RootBackButtonDispatcher` is the standard, top-level component for receiving system back button presses in Flutter's declarative routing system. By providing an instance of `RootBackButtonDispatcher` to your root `Router`, you ensure that the system back button events are caught and properly dispatched to your `RouterDelegate`'s `popRoute` method for handling (typically popping a screen from a `Navigator`). It acts as the crucial bridge between the platform's back button mechanism and your application's routing logic.\n\nIn the next chapter, we'll look at the [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md), which is used when you have nested `Router`s and need more fine-grained control over which part of your UI handles the back button.\n\n[Next Chapter: ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 8: ChildBackButtonDispatcher\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 8: ChildBackButtonDispatcher\n\nWelcome back! Over the past seven chapters, we've journeyed through the core components of Flutter's Declarative Router system, covering everything from the \"note\" ([Chapter 1: RouteInformation](01_routeinformation_.md)) to the \"orchestrator\" ([Chapter 5: Router](05_router_.md)) and the \"system back button listener\" ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) and [Chapter 7: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)).\n\nYou learned that the `RootBackButtonDispatcher` is essential for catching global system back button presses and sending them to your *main* [Router](05_router_.md). But what if your app has a more complex layout?\n\n## Why Nested Routers Need ChildBackButtonDispatcher\n\nImagine your app has a main screen with a tab bar at the bottom. Each tab has its own separate navigation flow. For instance:\n\n*   **Tab A:** A list of items -> Item Detail -> Another sub-page.\n*   **Tab B:** User profile -> Edit profile.\n*   **Tab C:** Settings.\n\n```mermaid\ngraph TD\n    A[App Root (Router)] --&gt; B[Main Screen (Tab Bar)]\n    B --&gt; C{Tab A}\n    B --&gt; D{Tab B}\n    B --&gt; E{Tab C}\n    C --&gt; F[Item List]\n    F --&gt; G[Item Detail]\n    D --&gt; H[Profile]\n    H --&gt; I[Edit Profile]\n```\n\nIn this setup, you might use a separate [Router](05_router_.md) and [RouterDelegate](04_routerdelegate_.md) *within each tab*. This allows each tab to manage its own navigation stack independently.\n\nNow, consider the user pressing the system back button. What should happen?\n\n*   If they are deep inside **Tab A**'s detail page, you likely want the back button to pop *within Tab A*.\n*   Only if they are at the root of **Tab A** (the item list) should the back button switch tabs or potentially go back from the main screen.\n\nThe `RootBackButtonDispatcher` sends the back event to the *main* [Router](05_router_.md) at the top of your app. But that main [Router](05_router_.md) doesn't know which tab is currently active or which nested [Router](05_router_.md) should handle the pop request.\n\nThis is the problem the `ChildBackButtonDispatcher` solves!\n\n## What is a ChildBackButtonDispatcher?\n\nA `ChildBackButtonDispatcher` is a type of [BackButtonDispatcher](06_BackButtonDispatcher.md) designed specifically for **nested [Router](05_router.md)s**. Instead of listening to the platform directly like the `RootBackButtonDispatcher`, it listens to a *parent* [BackButtonDispatcher](06_BackButtonDispatcher.md).\n\nIts core responsibilities are:\n\n1.  **Listen to a Parent:** It receives back button notifications from the [BackButtonDispatcher](06_BackButtonDispatcher.md) higher up in the hierarchy (usually the `RootBackButtonDispatcher` or another `ChildBackButtonDispatcher`).\n2.  **Connect to a Child Router:** It's associated with a specific nested [Router](05_router.md).\n3.  **Claim Priority:** It can signal to its parent that its associated nested [Router](05_router.md) is currently active and *should* be given the *first chance* to handle any incoming back button notifications.\n4.  **Dispatch to the Child Router:** If its parent gives it priority, it forwards the back button notification to its associated nested [Router](05_router.md) (which then calls its nested [RouterDelegate](04_routerdelegate_.md)'s `popRoute` method).\n\nThink of the `ChildBackButtonDispatcher` as a representative for its nested [Router](05_router.md), telling the back button system: \"Hey, my section of the UI is currently focused, send the back events here first!\"\n\nHere's the flow with nested dispatchers:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant RootDispatcher as RootBackButtonDispatcher (Parent)\n    participant ChildDispatcherA as ChildBackButtonDispatcher (for Tab A)\n    participant ChildDispatcherB as ChildBackButtonDispatcher (for Tab B)\n    participant ActiveChildDispatcher as Currently Active ChildDispatcher (e.g. ChildDispatcherA)\n    participant NestedRouter as Nested Router (e.g. for Tab A)\n    participant NestedDelegate as Nested RouterDelegate\n\n    User->>System: Presses back button\n    System->>RootDispatcher: Back button event\n    RootDispatcher->>ActiveChildDispatcher: Notifies active child\n    ActiveChildDispatcher->>NestedRouter: Notifies associated Router\n    NestedRouter->>NestedDelegate: Calls popRoute()\n    NestedDelegate-->>NestedRouter: Returns true/false (handled?)\n    NestedRouter-->>ActiveChildDispatcher: Returns true/false\n    ActiveChildDispatcher-->>RootDispatcher: Returns true/false\n    alt Handled by Active Child (returns true)\n        RootDispatcher-->>System: Reports back button handled\n    else Not Handled by Active Child (returns false)\n        RootDispatcher->>RootDispatcher: Asks its own listeners (e.g., its RouterDelegate)\n        RootDispatcher-->>System: Reports handling status\n    end\n```\n\nThis diagram illustrates that the `RootBackButtonDispatcher` is the initial receiver, but it then checks with its \"children\" (the `ChildBackButtonDispatcher`s that have claimed priority) to see who should handle the event first.\n\n## How to Use ChildBackButtonDispatcher\n\nTo use a `ChildBackButtonDispatcher`, you need two things:\n\n1.  **A Parent Dispatcher:** This will be the [BackButtonDispatcher](06_BackButtonDispatcher.md) of the [Router](05_router.md) widget higher up in the tree (usually the `RootBackButtonDispatcher` of your main app [Router](05_router.md)). You can get this using `Router.of(context).backButtonDispatcher`.\n2.  **A Child Router:** The `ChildBackButtonDispatcher` will be provided to the `backButtonDispatcher` property of your nested [Router](05_router.md).\n\nLet's sketch out how you might set this up for a tabbed interface, assuming you have a main `MaterialApp.router` and then a `Router` inside each tab's content widget.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume custom delegates for tabs\n\n// Assume MyAppRouterDelegate implements routing for the main app (e.g., showing tabs)\n// Assume MyAppRouteInformationParser handles parsing main paths (e.g., /tab_a)\n\n// Assume you have separate delegates and parsers for each tab's routing\n// Example: TabARouterDelegate, TabARouteInformationParser, TabAConfig\n\nclass MainScreenWithTabs extends StatefulWidget {\n  // ... constructor and state management for current tab ...\n  final int currentTab; // Assume this state exists\n  const MainScreenWithTabs({super.key, required this.currentTab});\n\n  @override\n  State<MainScreenWithTabs> createState() => _MainScreenWithTabsState();\n}\n\nclass _MainScreenWithTabsState extends State<MainScreenWithTabs> {\n   // We need separate delegates and parsers for each tab's *nested* router\n   // Their configurations would be different from the main app config\n   late final TabARouterDelegate _tabARouterDelegate;\n   late final TabARouteInformationParser _tabARouteInformationParser;\n    late final TabBRouterDelegate _tabBRouterDelegate;\n   late final TabBRouteInformationParser _tabBRouteInformationParser;\n\n   @override\n   void initState() {\n       super.initState();\n       _tabARouterDelegate = TabARouterDelegate();\n       _tabARouteInformationParser = TabARouteInformationParser();\n       _tabBRouterDelegate = TabBRouterDelegate();\n       _tabBRouteInformationParser = TabBRouteInformationParser();\n   }\n\n   @override\n   void dispose() {\n       _tabARouterDelegate.dispose();\n       _tabBRouterDelegate.dispose();\n       super.dispose();\n   }\n\n  @override\n  Widget build(BuildContext context) {\n    // Get the parent BackButtonDispatcher (from the main app Router)\n    final BackButtonDispatcher parentBackButtonDispatcher =\n        Router.of(context).backButtonDispatcher!;\n\n    // Create a ChildBackButtonDispatcher for each tab's future Router\n    final ChildBackButtonDispatcher tabABackButtonDispatcher =\n        parentBackButtonDispatcher.createChildBackButtonDispatcher();\n    final ChildBackButtonDispatcher tabBBackButtonDispatcher =\n        parentBackButtonDispatcher.createChildBackButtonDispatcher();\n\n    // *** Important: Tell the currently active tab's dispatcher to take priority! ***\n    // This is usually done whenever the tab selection changes.\n    // For simplicity here, we'll do it based on the current tab index in build.\n    // A real implementation might do this in a state change callback.\n    if (widget.currentTab == 0) {\n        tabABackButtonDispatcher.takePriority();\n    } else if (widget.currentTab == 1) {\n        tabBBackButtonDispatcher.takePriority();\n    }\n    // Tab C might not have a nested router, or claim priority only when a specific view is shown.\n\n    Widget tabContent;\n    if (widget.currentTab == 0) {\n      tabContent = Router<TabAConfig>( // Nested Router for Tab A\n        routerDelegate: _tabARouterDelegate,\n        routeInformationParser: _tabARouteInformationParser,\n        // *** Provide the ChildBackButtonDispatcher to the nested Router! ***\n        backButtonDispatcher: tabABackButtonDispatcher,\n      );\n    } else if (widget.currentTab == 1) {\n       tabContent = Router<TabBConfig>( // Nested Router for Tab B\n        routerDelegate: _tabBRouterDelegate,\n        routeInformationParser: _tabBRouteInformationParser,\n         // *** Provide the ChildBackButtonDispatcher to the nested Router! ***\n        backButtonDispatcher: tabBBackButtonDispatcher,\n      );\n    } else {\n       tabContent = Center(child: Text('Settings Tab')); // Tab C - no nested router needed here\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('App with Tabs')),\n      body: tabContent, // Show the content of the current tab\n      bottomNavigationBar: BottomNavigationBar(\n         currentIndex: widget.currentTab,\n         onTap: (index) { /* Update widget.currentTab state and rebuild */}\n         // ... items for tabs ...\n      ),\n    );\n  }\n}\n```\n\nBreaking down the key parts of using `ChildBackButtonDispatcher`:\n\n1.  **Get the Parent:** `Router.of(context).backButtonDispatcher!` retrieves the `BackButtonDispatcher` from the nearest ancestor [Router](05_router.md) (in this case, the main app [Router](05_router.md) set up by `MaterialApp.router`). We use `!` assuming the main router *has* a dispatcher (like `/ RootBackButtonDispatcher`).\n2.  **Create Children:** `parentBackButtonDispatcher.createChildBackButtonDispatcher()` is the method on the parent where you create instances of `ChildBackButtonDispatcher` that are linked to this parent.\n3.  **Provide to Nested Router:** Each `ChildBackButtonDispatcher` is then given to the `backButtonDispatcher` property of the specific nested [Router](05_router.md) it manages.\n4.  **Claim Priority (`takePriority()`):** This is arguably the most important step for nested routers. When a nested [Router](05_router.md)'s content becomes the user's *focus* (e.g., when a user switches tabs), you must call `takePriority()` on that nested [Router](05_router.md)'s `ChildBackButtonDispatcher`. This tells the parent dispatcher: \"If a back button event comes in, ask *me* first before anyone else (or before handling it yourself).\"\n\nWhen the user presses the back button:\n\n*   The event is first caught by the `RootBackButtonDispatcher`.\n*   The `RootBackButtonDispatcher` checks if any of its `ChildBackButtonDispatcher`s have called `takePriority()` most recently.\n*   If the `ChildBackButtonDispatcher` for the currently active tab (e.g., Tab A) called `takePriority()`, the `RootBackButtonDispatcher` forwards the back request to *that* `ChildBackButtonDispatcher`.\n*   That `ChildBackButtonDispatcher` then notifies its associated nested [Router](05_router.md).\n*   The nested [Router](05_router.md) calls its nested [RouterDelegate](04_routerdelegate_.md)'s `popRoute()` method.\n*   If the nested [RouterDelegate](04_routerDelegate_.md) (e.g., for Tab A) successfully pops a screen from its `Navigator`, its `popRoute()` returns `Future.value(true)`.\n*   This `true` bubbles back up through the `ChildBackButtonDispatcher` to the `RootBackButtonDispatcher`, signaling that the back event was fully handled internally. The OS default pop (like closing the app) is then prevented.\n*   If the nested [RouterDelegate](04_routerDelegate_.md)'s `popRoute()` returns `Future.value(false)` (meaning the nested tab's `Navigator` couldn't pop anything because it was already at its root), the `ChildBackButtonDispatcher` also returns `false` to the `RootBackButtonDispatcher`.\n*   The `RootBackButtonDispatcher` then proceeds to ask its *own* listeners (which include the main app [Router](05_router.md)'s primary listener, which would call the main app [RouterDelegate](04_routerDelegate_.md)'s `popRoute`). This would allow the main app [RouterDelegate](04_routerDelegate_.md) to handle the back press, perhaps by changing tabs or exiting the app.\n\nThis priority system ([deferTo](https://api.flutter.dev/flutter/widgets/BackButtonDispatcher/deferTo.html) and [takePriority](https://api.flutter.dev/flutter/widgets/BackButtonDispatcher/takePriority.html)) managed by the parent and child dispatchers is what makes nested back button handling work correctly.\n\nA common helper widget is [BackButtonListener](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html). This widget automatically creates a `ChildBackButtonDispatcher` linked to the nearest ancestor [Router](05_router.md)'s dispatcher and calls `takePriority()` when the widget is first built. It also handles removing itself when it's disposed. This is useful if you just need a specific widget *deeper* in the tree (not a whole nested `Router`) to temporarily handle back button presses.\n\n## Internal View (How Flutter Uses ChildBackButtonDispatcher)\n\nLet's look at some code snippets from `packages/flutter/lib/src/widgets/router.dart` to see how `ChildBackButtonDispatcher` works with its parent.\n\nRecall in [Chapter 6](06_backbuttondispatcher_.md), we saw the base `BackButtonDispatcher` has an `invokeCallback` method and keeps a list of potential children that might take priority (`_children`).\n\nThe `RootBackButtonDispatcher`'s `didPopRoute` method (which catches the native back event) simply calls `invokeCallback`:\n\n```dart\n// Snippet from RootBackButtonDispatcher\n@override\nFuture<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n```\n\nThe base `BackButtonDispatcher.invokeCallback` method is where the child prioritization logic lives:\n\n```dart\n// Snippet from BackButtonDispatcher.invokeCallback\n@override\nFuture<bool> invokeCallback(Future<bool> defaultValue) {\n  if (_children.isNotEmpty) { // Check if there are children that claimed priority\n    final List<ChildBackButtonDispatcher> children = _children.toList();\n    int childIndex = children.length - 1; // Start with the most recent child\n\n    Future<bool> notifyNextChild(bool result) {\n      if (result) { // If the previous child handled it (returned true)\n        return SynchronousFuture<bool>(result); // Stop and return true\n      }\n      // If not handled, go to the next child in the priority list (backwards)\n      if (childIndex > 0) {\n        childIndex -= 1;\n        // *** Recursively call notifiedByParent on the child ***\n        return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n      }\n      // No children handled it, call the parent's own callbacks\n      return super.invokeCallback(defaultValue);\n    }\n    // Start the process by asking the latest child\n    return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n  }\n  // No children claimed priority, call the parent's own callbacks\n  return super.invokeCallback(defaultValue);\n}\n```\n\nThis shows the delegation:\n1.  `invokeCallback` checks if there are prioritized children (`_children`).\n2.  If yes, it starts a chain, calling `notifiedByParent` on the most recently prioritized child.\n3.  If that child's `notifiedByParent` returns `false` (didn't handle it), it moves to the *next* child in the priority list and calls its `notifiedByParent`, and so on.\n4.  If any child returns `true`, the chain stops, and `true` is returned all the way up.\n5.  If *no* children handle it (all return `false`), the `invokeCallback` finally calls `super.invokeCallback(defaultValue)`, which triggers the parent's own registered callbacks (like the one from the `Router` itself, which calls its `RouterDelegate.popRoute`).\n\nNow, let's look at the `ChildBackButtonDispatcher`. Its key method is `notifiedByParent`:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.notifiedByParent\n@protected\nFuture<bool> notifiedByParent(Future<bool> defaultValue) {\n  // A child dispatcher simply calls its OWN invokeCallback.\n  // Its own callbacks are the ones added by the nested Router it's linked to.\n  return invokeCallback(defaultValue);\n}\n```\n\nThis method is simple: when the parent `BackButtonDispatcher` calls `notifiedByParent` on a `ChildBackButtonDispatcher`, the child simply calls *its own* `invokeCallback`. As we know, a `BackButtonDispatcher`'s `invokeCallback` calls the registered callbacks (which is the nested [Router](05_router.md)'s callback that triggers its [RouterDelegate](04_routerDelegate_.md).popRoute()). This completes the chain of delegation.\n\nThe `takePriority` method in `ChildBackButtonDispatcher` does two things:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.takePriority\n@override\nvoid takePriority() {\n  // Tell the parent to defer to THIS child\n  parent.deferTo(this);\n  // Clear this child's own inner children (if it had any)\n  super.takePriority();\n}\n```\n\n1.  `parent.deferTo(this)`: This is how the child tells the parent to add it to the parent's `_children` list. This marks this child dispatcher as one that should be checked when the parent receives a back event. If called multiple times, `deferTo` moves the child to the end of the parent's priority list, making it the *most recent* and hence the *first* to be checked.\n2.  `super.takePriority()`: This clears the `_children` list *within* this specific `ChildBackButtonDispatcher`. This ensures that this dispatcher prioritizes its *own* callbacks (those added by its associated nested [Router](05_router.md)) over any children *it* might have (relevant for deeply nested structures).\n\nFinally, the `removeCallback` in `ChildBackButtonDispatcher` ensures cleanup. When the nested [Router](05_router.md) or the widget using a [BackButtonListener](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html) is disposed, it removes its callback from the `ChildBackButtonDispatcher`. If the `ChildBackButtonDispatcher` then has no more callbacks (meaning its associated nested part of the UI is gone), it automatically tells its parent to \"forget\" about it:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.removeCallback\n@override\nvoid removeCallback(ValueGetter<Future<bool>> callback) {\n  super.removeCallback(callback);\n  if (!hasCallbacks) { // If no callbacks are left on this child dispatcher\n    parent.forget(this); // Tell the parent to remove this child from its priority list\n  }\n}\n```\n\nThis `parent.forget(this)` call is how the parent `BackButtonDispatcher` knows that a child is no longer active and shouldn't be considered for back button priority anymore.\n\nThese internal workings show the elegant delegation pattern: the `RootBackButtonDispatcher` starts the process, which cascades down through `ChildBackButtonDispatcher`s that have claimed priority. The first one able to handle the pop (by its associated [RouterDelegate](04_routerDelegate_.md) returning `true`) stops the cascade.\n\n## Conclusion\n\nThe `ChildBackButtonDispatcher` is essential for managing back button behavior in apps with nested routing. It doesn't listen to the platform directly but instead connects to a parent [BackButtonDispatcher](06_BackButtonDispatcher.md). By calling `takePriority()`, a `ChildBackButtonDispatcher` signals its associated nested [Router](05_router.md) should be given the opportunity to handle back button events first. This mechanism ensures that back presses are directed to the most relevant part of your UI hierarchy, allowing for intuitive navigation within complex layouts like tabbed interfaces.\n\nIn the next chapter, we'll look at the [PopNavigatorRouterDelegateMixin](09_popnavigatorrouterdelegatemixin_.md), a very common helper mixin for `RouterDelegate`s that simplifies integrating back button handling with a `Navigator`.\n\n[Next Chapter: PopNavigatorRouterDelegateMixin](09_popnavigatorrouterdelegatemixin_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"PopNavigatorRouterDelegateMixin\n\". This is Chapter 9.\n\nConcept Details:\n- Name: PopNavigatorRouterDelegateMixin\n\n- Description:\nThis is a helper for RouterDelegates that build a Navigator. By mixing this in, the RouterDelegate can easily handle back button events by telling the Navigator to try and pop the current screen. This simplifies hooking up the back button to the standard navigation behavior.\n\n\nComplete Tutorial Structure:\n1. [RouteInformation\n](01_routeinformation_.md)\n2. [RouteInformationProvider\n](02_routeinformationprovider_.md)\n3. [RouteInformationParser\n](03_routeinformationparser_.md)\n4. [RouterDelegate\n](04_routerdelegate_.md)\n5. [Router\n](05_router_.md)\n6. [BackButtonDispatcher\n](06_backbuttondispatcher_.md)\n7. [RootBackButtonDispatcher\n](07_rootbackbuttondispatcher_.md)\n8. [ChildBackButtonDispatcher\n](08_childbackbuttondispatcher_.md)\n9. [PopNavigatorRouterDelegateMixin\n](09_popnavigatorrouterdelegatemixin_.md)\n\nContext from previous chapters:\n# Chapter 1: RouteInformation\n\nWelcome to the first chapter of our Flutter routing tutorial! In this chapter, we'll start by exploring a fundamental concept called `RouteInformation`.\n\nImagine you have a mobile app with different screens, like a home screen, a settings screen, and a profile screen. When you navigate between these screens, your app needs to know where it's going and sometimes, it needs extra details about where it's landing. This is where `RouteInformation` comes in!\n\n## What is RouteInformation?\n\nThink of `RouteInformation` as a special note that your app uses to keep track of its location and any important information about that location.\n\nIt contains two main things:\n\n1.  **Location:** This is like the 'address' of where you are in the app. On the web, this is often the URL (like `myapp.com/settings`). In a mobile app, it represents a specific screen or view you want to show.\n2.  **State:** This is like extra notes or details about that location. For example, if you're on a profile page, the state might include the user's ID so the page knows which profile to display. If you're on a screen with a search bar, the state might hold the text the user typed in.\n\nEssentially, `RouteInformation` is a bundle of information that describes a specific point or configuration within your application.\n\n## Why Do We Need RouteInformation?\n\nConsider a simple use case: building an app that shows a list of items, and when you tap an item, it takes you to a detail page for that item.\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant App as My Awesome App\n    participant ListScreen\n    participant DetailScreen\n\n    User->>App: Opens app\n    App->>ListScreen: Shows list of items\n    User->>ListScreen: Taps on onItem 1\n    ListScreen->>App: Wants to show detail for Item 1\n    App->>DetailScreen: Show detail for Item 1\n```\n\nTo show the detail screen, the app needs to know *which* item's details to show. It can't just say \"go to the detail screen.\" It needs that extra information to configure the detail screen correctly. This is where `RouteInformation` is useful. The \"note\" for the detail screen route would include both the location (the detail screen) and the state (the ID of the item).\n\n## How Does it Work? (A Simple View)\n\nWe'll dive into the concepts that use `RouteInformation` in later chapters ([Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md), [Chapter 3: RouteInformationParser](03_routeinformationparser_.md), and [Chapter 4: RouterDelegate](04_routerdelegate_.md)), but for now, think of it like this:\n\n1.  Something triggers a change in the app's desired location (e.g., user taps a button, the app starts up).\n2.  A `RouteInformation` object is created, containing the new location and any relevant state.\n3.  This `RouteInformation` note is then passed around to different parts of the routing system to figure out what screen to show and how to configure it.\n\nLet's look at how `RouteInformation` is defined in Flutter's code.\n\n```dart\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\nclass RouteInformation {\n  /// Creates a route information object.\n  const RouteInformation({\n    String? location, // Deprecated, use uri instead\n    Uri? uri, // The location (like a web address)\n    this.state, // Extra details for this location\n  });\n\n  final String? _location; // Internal storage for the old location string\n\n  /// The uri location of the application.\n  Uri get uri {\n     // Logic to get the URI, using the provided uri or parsing the location\n     // ...\n  }\n\n  final Uri? _uri; // Internal storage for the URI\n\n  /// The state of the application in the [uri].\n  final Object? state;\n}\n```\n\nAs you can see, the `RouteInformation` class has a `uri` property (which is the modern way to represent the location) and a `state` property where you can store extra data.\n\nHere's how you might create a `RouteInformation` object for our item detail use case:\n\n```dart\n// Imagine item ID is 123\nint itemId = 123;\n\n// Create the route information\nRouteInformation itemDetailRoute = RouteInformation(\n  uri: Uri.parse('/items/$itemId'), // Location: /items/123\n  state: {'itemId': itemId}, // State: Store the item ID\n);\n```\n\nIn this simplified example, we create a `RouteInformation` object. The `uri` `/items/123` tells us *where* we want to go (the item detail page for item 123), and the `state` map `{ 'itemId': 123 }` provides the specific detail needed at that location (the ID of the item).\n\nThis `RouteInformation` object is a crucial piece of data that the rest of the routing system will use to render the correct details for Item 123.\n\n## Internal View (How Flutter Uses It)\n\nFlutter's internal routing system uses `RouteInformation` as a common format for communicating routing changes. When something triggers a route change (like the user tapping a button or the browser URL changing), the system often generates a `RouteInformation` object. This object is then processed by other parts of the routing system to update the UI.\n\nIt's important to understand that `RouteInformation` itself doesn't *make* anything happen on screen. It's just the *information* about the desired state. Other components will read this information and act on it. We'll cover these components in the next chapters.\n\nThe provided code snippets show how the central `Router` widget internally uses `RouteInformation`. For example, the `_processRouteInformation` method processes an incoming `RouteInformation` object:\n\n```dart\n// Snippet from Router's internal State\nvoid _processRouteInformation(\n  RouteInformation information, // The incoming RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to set the delegate's route\n) {\n  // ... asserts and setup ...\n\n  // Use the routeInformationParser (explained in Chapter 3)\n  // to turn the RouteInformation into a configuration (T)\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet shows that when the `Router` gets a `RouteInformation`, it uses something called a `RouteInformationParser` to understand the information and turn it into a structured `configuration` that the app's logic can understand.\n\nAnother part of the `Router`'s internal state shows how it reports changes back using `RouteInformation`:\n\n```dart\n// Snippet from Router's internal State\nvoid _reportRouteInformation(Duration timestamp) {\n  if (!mounted) {\n    return;\n  }\n  // ... asserts ...\n\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    // Calls the RouteInformationProvider (explained in Chapter 2)\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nHere, after the app's state changes and the `Router` rebuilds, it retrieves the *current* `RouteInformation` (using the `routerDelegate`, explained in Chapter 4) and reports it back using the `RouteInformationProvider`. This is how, for example, the browser's URL stays updated as you navigate within your Flutter web app.\n\nThese internal workings highlight that `RouteInformation` is the key piece of data that flows through Flutter's router system, carrying the \"where and what\" of the app's state.\n\n## Conclusion\n\nIn this chapter, we learned that `RouteInformation` is a simple but powerful concept. It's a data object that holds information about your app's location and any associated state. This note-like structure is essential for telling the app where it is and what it should be doing at that location.\n\nWe saw how it's used to represent the desired destination and information needed to display a specific item's details. We also got a peek at how the `Router` internally uses `RouteInformation` for both processing incoming route requests and reporting the current state.\n\nIn the next chapter, we'll explore the [RouteInformationProvider](02_routeinformationprovider_.md), which is responsible for providing this `RouteInformation` to the routing system.\n\n[Next Chapter: RouteInformationProvider](02_routeinformationprovider_.md)\n---\n# Chapter 2: RouteInformationProvider\n\nWelcome back! In the last chapter, we introduced the concept of [RouteInformation](01_routeinformation_.md) \u2013 that little bundle of data telling our app where it wants to go and any extra details needed for that location.\n\nNow, how does this [RouteInformation](01_routeinformation_.md) actually get into our app's hands? This is where the `RouteInformationProvider` comes in!\n\n## What is a RouteInformationProvider?\n\nThink of `<RouteInformationProvider>` as the \"sensor\" or the \"source of truth\" for route changes outside of your app's internal navigation logic. Its job is to *provide* the current [RouteInformation](01_routeinformation_.md) to the rest of the routing system when needed.\n\nHere's its main purpose:\n\n*   **Detecting External Changes:** It listens for things happening *outside* your app that should cause a route change. On the web, this is usually the browser's URL changing (like when the user clicks the back button or types a new URL). On mobile, it might listen for system intents (like a deep link opening the app to a specific screen).\n*   **Providing Initial Route:** When your app first starts, the `RouteInformationProvider` tells the routing system what the initial route should be.\n*   **Saving State:** It also helps the app save its current route information for state restoration, so if the app is closed and reopened, it can go back to where the user was.\n\nEssentially, it's the bridge between external navigation events (like browser actions) and your Flutter routing system.\n\n## Why Do We Need a RouteInformationProvider?\n\nImagine you're building a web app with Flutter. The user types `yourwebsite.com/settings` into their browser. How does your Flutter app know to show the Settings screen?\n\nThis is the `RouteInformationProvider`'s job! It detects that the browser URL has changed, creates a [RouteInformation](01_routeinformation_.md) object (e.g., `uri: Uri.parse('/settings')`), and then tells the `Router` (which we'll cover in [Chapter 5: Router](05_router_.md)) that there's new route information available.\n\nHere's a simple scenario:\n\n```mermaid\nsequenceDiagram\n    participant Browser as Web Browser\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n    participant App as Your Flutter App\n\n    Browser->>Provider: User navigates to /profile\n    Provider->>Provider: Detects URL change\n    Provider->>Provider: Creates RouteInformation(/profile)\n    Provider-->>Router: Notifies Router of new RouteInformation\n    Router->>App: Updates UI based on /profile\n```\n\nWithout the `RouteInformationProvider`, your Flutter app wouldn't know when the browser's URL changes, and could therefore not respond to users navigating via the browser's history or URL bar.\n\n## The `PlatformRouteInformationProvider`\n\nFlutter provides a built-in `RouteInformationProvider` called `PlatformRouteInformationProvider`. This is the most common one you'll use, especially for web apps.\n\nLet's look at a simplified version of how you might use it when setting up your main app widget (like `MaterialApp.router`):\n\n```dart\n// Example setup using MaterialApp.router\nMaterialApp.router(\n  routeInformationProvider: PlatformRouteInformationProvider(\n    initialRouteInformation: RouteInformation(uri: Uri.parse('/')), // Start at home\n  ),\n  // ... other delegates will be added here later\n  // routeInformationParser: ..., // Chapter 3\n  // routerDelegate: ..., // Chapter 4\n  // backButtonDispatcher: ..., // Chapter 6\n)\n```\n\nIn this tiny snippet:\n*   We're creating a `PlatformRouteInformationProvider`.\n*   We tell it the `initialRouteInformation`, which is the [RouteInformation](01_routeinformation_.md) for the home screen (`/`). When the app starts, this is the first route information the provider gives to the `Router`.\n\nThe `PlatformRouteInformationProvider` automatically hooks into the underlying platform (web browser history, mobile system intents) to sense changes and provide new [RouteInformation](01_routeInformation_.md) objects.\n\n## How it Works (A Simple View)\n\nThe `RouteInformationProvider` is like a `ValueListenable<RouteInformation>`. This means:\n\n1.  It holds a `value` which is the current [RouteInformation](01_routeinformation_.md).\n2.  You can `addListener` to it to be notified whenever its `value` changes.\n\nThe `Router` widget listens to the `RouteInformationProvider`. When the provider's value changes, the `Router` knows it needs to process this new [RouteInformation](01_routeinformation_.md) and potentially update the UI.\n\nHere's a simplified sequence:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Platform as Platform (e.g., Browser History)\n    participant Provider as RouteInformationProvider\n    participant Router as Flutter Router\n\n    User->>Platform: Clicks browser back button\n    Platform->>Provider: Notifies provider of new URL\n    Provider->>Provider: Updates its internal RouteInformation value\n    Provider-->>Router: Notifies Router that value changed\n    Router->>Router: Reads Provider.value (the new RouteInformation)\n    Router->>Router: Processes RouteInformation (more on this in future chapters!)\n```\n\nThis shows the flow when an external event triggers a route change. The `RouteInformationProvider` is the one translating that external event into a format (the [RouteInformation](01_routeinformation_.md) object) that the Flutter `Router` can understand and act upon.\n\n## Internal View (How Flutter Uses It)\n\nLooking at the code snippets from `packages/flutter/lib/src/widgets/router.dart`, we can see how the `RouterState` interacts with the `RouteInformationProvider`.\n\nFirst, when the `Router` is initialized, it registers itself as a listener:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // Router registers as a listener!\n  widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n  // ... other initializations ...\n}\n```\n\nThis is super important! It means whenever the `RouteInformationProvider` detects a change and calls `notifyListeners()` (which `ValueNotifier` does internally when its value changes), the `_handleRouteInformationProviderNotification` method in the `RouterState` will be called.\n\nWhat happens inside that method?\n\n```dart\n// Snippet from _RouterState._handleRouteInformationProviderNotification\nvoid _handleRouteInformationProviderNotification() {\n  _routeParsePending = true; // Marks that we need to parse a new route\n  _processRouteInformation(\n    widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n    () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n  );\n}\n```\n\nThis method does two key things:\n\n1.  It gets the latest [RouteInformation](01_routeinformation_.md) from the provider (`widget.routeInformationProvider!.value`).\n2.  It calls `_processRouteInformation`, which signals the `Router` to start processing this new [RouteInformation](01_routeinformation_.md). We'll see how this processing happens in the next chapters ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md) and [Chapter 4: RouterDelegate](04_routerdelegate_.md)).\n\nThe `RouteInformationProvider` also works in the other direction! When your app's internal state changes and causes the `RouterDelegate` to update its `currentConfiguration` and notify the `Router`, the `Router` reports this back to the provider:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // Get the current RouteInformation from the delegate\n  _routeInformation.value = _retrieveNewRouteInformation();\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  // Schedule a task to report it\n  _scheduleRouteInformationReportingTask();\n}\n\n// Snippet from _RouterState._reportRouteInformation\nvoid _reportRouteInformation(Duration timestamp) {\n  // ... checks ...\n  if (_routeInformation.value != null) {\n    final RouteInformation currentRouteInformation = _routeInformation.value!;\n    assert(_currentIntentionToReport != null);\n    // This is where the Router tells the provider about the current route!\n    widget.routeInformationProvider!.routerReportsNewRouteInformation(\n      currentRouteInformation,\n      type: _currentIntentionToReport!,\n    );\n  }\n  // ... reset intention ...\n}\n```\n\nThis `routerReportsNewRouteInformation` call is handled by the `RouteInformationProvider`. For the `PlatformRouteInformationProvider` specifically, this method is overridden to update the browser's history:\n\n```dart\n// Snippet from PlatformRouteInformationProvider.routerReportsNewRouteInformation\n@override\nvoid routerReportsNewRouteInformation(\n  RouteInformation routeInformation, {\n  RouteInformationReportingType type = RouteInformationReportingType.none,\n}) {\n  SystemNavigator.selectMultiEntryHistory(); // For state restoration\n  SystemNavigator.routeInformationUpdated( // This updates browser history\n    uri: routeInformation.uri,\n    state: routeInformation.state,\n    replace: switch (type) {\n      RouteInformationReportingType.neglect => true,\n      RouteInformationReportingType.navigate => false,\n      RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n    },\n  );\n  _value = routeInformation; // Update internal value\n  _valueInEngine = routeInformation; // Keep track of what's in the engine\n}\n```\n\nThis bidirectional communication is key: the provider gets changes *from* the platform (like browser actions) and provides them *to* the `Router`, and the `Router` reports its *current* state *to* the provider so that the platform (like browser history) can stay synchronized.\n\n## Conclusion\n\nThe `RouteInformationProvider` is the \"eye on the outside world\" for your Flutter router. It detects external navigation changes and supplies the crucial [RouteInformation](01_routeinformation_.md) to the system. The `PlatformRouteInformationProvider` is the standard implementation that connects your app to platform features like browser history. Understanding that it acts as both a source of initial and external route information and a target for reporting the app's current route is essential for seeing the full picture of Flutter's routing system.\n\nIn the next chapter, we'll look at the [RouteInformationParser](03_routeinformationparser_.md), which takes the raw [RouteInformation](01_routeinformation_.md) provided by the `RouteInformationProvider` and turns it into something your app's logic can understand.\n\n[Next Chapter: RouteInformationParser](03_routeinformationparser_.md)\n---\n# Chapter 3: RouteInformationParser\n\nWelcome back! In the last chapter, we learned about the [RouteInformationProvider](02_routeinformationprovider_.md), which is like the \"sensor\" that detects external route changes and provides us with [RouteInformation](01_routeinformation_.md) \u2013 that important note about the desired location and state.\n\nNow, we have this `RouteInformation` note, but it's often still in a somewhat raw format (like a web URL string and a generic state object). How does our app understand what this means in terms of *which screens* to show and *how* to set them up?\n\nThis is where the `RouteInformationParser` comes in!\n\n## What is a RouteInformationParser?\n\nThink of the `RouteInformationParser` as a **translator**. Its main job is to take the `RouteInformation` provided by the [RouteInformationProvider](02_routeinformationprovider_.md) and **translate** it into a structured format that your app's logic can easily understand. This structured format is often custom to your application and describes the current \"state\" or \"configuration\" of your navigation.\n\nLet's revisit our item detail example from [Chapter 1: RouteInformation](01_routeinformation_.md).\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Parser as RouteInformationParser\n    participant AppData as MyAppState (Our Structured Data)\n\n    Provider->>Parser: Gives raw RouteInformation(uri: /items/123)\n    Parser->>Parser: Looks at the uri (/items/123)\n    Parser->>Parser: Extracts the item ID (123)\n    Parser-->>AppData: Creates structured data (DisplayItemDetails(itemId: 123))\n```\n\nIn this example:\n1.  The `RouteInformationProvider` gives the parser the `RouteInformation` object with the URI `/items/123`.\n2.  The `RouteInformationParser` receives this. It inspects the URI string.\n3.  It recognizes the pattern `/items/:itemId` and extracts the `123` part.\n4.  It then creates a more structured, app-specific object, like `DisplayItemDetails(itemId: 123)`. This object clearly and strongly types the intent: \"show the details screen for item 123.\"\n\nThis structured data (`DisplayItemDetails` in our example) is the output of the `RouteInformationParser`, and it's what the [RouterDelegate](04_routerdelegate_.md) will use to decide what widgets to build.\n\n## Why Do We Need a RouteInformationParser?\n\nImagine your app has many different types of screens, each needing specific data:\n*   A profile screen might need a user ID (`/users/456`).\n*   A product listing screen might need a category ID and a sort order (`/products?category=electronics&sort=price`).\n*   A settings screen might not need any extra data (`/settings`).\n\nThe raw `RouteInformation` (the URI string and the state map) can be flexible, but it can also be messy to work with directly in your app's UI building logic. You'd have to constantly parse strings, check existence of keys in a map, etc.\n\nThe `RouteInformationParser` centralizes this translation process. It takes the responsibility of understanding the raw `RouteInformation` format and producing a clean, well-defined object that represents the app's desired state. This keeps your UI building logic (in the [RouterDelegate](04_routerdelegate_.md)) much cleaner.\n\nIt also works in reverse! When your app's state changes internally and the [RouterDelegate](04_routerdelegate_.md) updates its `currentConfiguration`, the `Router` asks the `RouteInformationParser` to **restore** a `RouteInformation` from this structured configuration. This is how the parser helps in two directions:\n\n*   **Parsing:** `RouteInformation` (raw)  -> Structured App Configuration (easy for [RouterDelegate](04_routerdelegate_.md))\n*   **Restoring:** Structured App Configuration -> `RouteInformation` (raw) (for [RouteInformationProvider](02_routeinformationprovider_.md), e.g., updating browser URL)\n\n## How to Create a Simple RouteInformationParser\n\nLet's create a simple `RouteInformationParser` that can handle two routes: `/` (home) and `/items/:id` (item detail).\n\nFirst, we need to define the structured data type that our parser will output. This is often called a \"configuration\" or \"path\".\n\n```dart\n// A simple enum to represent our app's \"screens\" or \"paths\"\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\n// A class to hold potentially complex configuration data\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId; // Specific data for itemDetail path\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  // Helper to check if it's the home route\n  bool get isHomePage => path == MyAppPath.home;\n\n  // Helper to check if it's the item detail route\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n```\n\nHere, we have `MyAppPath` to represent the different *types* of paths and `MyAppRouteConfiguration` to hold the *specific* details for that path (like the `itemId`).\n\nNow, let's build the `RouteInformationParser`. We need to extend `RouteInformationParser<T>`, where `T` is our structured configuration type (`MyAppRouteConfiguration`).\n\n```dart\n// Our custom parser class\nclass MyAppRouteInformationParser\n    extends RouteInformationParser<MyAppRouteConfiguration> {\n\n  // This method translates RouteInformation to our configuration\n  @override\n  Future<MyAppRouteConfiguration> parseRouteInformation(\n      RouteInformation routeInformation) async {\n\n    final uri = routeInformation.uri; // Get the URI from the RouteInformation\n\n    // Check if the path is empty or just \"/\"\n    if (uri.pathSegments.isEmpty || uri.pathSegments.first == '') {\n      return SynchronousFuture(MyAppRouteConfiguration.home()); // It's the home page!\n    }\n\n    // Check if the path starts with \"items\"\n    if (uri.pathSegments.length == 2 && uri.pathSegments.first == 'items') {\n      final String itemIdSegment = uri.pathSegments[1]; // Get the ID part\n\n      // Try to parse the ID as an integer\n      final int? itemId = int.tryParse(itemIdSegment);\n      if (itemId != null) {\n        return SynchronousFuture(MyAppRouteConfiguration.itemDetail(itemId)); // It's an item detail!\n      }\n    }\n\n    // If neither matches, maybe route to home or show an error\n    // For simplicity, let's route to home for now\n    return SynchronousFuture(MyAppRouteConfiguration.home());\n  }\n\n  // This method translates our configuration back to RouteInformation\n  @override\n  RouteInformation? restoreRouteInformation(\n      MyAppRouteConfiguration configuration) {\n    // Based on the configuration, create the RouteInformation\n    if (configuration.isHomePage) {\n      return RouteInformation(uri: Uri.parse('/')); // Home page URI\n    }\n\n    if (configuration.isItemDetailPage) {\n      // Item detail page URI, include the item ID\n      return RouteInformation(uri: Uri.parse('/items/${configuration.itemId}'));\n    }\n\n    // Should not happen if we handle all paths in our configuration\n    return null;\n  }\n}\n```\n\nLet's break down the important parts:\n\n1.  **`parseRouteInformation`:** This is where the magic happens for `RouteInformation` -> Configuration.\n    *   It receives the `RouteInformation`.\n    *   It accesses the `uri` (the location).\n    *   It uses simple logic (checking path segments) to figure out what the URI means in terms of our app's screens.\n    *   If the path is `/`, it returns `MyAppRouteConfiguration.home()`.\n    *   If the path is `/items/:id` and the `:id` is a number, it returns `MyAppRouteConfiguration.itemDetail(itemId)`.\n    *   **Important:** It returns a `Future`. For simple synchronous processing like this, we wrap the result in `SynchronousFuture`. This tells Flutter that the result is available immediately. If parsing required network requests or heavy computation, it would be a real `Future`.\n\n2.  **`restoreRouteInformation`:** This handles the reverse, Configuration -> `RouteInformation`.\n    *   It receives our app configuration (`MyAppRouteConfiguration`).\n    *   Based on which type of configuration it is (`isHomePage` or `isItemDetailPage`), it constructs and returns the appropriate `RouteInformation` object.\n    *   For the item detail page, it rebuilds the `/items/:id` URI using the `itemId` from the configuration.\n    *   Returning `null` means this configuration shouldn't be reported as a route change (useful for temporary internal states you don't want reflecting in the browser history).\n\nNow, with our `MyAppRouteInformationParser` and `MyAppRouteConfiguration`, the incoming `RouteInformation` from the [RouteInformationProvider](02_routeinformationprovider_.md) can be cleanly translated into something our [RouterDelegate](04_routerdelegate_.md) can easily work with.\n\n## Internal View (How Flutter Uses It)\n\nLet's look at how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) uses the `RouteInformationParser`.\n\nWhen the [RouteInformationProvider](02_routeinformationprovider_.md) notifies the `Router` that there's new `RouteInformation` available, the `_handleRouteInformationProviderNotification` method is called (as we saw in [Chapter 2](02_routeinformationprovider_.md)). This method then calls `_processRouteInformation`:\n\n```dart\n// Snippet from _RouterState._processRouteInformation\nvoid _processRouteInformation(\n  RouteInformation information, // The new RouteInformation\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // A way to call the delegate (RouterDelegate)\n) {\n  // ... setup ...\n\n  // *** This is where the parser is used! ***\n  // It calls parseRouteInformationWithDependencies\n  widget.routeInformationParser!\n      .parseRouteInformationWithDependencies(information, context)\n      .then<void>( // When the parsing is done...\n          _processParsedRouteInformation( // ...process the parsed data (T)\n              _currentRouterTransaction, delegateRouteSetter));\n}\n```\n\nThis snippet clearly shows the flow:\n1.  `_processRouteInformation` is called with the new `information` (the `RouteInformation` from the provider).\n2.  It accesses the `widget.routeInformationParser`.\n3.  It calls the parser's `parseRouteInformationWithDependencies` method, passing the `information` and the `context`.\n4.  Because `parseRouteInformationWithDependencies` (or the simpler `parseRouteInformation` it calls) returns a `Future`, the `.then` is used to wait for the result.\n5.  Once the parsing is complete, the resulting structured data (`T`, which is our `MyAppRouteConfiguration` in the example) is passed to `_processParsedRouteInformation`.\n\nWhat does `_processParsedRouteInformation` do? It calls the `setNewRoutePath` or `setInitialRoutePath` methods on the [RouterDelegate](04_routerdelegate_.md) (using the provided `delegateRouteSetter`) with the parsed configuration:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction,\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    if (_currentRouterTransaction != transaction) {\n      return; // Ignore if a new route change happened meantime\n    }\n    // *** Calls the RouterDelegate's setter with the parsed data! ***\n    await delegateRouteSetter()(data);\n    if (_currentRouterTransaction == transaction) {\n      // If still processing the same transaction, rebuild the Router\n       _rebuild();\n    }\n  };\n}\n```\n\nThis completes the first half of the journey: `RouteInformationProvider` -> `RouteInformation` -> `RouteInformationParser` -> Structured Configuration -> `RouterDelegate`.\n\nThe second half, for restoring and reporting the current route (`RouterDelegate` -> Configuration -> `RouteInformationParser` -> `RouteInformation` -> [RouteInformationProvider](02_routeinformationprovider_.md)), happens when the `Router` rebuilds and needs to report the current state. The `_maybeNeedToReportRouteInformation` method is involved:\n\n```dart\n// Snippet from _RouterState._maybeNeedToReportRouteInformation\nvoid _maybeNeedToReportRouteInformation() {\n  // *** Retrieves the current config from the RouterDelegate ***\n  // *** And uses the parser to turn it back into RouteInformation ***\n  _routeInformation.value = _retrieveNewRouteInformation();\n\n  _currentIntentionToReport ??= RouteInformationReportingType.none;\n  _scheduleRouteInformationReportingTask(); // Schedules reporting to the provider\n}\n\n// Snippet from _RouterState._retrieveNewRouteInformation\nRouteInformation? _retrieveNewRouteInformation() {\n  final T? configuration = widget.routerDelegate.currentConfiguration; // Get config\n  if (configuration == null) {\n    return null;\n  }\n  // *** Calls the parser's restoreRouteInformation method! ***\n  return widget.routeInformationParser?.restoreRouteInformation(configuration);\n}\n```\n\nHere:\n1.  `_maybeNeedToReportRouteInformation` is called.\n2.  It calls `_retrieveNewRouteInformation`.\n3.  `_retrieveNewRouteInformation` asks the `routerDelegate` for its `currentConfiguration`.\n4.  If a configuration is available, **it calls the `routeInformationParser`'s `restoreRouteInformation` method** with this configuration.\n5.  The resulting `RouteInformation` is then stored and scheduled to be reported to the [RouteInformationProvider](02_routeinformationprovider_.md).\n\nThis shows how the `RouteInformationParser` acts as the critical bridge, translating back and forth between the raw platform-friendly `RouteInformation` and your app-specific structured configuration.\n\n## Conclusion\n\nIn this chapter, we learned that the `RouteInformationParser` is the translator in the Flutter routing system. It skillfully converts the raw `RouteInformation` (often from external sources like browser URLs) into a structured, app-specific data type that represents the desired navigation state. It also works in reverse, helping to restore `RouteInformation` from the app's current state for things like updating browser history. By creating a custom parser and a custom configuration type, you gain fine-grained control over how your app interprets incoming routes and represents its own navigation state.\n\nIn the next chapter, we'll finally dive into the [RouterDelegate](04_routerdelegate_.md), which takes the structured data produced by the `RouteInformationParser` and uses it to build the actual UI, deciding which screens or widgets to display.\n\n[Next Chapter: RouterDelegate](04_routerdelegate_.md)\n---\n# Chapter 4: RouterDelegate\n\nWelcome back to our Flutter routing journey! In the previous chapters, we learned about [RouteInformation](01_routeinformation_.md) (the note about our desired location) and the [RouteInformationProvider](02_routeinformationprovider_.md) (the sensor that provides this note). We then saw how the [RouteInformationParser](03_routeinformationparser_.md) acts as the translator, turning the raw [RouteInformation](01_routeinformation_.md) into a clean, structured app configuration that our app understands.\n\nNow, what do we *do* with this structured configuration? How do we actually display the right screens and build the visual layout of our app based on it?\n\nThis is the job of the `RouterDelegate`!\n\n## What is a RouterDelegate?\n\nThink of the `RouterDelegate` as the **main builder** or the **presenter** of your app's layout for routing. It receives the structured configuration (the output from the [RouteInformationParser](03_routeinformationparser_.md)) and is responsible for:\n\n1.  **Building the UI:** Deciding which widgets to show based on the configuration. This commonly involves creating a `Navigator` widget, which manages a stack of `Page` objects (which represent your screens).\n2.  **Handling Configuration Changes:** Updating the UI when the configuration changes (e.g., the user navigates to a different screen).\n3.  **Handling Pop Requests:** Responding to requests to \"go back\" (like the user pressing the system back button) and determining if the current screen can be popped.\n\nEssentially, the `RouterDelegate` takes the \"what\" (the desired state/configuration) and creates the \"how\" (the actual widgets on the screen).\n\nLet's look at our item detail example again:\n\n```mermaid\nsequenceDiagram\n    participant Parser as RouteInformationParser\n    participant Config as MyAppRouteConfiguration\n    participant Delegate as RouterDelegate\n    participant Navigator as Flutter Navigator\n    participant Screen as MyAppScreens (Widgets)\n\n    Parser-->>Config: Provides configuration (e.g., DisplayItemDetails(123))\n    Delegate->>Config: Receives configuration\n    Delegate->>Navigator: Decides what Pages to show\n    Navigator->>Screen: Builds the widgets for the desired state\n```\n\nIn this flow:\n1.  The [RouteInformationParser](03_routeinformationparser_.md) gives us our `MyAppRouteConfiguration` (like `DisplayItemDetails(123)`).\n2.  The `RouterDelegate` gets this configuration.\n3.  Based on the configuration, the `RouterDelegate` decides which screens should be visible. In a common pattern, it builds or updates a `Navigator` widget.\n4.  The `Navigator` then takes care of displaying the appropriate `Page` widgets for those screens.\n\n## Why Do We Need a RouterDelegate?\n\nWithout a `RouterDelegate`, the `Router` wouldn't know how to translate the parsed route information into a visual representation. It doesn't know *which* widgets correspond to your app's `MyAppRouteConfiguration`.\n\nThe `RouterDelegate` decouples the parsing logic (handled by the [RouteInformationParser](03_routeinformationparser_.md)) from the UI building logic. This allows you to:\n\n*   **Define your UI structure separately:** You can decide how screens are stacked (using `Navigator`), shown in tabs, or arranged in any other layout based on the route.\n*   **Control animated transitions:** The `Navigator` built by the delegate handles screen transitions.\n*   **Manage screen state:** The delegate often holds the current app configuration and uses it to manage the state of the screens being displayed.\n*   **Handle back button behavior:** The delegate is the primary place to implement custom logic for what happens when the user presses the back button ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) will notify the delegate).\n\n## How to Create a Simple RouterDelegate\n\nUsing our `MyAppRouteConfiguration` from [Chapter 3](03_routeinformationparser_.md), let's create a simple `RouterDelegate` that shows either a Home screen or an Item Detail screen using a `Navigator`.\n\nWe need to extend `RouterDelegate<T>` where `T` is our configuration type (`MyAppRouteConfiguration`). We also need to implement the `Listenable` interface (often done using a `ChangeNotifier` or mixing in `PopNavigatorRouterDelegateMixin` and extending `ChangeNotifier`). For building a `Navigator`, the `PopNavigatorRouterDelegateMixin` is very commonly used, as it automatically hooks the `popRoute` method to the `Navigator`.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For ChangeNotifier and SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator and Button\n\n// Re-using our configuration from Chapter 3\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration {\n  final MyAppPath path;\n  final int? itemId;\n\n  MyAppRouteConfiguration.home()\n      : path = MyAppPath.home,\n        itemId = null;\n\n  MyAppRouteConfiguration.itemDetail(this.itemId)\n      : path = MyAppPath.itemDetail,\n        assert(itemId != null);\n\n  bool get isHomePage => path == MyAppPath.home;\n  bool get isItemDetailPage => path == MyAppPath.itemDetail;\n}\n\n// Our RouterDelegate\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> {\n\n  // Required by PopNavigatorRouterDelegateMixin\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  // This holds the current configuration received from the parser\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  // This getter is called by the Router to know the current state\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  // This is called by the Router when a new route is parsed\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    // Update our internal state with the new configuration\n    _currentConfiguration = configuration;\n    // Notify listeners (the Router) to rebuild\n    notifyListeners();\n    // Return a completed future since this is synchronous\n    return SynchronousFuture<void>(null);\n  }\n\n  // PopRoute is handled by PopNavigatorRouterDelegateMixin\n\n  // This is where we build the UI based on the current configuration\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    // Always show the Home page as the base\n    pages.add(\n       MaterialPage( // MaterialPage provides platform-specific transitions\n         child: HomePage(\n           // Function to navigate to item detail\n           onItemTapped: (itemId) {\n             // Update configuration internally and notify listeners\n             setNewRoutePath(MyAppRouteConfiguration.itemDetail(itemId));\n           },\n         ),\n         key: const ValueKey('HomePage'), // Unique key for Navigator\n       )\n    );\n\n    // If configuration indicates item detail, add that page on top\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(\n            itemId: _currentConfiguration!.itemId!,\n          ),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'), // Unique key including ID\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey,\n      pages: pages,\n      onPopPage: (route, result) {\n        // Handle when a route is popped from the Navigator (e.g., by tapping back button on app bar)\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // If a page was popped, update our configuration by going back to home\n        // In a real app, this logic would be more complex to handle nested routes\n        if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true; // Tell the Navigator the pop was handled\n      },\n    );\n  }\n\n  // dispose method inherited from ChangeNotifier\n}\n\n// Dummy widgets for our screens\nclass HomePage extends StatelessWidget {\n   const HomePage({super.key, required this.onItemTapped});\n   final void Function(int) onItemTapped;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: const Text('Home')),\n       body: Center(\n         child: Column(\n           mainAxisAlignment: MainAxisAlignment.center,\n           children: <Widget>[\n             const Text('Home Screen'),\n             ElevatedButton(\n               onPressed: () => onItemTapped(123), // Navigate to item 123\n               child: const Text('Go to Item 123'),\n             ),\n           ],\n         ),\n       ),\n     );\n   }\n}\n\nclass ItemDetailPage extends StatelessWidget {\n   const ItemDetailPage({super.key, required this.itemId});\n   final int itemId;\n\n   @override\n   Widget build(BuildContext context) {\n     return Scaffold(\n       appBar: AppBar(title: Text('Item $itemId Details')),\n       body: Center(\n         child: Text('Details for Item ID: $itemId'),\n       ),\n     );\n   }\n}\n```\n\nLet's break down the `MyAppRouterDelegate`:\n\n1.  **`navigatorKey`:** Required by `PopNavigatorRouterDelegateMixin`. This key is used to get a reference to the `NavigatorState` (`navigatorKey.currentState`). The mixin's `popRoute` uses this to call `navigator?.maybePop()`.\n2.  **`_currentConfiguration`:** A private variable to store the latest configuration we received.\n3.  **`currentConfiguration` getter:** The `Router` calls this to get the current state of our delegate. This is important for the [RouteInformationParser](03_routeInformationParser_.md)'s `restoreRouteInformation` method (to convert back to raw [RouteInformation](01_routeInformation_.md)) and for state restoration.\n4.  **`setNewRoutePath(MyAppRouteConfiguration configuration)`:** This is the core method called by the `Router` after the [RouteInformationParser](03_routeInformationParser_.md) successfully translates `RouteInformation` into `MyAppRouteConfiguration`.\n    *   We update `_currentConfiguration` with the new `configuration`.\n    *   We call `notifyListeners()`. This tells the `Router` that our delegate's state has changed and it needs to `rebuild`. When the `Router` rebuilds, it calls our `build` method.\n    *   We return a `SynchronousFuture` because our update is immediate.\n5.  **`popRoute()`:** This is implemented by `PopNavigatorRouterDelegateMixin`. It automatically calls the `maybePop()` method on the `Navigator` instance identified by `navigatorKey`. `Navigator.maybePop()` attempts to pop the topmost route. If successful, it returns `true`; otherwise, `false`. This result is then returned by `popRoute`, and the [BackButtonDispatcher](06_backbuttondispatcher_.md) uses it to decide if the pop was handled or if it should bubble the back request further.\n6.  **`build(BuildContext context)`:** This is where the UI is constructed.\n    *   We create a list of `Page` objects. A `Navigator` displays pages based on this list.\n    *   We always add the `HomePage` as the base page.\n    *   We check `_currentConfiguration`. If it indicates `isItemDetailPage`, we add the `ItemDetailPage` to the list. Since the `ItemDetailPage` is added *after* the `HomePage`, it will be displayed on top in the `Navigator` stack.\n    *   We return a `Navigator` widget. We provide our `navigatorKey`.\n    *   `onPopPage` is a callback for the `Navigator`. It's triggered when a page asks to be popped (e.g., by the user pressing the back arrow in an `AppBar`, *not* the system back button, which is handled by `popRoute`). We check if the pop was handled and, if so, update our internal configuration to navigate back (in this simple case, back to home).\n\nNow, when the [RouteInformationParser](03_routeInformationParser_.md) gives `MyAppRouterDelegate` a configuration like `MyAppRouteConfiguration.itemDetail(123)`, the delegate updates its internal state, calls `notifyListeners`, the `Router` rebuilds, the `build` method is called, the `Navigator` gets a list of pages with the `HomePage` and `ItemDetailPage(123)`, and the Navigator shows the Item Detail screen on top!\n\n## Internal View (How Flutter Uses It)\n\nLet's revisit the `Router`'s internal state (`packages/flutter/lib/src/widgets/router.dart`) to see how it interacts with the `RouterDelegate`.\n\nAs we saw in [Chapter 3](03_routeinformationparser_.md), after the [RouteInformationParser](03_routeInformationParser.md) successfully calls `parseRouteInformationWithDependencies` and the `Future` completes, the `_processParsedRouteInformation` method handles the result:\n\n```dart\n// Snippet from _RouterState._processParsedRouteInformation\n_RouteSetter<T> _processParsedRouteInformation(\n  Object? transaction, // Unused in this simplified view\n  ValueGetter<_RouteSetter<T>> delegateRouteSetter, // Function to get the delegate's setter\n) {\n  return (T data) async { // 'data' is the parsed config (MyAppRouteConfiguration)\n    // Call the appropriate delegate method with the parsed data!\n    await delegateRouteSetter()(data);\n    // After the delegate finishes setting the new path, rebuild\n    // (provided no other transactions interfered)\n    _rebuild();\n  };\n}\n```\n\nThis confirms that the `Router` calls the `setNewRoutePath` (or `setInitialRoutePath`/`setRestoredRoutePath`) method on the `routerDelegate` instance using the parsed configuration data (`T`, our `MyAppRouteConfiguration`). Once that method completes, the `Router` calls `_rebuild()`, which triggers `setState` and causes the `Router` widget itself to rebuild. This rebuild is what ultimately calls the `routerDelegate`'s `build` method to generate the UI.\n\nThe `Router` also listens to the `RouterDelegate` for notifications. This connection is made in the `_RouterState.initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router listens to the delegate!\n  widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n}\n```\n\nAnd the `_handleRouterDelegateNotification` method:\n\n```dart\n// Snippet from _RouterState._handleRouterDelegateNotification\nvoid _handleRouterDelegateNotification() {\n  // When the delegate notifies, rebuild the Router\n  setState(() {\n    /* routerDelegate wants to rebuild */\n  });\n  // And potentially report the new route information\n  _maybeNeedToReportRouteInformation();\n}\n```\n\nThis is crucial! When our `MyAppRouterDelegate` calls `notifyListeners()` in its `setNewRoutePath`, this method (`_handleRouterDelegateNotification`) is triggered. This causes the `Router`'s `setState` to run, leading to a rebuild and a call to our delegate's `build` method.\n\nFinally, the `Router` uses the delegate for handling back button presses. The [BackButtonDispatcher](06_backbuttondispatcher_.md) notifies the `Router`, which calls `_handleBackButtonDispatcherNotification`:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  _currentRouterTransaction = Object(); // Start a new transaction\n  // Call the delegate's popRoute method!\n  return widget.routerDelegate.popRoute().then<bool>(\n    _handleRoutePopped(_currentRouterTransaction), // Process the result\n  );\n}\n```\n\nHere, the `Router` calls the `routerDelegate.popRoute()` method. As we discussed, if you're using `PopNavigatorRouterDelegateMixin`, this calls `navigatorKey.currentState?.maybePop()`. The `Router` waits for the result of `popRoute` (true if handled, false otherwise) and uses it to determine the next steps, including whether to rebuild or allow the back event to bubble up further.\n\nThese internal methods clearly show how the `RouterDelegate` is central to the process: the `Router` *calls* the delegate to set the new route and *calls* it to handle pops, and the delegate asynchronously *notifies* the router when its internal state changes and it needs to rebuild the UI.\n\n## Conclusion\n\nThe `RouterDelegate` is the powerhouse of your Flutter router. It's the component that takes the parsed route configuration and transforms it into the visual layout of your application, typically by building or updating a `Navigator` widget. You implement its methods (`setNewRoutePath`, `popRoute`, `build`, and `currentConfiguration`) to control how routes are displayed and how back button presses are handled. By notifying its listeners (`notifyListeners()`), it signals the `Router` to rebuild the UI based on the updated state.\n\nIn the next chapter, we'll see how the [Router](05_router_.md) widget itself orchestrates all these pieces \u2013 the [RouteInformationProvider](02_routeinformationprovider_.md), the [RouteInformationParser](03_routeinformationparser_.md), and the `RouterDelegate`.\n\n[Next Chapter: Router](05_router_.md)\n---\n# Chapter 5: Router\n\nWelcome back to our Flutter routing deep dive! In the previous chapters, we've explored some key players:\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The note telling us where to go and what data is needed.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The sensor that detects external route changes and gives us the `RouteInformation`.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The translator that turns `RouteInformation` into a structured app configuration.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The builder that takes the structured configuration and builds the UI, usually with a `Navigator`.\n\nBut who brings all these pieces together? Who is in charge of the whole routing process, listening to the [RouteInformationProvider](02_routeinformationprovider_.md), using the [RouteInformationParser](03_routeinformationparser_.md), and commanding the [RouterDelegate](04_routerdelegate_.md)?\n\nMeet the `Router` widget!\n\n## What is the Router Widget?\n\nThe `Router` widget is the **central hub** or the **orchestrator** of the Flutter routing system. It's the widget you place in your widget tree that ties together the [RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), and [RouterDelegate](04_routerdelegate_.md).\n\nThink of it as the conductor of an orchestra:\n\n*   It listens to the **[RouteInformationProvider](02_routeinformationprovider_.md)** (like listening to a signal from outside, such as a browser URL change).\n*   It hands that signal ([RouteInformation](01_routeinformation_.md)) to the **[RouteInformationParser](03_routeinformationparser_.md)** (like asking the translator to figure out what the signal means).\n*   It takes the result from the parser (the structured app configuration) and gives it to the **[RouterDelegate](04_routerdelegate_.md)** (like telling the builder exactly what to display).\n*   It also allows the [RouterDelegate](04_routerdelegate_.md) to report its current state and uses the [RouteInformationParser](03_routeinformationparser_.md) to convert that back to [RouteInformation](01_routeinformation_.md) for things like browser history.\n*   It coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) to handle system back button presses by telling the [RouterDelegate](04_routerdelegate_.md) to `popRoute`.\n\nEssentially, the `Router` widget is the glue that makes the Declarative Router system work. It's rarely something you interact with directly *after* setting it up; its job is to manage the delegates you provide.\n\nHere's a simplified flow showing the `Router` in the middle:\n\n```mermaid\nsequenceDiagram\n    participant Provider as RouteInformationProvider\n    participant Router as Router Widget\n    participant Parser as RouteInformationParser\n    participant Config as App Configuration\n    participant Delegate as RouterDelegate\n    participant UI as App UI (Navigator/Pages)\n\n    Provider->>Router: New RouteInformation available\n    Router->>Parser: parse(RouteInformation)\n    alt Parser completes\n        Parser-->>Router: Returns Config\n        Router->>Delegate: setNewRoutePath(Config)\n        Delegate-->>Router: Notifies Router (state changed)\n        Router->>Router: setState (Triggers rebuild)\n        Router->>Delegate: build()\n        Delegate-->>UI: Builds/Updates UI\n        Delegate->>Router: currentConfiguration\n        Router->>Parser: restore(Config)\n        Parser-->>Router: Returns RouteInformation\n        Router->>Provider: routerReportsNewRouteInformation(RouteInformation)\n    end\n```\n\nThis diagram shows the core cycle: The provider gets information, gives it to the Router, the Router passes it to the parser, the parser gives back configuration, the Router gives that to the delegate, the delegate updates its state and notifies the Router, the Router tells the delegate to build the UI, and finally, the Router gets the current state back from the delegate to report to the provider (for things like browser history).\n\n## Why Do We Need the Router Widget?\n\nWhile each delegate ([RouteInformationProvider](02_routeinformationprovider_.md), [RouteInformationParser](03_routeinformationparser_.md), [RouterDelegate](04_routerdelegate_.md), and [BackButtonDispatcher](06_backbuttondispatcher_.md)) has a specific responsibility, they need a manager to coordinate them. The `Router` widget provides this management layer.\n\nIt handles the complex asynchronous interactions (like waiting for the parser to finish) and ensures that when one delegate signals a change (like the provider getting a new route or the delegate's state changing), the correct methods on the other delegates are called in the right order.\n\nSetting up your routing with the `Router` looks like this (using `MaterialApp.router`, which internally uses a `Router` widget):\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume this file contains our custom delegates and config\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n\n      // Provide our custom delegates!\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n      // backButtonDispatcher: RootBackButtonDispatcher(), // From Chapter 7\n    );\n  }\n}\n```\n\nHere, you don't explicitly write `Router(...)`, but `MaterialApp.router` is a convenience widget that does it for you. You pass in your custom implementations of the delegates we've discussed. The `MaterialApp.router` (or `WidgetsBinding.builder`) is a common place to set up the root `Router` for your application.\n\nYou *can* create a `Router` widget directly in your tree if you need nested routing, but for a basic app, the one provided by `MaterialApp.router` is usually sufficient.\n\n## How the Router Widget Works (Internal View)\n\nLet's peek inside the `_RouterState` class, which implements the state for the `Router` widget. This is where the connections between the delegates happen.\n\nWe've seen snippets of this in previous chapters, but let's review the core interactions:\n\n1.  **Receiving Route Information:** When the [RouteInformationProvider](02_routeinformationprovider_.md) notifies its listeners (which the `Router` state is), the `_handleRouteInformationProviderNotification` method is called:\n\n    ```dart\n    // Snippet from _RouterState._handleRouteInformationProviderNotification\n    void _handleRouteInformationProviderNotification() {\n      _routeParsePending = true; // Mark that we need to parse\n      _processRouteInformation(\n        widget.routeInformationProvider!.value, // Get the NEW RouteInformation\n        () => widget.routerDelegate.setNewRoutePath, // Tell the delegate to set the new path\n      );\n    }\n    ```\n    This gets the latest [RouteInformation](01_routeinformation_.md) from the provider and calls `_processRouteInformation`.\n\n2.  **Processing Route Information:** The `_processRouteInformation` calls the [RouteInformationParser](03_routeinformationparser_.md):\n\n    ```dart\n    // Snippet from _RouterState._processRouteInformation\n    void _processRouteInformation(\n      RouteInformation information,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter, // How to call the delegate\n    ) {\n      // ... setup ...\n\n      // Call the parser!\n      widget.routeInformationParser!\n          .parseRouteInformationWithDependencies(information, context)\n          .then<void>( // When parsing completes...\n              _processParsedRouteInformation( // ...process the result\n                  _currentRouterTransaction, delegateRouteSetter));\n    }\n    ```\n    This waits for the `parseRouteInformationWithDependencies` future to complete.\n\n3.  **Calling the RouterDelegate:** Once the parser returns the structured configuration (`T`), `_processParsedRouteInformation` is called, which then calls the appropriate setter on the [RouterDelegate](04_routerdelegate_.md) (`setNewRoutePath`, `setInitialRoutePath`, or `setRestoredRoutePath`):\n\n    ```dart\n    // Snippet from _RouterState._processParsedRouteInformation\n    _RouteSetter<T> _processParsedRouteInformation(\n      Object? transaction,\n      ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n    ) {\n      return (T data) async { // 'data' is the parsed config\n        // Call the delegate's method!\n        await delegateRouteSetter()(data);\n         // If successful, trigger a rebuild\n        _rebuild();\n      };\n    }\n    ```\n\n4.  **Listening to the RouterDelegate:** The `Router` also listens to the [RouterDelegate](04_routerdelegate_.md). This is set up in `initState`:\n\n    ```dart\n    // Snippet from _RouterState.initState\n    @override\n    void initState() {\n      super.initState();\n      // ... other listeners ...\n      // Listen to the delegate!\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n    }\n    ```\n    And when the delegate calls `notifyListeners()`, `_handleRouterDelegateNotification` runs:\n\n    ```dart\n    // Snippet from _RouterState._handleRouterDelegateNotification\n    void _handleRouterDelegateNotification() {\n      // Rebuild the Router\n      setState(() { /* routerDelegate wants to rebuild */ });\n      // And potentially report the new route information\n      _maybeNeedToReportRouteInformation();\n    }\n    ```\n    This rebuild is what causes the delegate's `build` method to be called, updating the UI. The call to `_maybeNeedToReportRouteInformation` triggers the reverse process (Configuration -> [RouteInformation](01_routeinformation_.md) -> [RouteInformationProvider](02_routeinformationprovider_.md)).\n\n5.  **Handling Back Button:** The `Router` also listens to the [BackButtonDispatcher](06_backbuttondispatcher_.md) (set up in `initState`). When notified, it calls the delegate's `popRoute` method:\n\n    ```dart\n    // Snippet from _RouterState._handleBackButtonDispatcherNotification\n    Future<bool> _handleBackButtonDispatcherNotification() {\n      _currentRouterTransaction = Object(); // Start a new transaction\n      // Call the delegate's popRoute!\n      return widget.routerDelegate.popRoute().then<bool>(\n        _handleRoutePopped(_currentRouterTransaction), // Process the result\n      );\n    }\n    ```\n\nThese internal methods show how the `Router` is constantly listening for changes from the [RouteInformationProvider](02_routeinformationprovider_.md), orchestrating the parsing and delegate updates, and listening back to the [RouterDelegate](04_routerdelegate_.md) and [BackButtonDispatcher](06_backbuttondispatcher_.md) to manage the overall routing state and UI.\n\nThe `build` method of the `Router` simply provides an `InheritedWidget` (`_RouterScope`) so descendant widgets can access the router's delegates (using `Router.of(context)`) and then calls `widget.routerDelegate.build(context)` to get the actual UI tree:\n\n```dart\n// Snippet from _RouterState.build\n@override\nWidget build(BuildContext context) {\n  return UnmanagedRestorationScope(\n    bucket: bucket,\n    child: _RouterScope(\n      // Provides delegates via InheritedWidget\n      routeInformationProvider: widget.routeInformationProvider,\n      bac...tonDispatcher: widget.backButtonDispatcher,\n      ro...InformationParser: widget.routeInformationParser,\n      r...Delegate: widget.routerDelegate,\n      routerState: this,\n      child: Builder(\n        // *** Calls the delegate's build method! ***\n        builder: widget.routerDelegate.build,\n      ),\n    ),\n  );\n}\n```\n\nThis reinforces that the `Router`'s job isn't to build the screen content itself, but to provide the context (via `_RouterScope`) and tell the `RouterDelegate` when and where to build.\n\n## Conclusion\n\nThe `Router` widget is the central figure in Flutter's Declarative Router system. It's the orchestrator that receives route information, delegates the parsing to the [RouteInformationParser](03_routeinformationparser_.md), passes the resulting configuration to the [RouterDelegate](04_routerdelegate_.md) to build the UI, and coordinates with the [BackButtonDispatcher](06_backbuttondispatcher_.md) for back button handling. While you often interact with it indirectly through convenience widgets like `MaterialApp.router`, understanding its role as the connector between all the delegates is key to grasping how the system functions.\n\nIn the next chapter, we'll look closer at the [BackButtonDispatcher](06_backbuttondispatcher_.md), which the `Router` listens to for those important system back button presses.\n\n[Next Chapter: BackButtonDispatcher](06_backbuttondispatcher_.md)\n---\n# Chapter 6: BackButtonDispatcher\n\nWelcome back! In the last five chapters, we've built a good understanding of how Flutter's Declarative Router manages navigation using:\n\n*   [Chapter 1: RouteInformation](01_routeinformation_.md): The \"where and what\" note.\n*   [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md): The \"sensor\" for external route changes.\n*   [Chapter 3: RouteInformationParser](03_routeinformationparser_.md): The \"translator\" from raw notes to structured app configurations.\n*   [Chapter 4: RouterDelegate](04_routerdelegate_.md): The \"builder\" that uses the configuration to show screens, often via a `Navigator`.\n*   [Chapter 5: Router](05_router_.md): The \"orchestrator\" that connects all the delegates.\n\nNow, what about that important system back button? On platforms like Android, users expect the back button to work intuitively \u2013 usually closing the current screen or going back to the previous step. How does our declarative routing system handle this?\n\nThis is where the `BackButtonDispatcher` comes in!\n\n## What is a BackButtonDispatcher?\n\nThink of the `BackButtonDispatcher` as the **system back button listener**. It's a mechanism that receives notifications when the user presses the hardware or software back button provided by the operating system (like on Android phones).\n\nWhen the `BackButtonDispatcher` catches a back button event, it doesn't handle it directly. Instead, its main job is to **forward** this event to the **[Router](05_router_.md)**. The [Router](05_router_.md) then tells the **[RouterDelegate](04_routerdelegate_.md)** to attempt to handle the back action.\n\nThe `BackButtonDispatcher` also supports **nesting**. This means if you have multiple [Router](05_router_.md)s for different parts of your UI (e.g., a main app [Router](05_router_.md) and a separate [Router](05_router_.md) for a flow within a tab), the back button event can be dispatched correctly to the most relevant [Router](05_router_.md) and its delegate.\n\nIts main purposes are:\n\n1.  **Receive System Back Button Events:** Listen for the platform-specific signal that the user wants to go back.\n2.  **Dispatch to the Router:** Notify the **[Router](05_router_.md)** that a back request has occurred.\n3.  **Coordinate Hierarchies:** Allow nested [Router](05_router_.md)s to participate in back button handling.\n\nHere's a simple flow:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant Dispatcher as BackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>Dispatcher: Sends back button event\n    Dispatcher->>Dispatcher: Receives event\n    Dispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>Dispatcher: Returns true/false\n    Dispatcher-->>System: Communicates handling status (affects whether app exits etc.)\n```\n\nThis flow shows that the `BackButtonDispatcher` is the critical first step in the Flutter routing system's response to a back button press.\n\n## Why Do We Need a BackButtonDispatcher?\n\nWithout a `BackButtonDispatcher`, Flutter wouldn't have a standardized way to receive back button events from the underlying operating system. Each platform might signal this differently, and the `BackButtonDispatcher` provides a common interface.\n\nFurthermore, since back button behavior can depend on the current screen and state (which is managed by your `RouterDelegate` in conjunction with a `Navigator`), the `BackButtonDispatcher` is needed to effectively forward this request to the component best equipped to handle it \u2013 your `RouterDelegate`.\n\nIt separates the *detection* of the back button press from the *logic* of what happens when it's pressed, keeping responsibilities clear.\n\n## How to Use a BackButtonDispatcher\n\nYou typically don't build your own custom `BackButtonDispatcher` from scratch for a basic app. Flutter provides standard implementations that you simply provide to your `Router` (or `MaterialApp.router`).\n\nFor the main, top-level `Router` in your app, you'll almost always use the `RootBackButtonDispatcher`. We'll cover `RootBackButtonDispatcher` in more detail in [Chapter 7](07_rootbackbuttondispatcher_.md), but for now, just know that it's the concrete class that listens to the platform's default back button messages.\n\nHere's how you integrate it into your `MaterialApp.router` setup:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the BackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Using the root dispatcher\n\n    );\n  }\n}\n```\n\nBy providing a `RootBackButtonDispatcher` to the `backButtonDispatcher` property, you're telling the `Router` widget: \"Use this object to listen for system back button presses.\"\n\nWhen the user presses the back button, the `RootBackButtonDispatcher` catches it and notifies the `Router`. The `Router` then calls your `RouterDelegate`'s `popRoute` method. As we saw in [Chapter 4](04_routerdelegate_.md), if you use the `PopNavigatorRouterDelegateMixin`, your `popRoute` method will automatically try to pop the top-most page from the `Navigator`.\n\nSo, in essence, providing a `RootBackButtonDispatcher` and using `PopNavigatorRouterDelegateMixin` in your `RouterDelegate` gives you standard back button behavior that pops screens from your primary `Navigator`.\n\n## Internal View (How Flutter Uses It)\n\nLet's see how the `Router` widget (`packages/flutter/lib/src/widgets/router.dart`) interacts with the `BackButtonDispatcher`.\n\nThe `Router`'s internal state (`_RouterState`) registers itself as a listener with the `BackButtonDispatcher` in its `initState` method:\n\n```dart\n// Snippet from _RouterState.initState\n@override\nvoid initState() {\n  super.initState();\n  // ... other listeners ...\n  // Router registers as a listener to the back button dispatcher!\n  widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n  // ... rest of initState ...\n}\n```\n\nThis means when the `BackButtonDispatcher` receives a back button event and calls its `invokeCallback` method, the `_handleBackButtonDispatcherNotification` method in the `_RouterState` will be executed.\n\nWhat does `_handleBackButtonDispatcherNotification` do? It's responsible for telling the **[RouterDelegate](04_routerdelegate_.md)** to handle the pop request:\n\n```dart\n// Snippet from _RouterState._handleBackButtonDispatcherNotification\nFuture<bool> _handleBackButtonDispatcherNotification() {\n  // Create a new transaction object (used internally to track simultaneous requests)\n  _currentRouterTransaction = Object();\n  // *** Call the delegate's popRoute method! ***\n  return widget.routerDelegate.popRoute().then<bool>(\n    // Process the result from popRoute (true/false)\n    _handleRoutePopped(_currentRouterTransaction),\n  );\n}\n```\n\nLet's break this down:\n\n1.  When the `BackButtonDispatcher` notifies the `Router`, `_handleBackButtonDispatcherNotification` is called.\n2.  Crucially, it calls `widget.routerDelegate.popRoute()`. This redirects the responsibility of handling the back action to the `RouterDelegate`.\n3.  The `RouterDelegate`'s `popRoute` method (which, with `PopNavigatorRouterDelegateMixin`, calls `Navigator.maybePop()`) attempts to handle the back event. It returns a `Future<bool>`: `true` if it successfully popped something, `false` otherwise.\n4.  The `.then<bool>` structure waits for this `Future<bool>` to complete. The result (`true` or `false`) is then passed to `_handleRoutePopped`.\n\nThe `_handleRoutePopped` method simply processes the result:\n\n```dart\n// Snippet from _RouterState._handleRoutePopped\n_AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n  return (bool data) { // 'data' is the true/false result from popRoute()\n    if (transaction != _currentRouterTransaction) {\n      // If a new transaction started while we were waiting for popRoute,\n      // assume this pop was handled to avoid unwanted bubbling.\n      return SynchronousFuture<bool>(true);\n    }\n    // Trigger a rebuild of the Router (which calls the delegate's build)\n    _rebuild();\n    // Return the actual result (true/false) so the dispatcher knows if it was handled\n    return SynchronousFuture<bool>(data);\n  };\n}\n```\n\nThis method:\n\n1.  Receives the boolean result `data` from the `RouterDelegate.popRoute()`.\n2.  If the pop was handled (`data` is `true`), it calls `_rebuild()`, which causes the `Router` to rebuild, reflecting the popped page (e.g., the `Navigator` with one less page).\n3.  It returns the `data` result (`true` or `false`) back up the chain. This result goes back to the `BackButtonDispatcher`, which can use it to signal to the platform whether the event was fully handled by Flutter (preventing the OS from, say, closing the entire app).\n\nThese internal steps illustrate how the `BackButtonDispatcher` acts as the initial trigger for back button handling, forwarding the request to the **[Router](05_router_.md)**, which then relies on the **[RouterDelegate](04_routerdelegate_.md)** to perform the actual logic.\n\n## Conclusion\n\nThe `BackButtonDispatcher` is the abstraction responsible for catching system back button presses and initiating the backward navigation process within your Flutter app's routing system. It acts as a listener for platform-specific back events and effectively notifies the **[Router](05_router_.md)**, which then directs the responsibility to the **[RouterDelegate](04_routerdelegate_.md)**'s `popRoute` method. By using a `RootBackButtonDispatcher` at the top level of your app and implementing `popRoute` (often with the help of `PopNavigatorRouterDelegateMixin`), you ensure that the system back button interacts correctly with your app's navigation stack.\n\nIn the next two chapters, we'll look closer at the common implementations: [RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md) and [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md).\n\n[Next Chapter: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)\n---\n# Chapter 7: RootBackButtonDispatcher\n\nWelcome back! In the last chapter, we learned about the [BackButtonDispatcher](06_backbuttondispatcher_.md), the mechanism that listens for system back button presses and forwards them to the [Router](05_router_.md). We saw that it's how Flutter handles those important \"go back\" requests from the operating system, especially on platforms like Android.\n\nNow, we're going to look at a specific and very common type of [BackButtonDispatcher](06_backbuttondispatcher_.md): the `RootBackButtonDispatcher`.\n\n## What is a RootBackButtonDispatcher?\n\nThink of the `RootBackButtonDispatcher` as the **primary listener for system back buttons for your app's main navigation**. It's the one that sits at the highest level of your routing setup and is the first to hear when the user presses the device's back button.\n\nIts main job is simple:\n\n1.  **Listen to the Platform:** It registers with the underlying operating system to receive notifications whenever the global \"pop route\" event occurs (which happens when the user presses the back button).\n2.  **Notify the Router:** When it receives such a notification, it immediately tells the **[Router](05_router_.md)** it's associated with that a back request has happened.\n\nIt doesn't decide *what* happens when the back button is pressed; that's the job of the [RouterDelegate](04_routerdelegate_.md). The `RootBackButtonDispatcher` is solely responsible for *detecting* the system event and ensuring the top-level [Router](05_router_.md) is informed.\n\nIt's called \"Root\" because it's intended for the main, un-nested [Router](05_router_.md) at the root of your application's navigation hierarchy.\n\nHere's the flow we saw in [Chapter 6](06_backbuttondispatcher_.md), specifically with the `RootBackButtonDispatcher`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant RootDispatcher as RootBackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate\n\n    User->>System: Presses back button\n    System->>RootDispatcher: Sends back button event\n    RootDispatcher->>RootDispatcher: Receives event\n    RootDispatcher->>Router: Notifies Router of back request\n    Router->>Delegate: Calls Delegate.popRoute()\n    Delegate->>Delegate: Tries to pop a screen (e.g., Navigator.maybePop())\n    Delegate-->>Router: Returns true (handled) or false (not handled)\n    Router-->>RootDispatcher: Returns true/false\n    RootDispatcher-->>System: Communicates handling status\n```\n\n## Why Do We Use a RootBackButtonDispatcher?\n\nFor most standard Flutter applications using the declarative router, you need *one* object that is responsible for catching the system back button event at the highest level. The `RootBackButtonDispatcher` is the built-in, standard way to achieve this.\n\nIf you don't provide any [BackButtonDispatcher](06_backbuttondispatcher_.md) to your root [Router](05_router_.md) (like the one managed by `MaterialApp.router`), system back button presses might not be handled correctly by your declarative routing system. You need an object connected to the `Router` that is specifically listening for these events.\n\nUsing `RootBackButtonDispatcher` gives you:\n\n*   **Standard Platform Integration:** It knows how to hook into the platform's native back button events.\n*   **Initial Back Button Handling Trigger:** It serves as the starting point for the back button event processing chain (RootDispatcher -> [Router](05_router_.md) -> [RouterDelegate](04_routerdelegate_.md)).\n\n## How to Use RootBackButtonDispatcher\n\nAs we briefly saw in the previous chapter, using `RootBackButtonDispatcher` is straightforward. You instantiate it and provide it to the `backButtonDispatcher` property of your main `Router` widget. Since `MaterialApp.router` creates the main `Router` for you, you provide it there:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assumes this has MyAppRouteInformationParser etc.\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // MaterialApp.router creates and manages a Router widget internally\n    return MaterialApp.router(\n      title: 'My Router App',\n      routeInformationProvider: PlatformRouteInformationProvider(\n        initialRouteInformation: RouteInformation(uri: Uri.parse('/')),\n      ),\n      routeInformationParser: MyAppRouteInformationParser(), // From Chapter 3\n      routerDelegate: MyAppRouterDelegate(),           // From Chapter 4\n\n      // *** Provide the RootBackButtonDispatcher here! ***\n      backButtonDispatcher: RootBackButtonDispatcher(), // Simple instantiation\n\n    );\n  }\n}\n```\n\nThat's it! You don't need to configure the `RootBackButtonDispatcher` any further for basic usage. By passing `RootBackButtonDispatcher()` to the `backButtonDispatcher` property, you are giving the `Router` the listener it needs to react to system back button pushes.\n\nThe `RootBackButtonDispatcher` itself doesn't require any arguments or complex setup for this purpose. It simply plugs into the platform's back button event system.\n\nRemember from [Chapter 4](04_routerdelegate_.md) that your `MyAppRouterDelegate` should implement the `popRoute` method (usually by mixing in `PopNavigatorRouterDelegateMixin`) for the back button press to actually do something like pop a screen from a `Navigator`. The `RootBackButtonDispatcher` just gets the event to the `Router`, and the `Router` passes it to the delegate's `popRoute`.\n\n## Internal View (How Flutter Uses RootBackButtonDispatcher)\n\nLet's dive a little deeper into the code to see how `RootBackButtonDispatcher` achieves its goal.\n\nThe `RootBackButtonDispatcher` class inherits from the base `BackButtonDispatcher` and also `WidgetsBindingObserver`:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  // ... methods below ...\n}\n```\nBy mixing in `WidgetsBindingObserver`, the `RootBackButtonDispatcher` can listen to system events delivered via the `WidgetsBinding.instance`.\n\nWhen the `Router` associated with this dispatcher starts up, it calls `addCallback` on the `RootBackButtonDispatcher` (as we saw in [Chapter 6](06_backbuttondispatcher_.md)'s internal view).\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (_RouterState.initState)\nwidget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n```\n\nThe `RootBackButtonDispatcher` overrides the `addCallback` method to start listening to the `WidgetsBinding` if it's the first callback being added:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid addCallback(ValueGetter<Future<bool>> callback) {\n  if (!hasCallbacks) { // hasCallbacks comes from the base BackButtonDispatcher\n    WidgetsBinding.instance.addObserver(this); // Starts listening to platform events!\n  }\n  super.addCallback(callback); // Add the provided callback (from the Router)\n}\n```\n\nThis `WidgetsBinding.instance.addObserver(this)` call is key. It registers the `RootBackButtonDispatcher` instance to receive important system event notifications, including `didPopRoute`.\n\nWhen the user presses the system back button, the Flutter engine on the platform side catches it and signals the framework through `WidgetsBinding`. This triggers the `didPopRoute` method *on the registered observer* (our `RootBackButtonDispatcher` instance):\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nFuture<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n```\n\nHere's what happens in `didPopRoute`:\n\n1.  It calls `invokeCallback`. This method, inherited from the base `BackButtonDispatcher`, is designed to call the callbacks that have been `addCallback`-ed to it.\n2.  As we saw earlier, the `Router` added a callback (`_handleBackButtonDispatcherNotification`) that triggers the `routerDelegate.popRoute()`.\n3.  So, the `didPopRoute` call effectively results in our `Router`'s `_handleBackButtonDispatcherNotification` being executed, which in turn calls our custom `RouterDelegate`'s `popRoute` method.\n4.  The result of `routerDelegate.popRoute()` (true/false future) is then returned by `invokeCallback` and subsequently by `didPopRoute`. This result goes back to the `WidgetsBinding`, indicating whether Flutter handled the pop request internally or if the underlying platform should proceed with its default behavior (like closing the app).\n\nThe `removeCallback` method in `RootBackButtonDispatcher` does cleanup, removing the observer if no more callbacks are listening:\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart (RootBackButtonDispatcher)\n@override\nvoid removeCallback(ValueGetter<Future<bool>> callback) {\n  super.removeCallback(callback);\n  if (!hasCallbacks) {\n    WidgetsBinding.instance.removeObserver(this); // Stop listening to platform events\n  }\n}\n```\n\nThis internal structure shows that the `RootBackButtonDispatcher` is a specialized `BackButtonDispatcher` that uses `WidgetsBindingObserver` to be the initial point of contact for system back button events, forwarding them through the generic `invokeCallback` mechanism to the registered listeners (the `Router`).\n\n## Conclusion\n\nThe `RootBackButtonDispatcher` is the standard, top-level component for receiving system back button presses in Flutter's declarative routing system. By providing an instance of `RootBackButtonDispatcher` to your root `Router`, you ensure that the system back button events are caught and properly dispatched to your `RouterDelegate`'s `popRoute` method for handling (typically popping a screen from a `Navigator`). It acts as the crucial bridge between the platform's back button mechanism and your application's routing logic.\n\nIn the next chapter, we'll look at the [ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md), which is used when you have nested `Router`s and need more fine-grained control over which part of your UI handles the back button.\n\n[Next Chapter: ChildBackButtonDispatcher](08_childbackbuttondispatcher_.md)\n---\n# Chapter 8: ChildBackButtonDispatcher\n\nWelcome back! Over the past seven chapters, we've journeyed through the core components of Flutter's Declarative Router system, covering everything from the \"note\" ([Chapter 1: RouteInformation](01_routeinformation_.md)) to the \"orchestrator\" ([Chapter 5: Router](05_router_.md)) and the \"system back button listener\" ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md) and [Chapter 7: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md)).\n\nYou learned that the `RootBackButtonDispatcher` is essential for catching global system back button presses and sending them to your *main* [Router](05_router_.md). But what if your app has a more complex layout?\n\n## Why Nested Routers Need ChildBackButtonDispatcher\n\nImagine your app has a main screen with a tab bar at the bottom. Each tab has its own separate navigation flow. For instance:\n\n*   **Tab A:** A list of items -> Item Detail -> Another sub-page.\n*   **Tab B:** User profile -> Edit profile.\n*   **Tab C:** Settings.\n\n```mermaid\ngraph TD\n    A[App Root (Router)] --&gt; B[Main Screen (Tab Bar)]\n    B --&gt; C{Tab A}\n    B --&gt; D{Tab B}\n    B --&gt; E{Tab C}\n    C --&gt; F[Item List]\n    F --&gt; G[Item Detail]\n    D --&gt; H[Profile]\n    H --&gt; I[Edit Profile]\n```\n\nIn this setup, you might use a separate [Router](05_router_.md) and [RouterDelegate](04_routerdelegate_.md) *within each tab*. This allows each tab to manage its own navigation stack independently.\n\nNow, consider the user pressing the system back button. What should happen?\n\n*   If they are deep inside **Tab A**'s detail page, you likely want the back button to pop *within Tab A*.\n*   Only if they are at the root of **Tab A** (the item list) should the back button switch tabs or potentially go back from the main screen.\n\nThe `RootBackButtonDispatcher` sends the back event to the *main* [Router](05_router_.md) at the top of your app. But that main [Router](05_router_.md) doesn't know which tab is currently active or which nested [Router](05_router_.md) should handle the pop request.\n\nThis is the problem the `ChildBackButtonDispatcher` solves!\n\n## What is a ChildBackButtonDispatcher?\n\nA `ChildBackButtonDispatcher` is a type of [BackButtonDispatcher](06_BackButtonDispatcher.md) designed specifically for **nested [Router](05_router.md)s**. Instead of listening to the platform directly like the `RootBackButtonDispatcher`, it listens to a *parent* [BackButtonDispatcher](06_BackButtonDispatcher.md).\n\nIts core responsibilities are:\n\n1.  **Listen to a Parent:** It receives back button notifications from the [BackButtonDispatcher](06_BackButtonDispatcher.md) higher up in the hierarchy (usually the `RootBackButtonDispatcher` or another `ChildBackButtonDispatcher`).\n2.  **Connect to a Child Router:** It's associated with a specific nested [Router](05_router.md).\n3.  **Claim Priority:** It can signal to its parent that its associated nested [Router](05_router.md) is currently active and *should* be given the *first chance* to handle any incoming back button notifications.\n4.  **Dispatch to the Child Router:** If its parent gives it priority, it forwards the back button notification to its associated nested [Router](05_router.md) (which then calls its nested [RouterDelegate](04_routerdelegate_.md)'s `popRoute` method).\n\nThink of the `ChildBackButtonDispatcher` as a representative for its nested [Router](05_router.md), telling the back button system: \"Hey, my section of the UI is currently focused, send the back events here first!\"\n\nHere's the flow with nested dispatchers:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant System as OS Back Button\n    participant RootDispatcher as RootBackButtonDispatcher (Parent)\n    participant ChildDispatcherA as ChildBackButtonDispatcher (for Tab A)\n    participant ChildDispatcherB as ChildBackButtonDispatcher (for Tab B)\n    participant ActiveChildDispatcher as Currently Active ChildDispatcher (e.g. ChildDispatcherA)\n    participant NestedRouter as Nested Router (e.g. for Tab A)\n    participant NestedDelegate as Nested RouterDelegate\n\n    User->>System: Presses back button\n    System->>RootDispatcher: Back button event\n    RootDispatcher->>ActiveChildDispatcher: Notifies active child\n    ActiveChildDispatcher->>NestedRouter: Notifies associated Router\n    NestedRouter->>NestedDelegate: Calls popRoute()\n    NestedDelegate-->>NestedRouter: Returns true/false (handled?)\n    NestedRouter-->>ActiveChildDispatcher: Returns true/false\n    ActiveChildDispatcher-->>RootDispatcher: Returns true/false\n    alt Handled by Active Child (returns true)\n        RootDispatcher-->>System: Reports back button handled\n    else Not Handled by Active Child (returns false)\n        RootDispatcher->>RootDispatcher: Asks its own listeners (e.g., its RouterDelegate)\n        RootDispatcher-->>System: Reports handling status\n    end\n```\n\nThis diagram illustrates that the `RootBackButtonDispatcher` is the initial receiver, but it then checks with its \"children\" (the `ChildBackButtonDispatcher`s that have claimed priority) to see who should handle the event first.\n\n## How to Use ChildBackButtonDispatcher\n\nTo use a `ChildBackButtonDispatcher`, you need two things:\n\n1.  **A Parent Dispatcher:** This will be the [BackButtonDispatcher](06_BackButtonDispatcher.md) of the [Router](05_router.md) widget higher up in the tree (usually the `RootBackButtonDispatcher` of your main app [Router](05_router.md)). You can get this using `Router.of(context).backButtonDispatcher`.\n2.  **A Child Router:** The `ChildBackButtonDispatcher` will be provided to the `backButtonDispatcher` property of your nested [Router](05_router.md).\n\nLet's sketch out how you might set this up for a tabbed interface, assuming you have a main `MaterialApp.router` and then a `Router` inside each tab's content widget.\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'my_app_routing.dart'; // Assume custom delegates for tabs\n\n// Assume MyAppRouterDelegate implements routing for the main app (e.g., showing tabs)\n// Assume MyAppRouteInformationParser handles parsing main paths (e.g., /tab_a)\n\n// Assume you have separate delegates and parsers for each tab's routing\n// Example: TabARouterDelegate, TabARouteInformationParser, TabAConfig\n\nclass MainScreenWithTabs extends StatefulWidget {\n  // ... constructor and state management for current tab ...\n  final int currentTab; // Assume this state exists\n  const MainScreenWithTabs({super.key, required this.currentTab});\n\n  @override\n  State<MainScreenWithTabs> createState() => _MainScreenWithTabsState();\n}\n\nclass _MainScreenWithTabsState extends State<MainScreenWithTabs> {\n   // We need separate delegates and parsers for each tab's *nested* router\n   // Their configurations would be different from the main app config\n   late final TabARouterDelegate _tabARouterDelegate;\n   late final TabARouteInformationParser _tabARouteInformationParser;\n    late final TabBRouterDelegate _tabBRouterDelegate;\n   late final TabBRouteInformationParser _tabBRouteInformationParser;\n\n   @override\n   void initState() {\n       super.initState();\n       _tabARouterDelegate = TabARouterDelegate();\n       _tabARouteInformationParser = TabARouteInformationParser();\n       _tabBRouterDelegate = TabBRouterDelegate();\n       _tabBRouteInformationParser = TabBRouteInformationParser();\n   }\n\n   @override\n   void dispose() {\n       _tabARouterDelegate.dispose();\n       _tabBRouterDelegate.dispose();\n       super.dispose();\n   }\n\n  @override\n  Widget build(BuildContext context) {\n    // Get the parent BackButtonDispatcher (from the main app Router)\n    final BackButtonDispatcher parentBackButtonDispatcher =\n        Router.of(context).backButtonDispatcher!;\n\n    // Create a ChildBackButtonDispatcher for each tab's future Router\n    final ChildBackButtonDispatcher tabABackButtonDispatcher =\n        parentBackButtonDispatcher.createChildBackButtonDispatcher();\n    final ChildBackButtonDispatcher tabBBackButtonDispatcher =\n        parentBackButtonDispatcher.createChildBackButtonDispatcher();\n\n    // *** Important: Tell the currently active tab's dispatcher to take priority! ***\n    // This is usually done whenever the tab selection changes.\n    // For simplicity here, we'll do it based on the current tab index in build.\n    // A real implementation might do this in a state change callback.\n    if (widget.currentTab == 0) {\n        tabABackButtonDispatcher.takePriority();\n    } else if (widget.currentTab == 1) {\n        tabBBackButtonDispatcher.takePriority();\n    }\n    // Tab C might not have a nested router, or claim priority only when a specific view is shown.\n\n    Widget tabContent;\n    if (widget.currentTab == 0) {\n      tabContent = Router<TabAConfig>( // Nested Router for Tab A\n        routerDelegate: _tabARouterDelegate,\n        routeInformationParser: _tabARouteInformationParser,\n        // *** Provide the ChildBackButtonDispatcher to the nested Router! ***\n        backButtonDispatcher: tabABackButtonDispatcher,\n      );\n    } else if (widget.currentTab == 1) {\n       tabContent = Router<TabBConfig>( // Nested Router for Tab B\n        routerDelegate: _tabBRouterDelegate,\n        routeInformationParser: _tabBRouteInformationParser,\n         // *** Provide the ChildBackButtonDispatcher to the nested Router! ***\n        backButtonDispatcher: tabBBackButtonDispatcher,\n      );\n    } else {\n       tabContent = Center(child: Text('Settings Tab')); // Tab C - no nested router needed here\n    }\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('App with Tabs')),\n      body: tabContent, // Show the content of the current tab\n      bottomNavigationBar: BottomNavigationBar(\n         currentIndex: widget.currentTab,\n         onTap: (index) { /* Update widget.currentTab state and rebuild */}\n         // ... items for tabs ...\n      ),\n    );\n  }\n}\n```\n\nBreaking down the key parts of using `ChildBackButtonDispatcher`:\n\n1.  **Get the Parent:** `Router.of(context).backButtonDispatcher!` retrieves the `BackButtonDispatcher` from the nearest ancestor [Router](05_router.md) (in this case, the main app [Router](05_router.md) set up by `MaterialApp.router`). We use `!` assuming the main router *has* a dispatcher (like `/ RootBackButtonDispatcher`).\n2.  **Create Children:** `parentBackButtonDispatcher.createChildBackButtonDispatcher()` is the method on the parent where you create instances of `ChildBackButtonDispatcher` that are linked to this parent.\n3.  **Provide to Nested Router:** Each `ChildBackButtonDispatcher` is then given to the `backButtonDispatcher` property of the specific nested [Router](05_router.md) it manages.\n4.  **Claim Priority (`takePriority()`):** This is arguably the most important step for nested routers. When a nested [Router](05_router.md)'s content becomes the user's *focus* (e.g., when a user switches tabs), you must call `takePriority()` on that nested [Router](05_router.md)'s `ChildBackButtonDispatcher`. This tells the parent dispatcher: \"If a back button event comes in, ask *me* first before anyone else (or before handling it yourself).\"\n\nWhen the user presses the back button:\n\n*   The event is first caught by the `RootBackButtonDispatcher`.\n*   The `RootBackButtonDispatcher` checks if any of its `ChildBackButtonDispatcher`s have called `takePriority()` most recently.\n*   If the `ChildBackButtonDispatcher` for the currently active tab (e.g., Tab A) called `takePriority()`, the `RootBackButtonDispatcher` forwards the back request to *that* `ChildBackButtonDispatcher`.\n*   That `ChildBackButtonDispatcher` then notifies its associated nested [Router](05_router.md).\n*   The nested [Router](05_router.md) calls its nested [RouterDelegate](04_routerdelegate_.md)'s `popRoute()` method.\n*   If the nested [RouterDelegate](04_routerDelegate_.md) (e.g., for Tab A) successfully pops a screen from its `Navigator`, its `popRoute()` returns `Future.value(true)`.\n*   This `true` bubbles back up through the `ChildBackButtonDispatcher` to the `RootBackButtonDispatcher`, signaling that the back event was fully handled internally. The OS default pop (like closing the app) is then prevented.\n*   If the nested [RouterDelegate](04_routerDelegate_.md)'s `popRoute()` returns `Future.value(false)` (meaning the nested tab's `Navigator` couldn't pop anything because it was already at its root), the `ChildBackButtonDispatcher` also returns `false` to the `RootBackButtonDispatcher`.\n*   The `RootBackButtonDispatcher` then proceeds to ask its *own* listeners (which include the main app [Router](05_router.md)'s primary listener, which would call the main app [RouterDelegate](04_routerDelegate_.md)'s `popRoute`). This would allow the main app [RouterDelegate](04_routerDelegate_.md) to handle the back press, perhaps by changing tabs or exiting the app.\n\nThis priority system ([deferTo](https://api.flutter.dev/flutter/widgets/BackButtonDispatcher/deferTo.html) and [takePriority](https://api.flutter.dev/flutter/widgets/BackButtonDispatcher/takePriority.html)) managed by the parent and child dispatchers is what makes nested back button handling work correctly.\n\nA common helper widget is [BackButtonListener](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html). This widget automatically creates a `ChildBackButtonDispatcher` linked to the nearest ancestor [Router](05_router.md)'s dispatcher and calls `takePriority()` when the widget is first built. It also handles removing itself when it's disposed. This is useful if you just need a specific widget *deeper* in the tree (not a whole nested `Router`) to temporarily handle back button presses.\n\n## Internal View (How Flutter Uses ChildBackButtonDispatcher)\n\nLet's look at some code snippets from `packages/flutter/lib/src/widgets/router.dart` to see how `ChildBackButtonDispatcher` works with its parent.\n\nRecall in [Chapter 6](06_backbuttondispatcher_.md), we saw the base `BackButtonDispatcher` has an `invokeCallback` method and keeps a list of potential children that might take priority (`_children`).\n\nThe `RootBackButtonDispatcher`'s `didPopRoute` method (which catches the native back event) simply calls `invokeCallback`:\n\n```dart\n// Snippet from RootBackButtonDispatcher\n@override\nFuture<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n```\n\nThe base `BackButtonDispatcher.invokeCallback` method is where the child prioritization logic lives:\n\n```dart\n// Snippet from BackButtonDispatcher.invokeCallback\n@override\nFuture<bool> invokeCallback(Future<bool> defaultValue) {\n  if (_children.isNotEmpty) { // Check if there are children that claimed priority\n    final List<ChildBackButtonDispatcher> children = _children.toList();\n    int childIndex = children.length - 1; // Start with the most recent child\n\n    Future<bool> notifyNextChild(bool result) {\n      if (result) { // If the previous child handled it (returned true)\n        return SynchronousFuture<bool>(result); // Stop and return true\n      }\n      // If not handled, go to the next child in the priority list (backwards)\n      if (childIndex > 0) {\n        childIndex -= 1;\n        // *** Recursively call notifiedByParent on the child ***\n        return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n      }\n      // No children handled it, call the parent's own callbacks\n      return super.invokeCallback(defaultValue);\n    }\n    // Start the process by asking the latest child\n    return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n  }\n  // No children claimed priority, call the parent's own callbacks\n  return super.invokeCallback(defaultValue);\n}\n```\n\nThis shows the delegation:\n1.  `invokeCallback` checks if there are prioritized children (`_children`).\n2.  If yes, it starts a chain, calling `notifiedByParent` on the most recently prioritized child.\n3.  If that child's `notifiedByParent` returns `false` (didn't handle it), it moves to the *next* child in the priority list and calls its `notifiedByParent`, and so on.\n4.  If any child returns `true`, the chain stops, and `true` is returned all the way up.\n5.  If *no* children handle it (all return `false`), the `invokeCallback` finally calls `super.invokeCallback(defaultValue)`, which triggers the parent's own registered callbacks (like the one from the `Router` itself, which calls its `RouterDelegate.popRoute`).\n\nNow, let's look at the `ChildBackButtonDispatcher`. Its key method is `notifiedByParent`:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.notifiedByParent\n@protected\nFuture<bool> notifiedByParent(Future<bool> defaultValue) {\n  // A child dispatcher simply calls its OWN invokeCallback.\n  // Its own callbacks are the ones added by the nested Router it's linked to.\n  return invokeCallback(defaultValue);\n}\n```\n\nThis method is simple: when the parent `BackButtonDispatcher` calls `notifiedByParent` on a `ChildBackButtonDispatcher`, the child simply calls *its own* `invokeCallback`. As we know, a `BackButtonDispatcher`'s `invokeCallback` calls the registered callbacks (which is the nested [Router](05_router.md)'s callback that triggers its [RouterDelegate](04_routerDelegate_.md).popRoute()). This completes the chain of delegation.\n\nThe `takePriority` method in `ChildBackButtonDispatcher` does two things:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.takePriority\n@override\nvoid takePriority() {\n  // Tell the parent to defer to THIS child\n  parent.deferTo(this);\n  // Clear this child's own inner children (if it had any)\n  super.takePriority();\n}\n```\n\n1.  `parent.deferTo(this)`: This is how the child tells the parent to add it to the parent's `_children` list. This marks this child dispatcher as one that should be checked when the parent receives a back event. If called multiple times, `deferTo` moves the child to the end of the parent's priority list, making it the *most recent* and hence the *first* to be checked.\n2.  `super.takePriority()`: This clears the `_children` list *within* this specific `ChildBackButtonDispatcher`. This ensures that this dispatcher prioritizes its *own* callbacks (those added by its associated nested [Router](05_router.md)) over any children *it* might have (relevant for deeply nested structures).\n\nFinally, the `removeCallback` in `ChildBackButtonDispatcher` ensures cleanup. When the nested [Router](05_router.md) or the widget using a [BackButtonListener](https://api.flutter.dev/flutter/widgets/BackButtonListener-class.html) is disposed, it removes its callback from the `ChildBackButtonDispatcher`. If the `ChildBackButtonDispatcher` then has no more callbacks (meaning its associated nested part of the UI is gone), it automatically tells its parent to \"forget\" about it:\n\n```dart\n// Snippet from ChildBackButtonDispatcher.removeCallback\n@override\nvoid removeCallback(ValueGetter<Future<bool>> callback) {\n  super.removeCallback(callback);\n  if (!hasCallbacks) { // If no callbacks are left on this child dispatcher\n    parent.forget(this); // Tell the parent to remove this child from its priority list\n  }\n}\n```\n\nThis `parent.forget(this)` call is how the parent `BackButtonDispatcher` knows that a child is no longer active and shouldn't be considered for back button priority anymore.\n\nThese internal workings show the elegant delegation pattern: the `RootBackButtonDispatcher` starts the process, which cascades down through `ChildBackButtonDispatcher`s that have claimed priority. The first one able to handle the pop (by its associated [RouterDelegate](04_routerDelegate_.md) returning `true`) stops the cascade.\n\n## Conclusion\n\nThe `ChildBackButtonDispatcher` is essential for managing back button behavior in apps with nested routing. It doesn't listen to the platform directly but instead connects to a parent [BackButtonDispatcher](06_BackButtonDispatcher.md). By calling `takePriority()`, a `ChildBackButtonDispatcher` signals its associated nested [Router](05_router.md) should be given the opportunity to handle back button events first. This mechanism ensures that back presses are directed to the most relevant part of your UI hierarchy, allowing for intuitive navigation within complex layouts like tabbed interfaces.\n\nIn the next chapter, we'll look at the [PopNavigatorRouterDelegateMixin](09_popnavigatorrouterdelegatemixin_.md), a very common helper mixin for `RouterDelegate`s that simplifies integrating back button handling with a `Navigator`.\n\n[Next Chapter: PopNavigatorRouterDelegateMixin](09_popnavigatorrouterdelegatemixin_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/router.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'scroll_view.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:collection';\n\nimport 'package:collection/collection.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'basic.dart';\nimport 'binding.dart';\nimport 'framework.dart';\nimport 'navigator.dart';\nimport 'restoration.dart';\nimport 'restoration_properties.dart';\n\n/// A piece of routing information.\n///\n/// The route information consists of a location string of the application and\n/// a state object that configures the application in that location.\n///\n/// This information flows two ways, from the [RouteInformationProvider] to the\n/// [Router] or from the [Router] to [RouteInformationProvider].\n///\n/// In the former case, the [RouteInformationProvider] notifies the [Router]\n/// widget when a new [RouteInformation] is available. The [Router] widget takes\n/// these information and navigates accordingly.\n///\n/// The latter case happens in web application where the [Router] reports route\n/// changes back to the web engine.\n///\n/// The current [RouteInformation] of an application is also used for state\n/// restoration purposes. Before an application is killed, the [Router] converts\n/// its current configurations into a [RouteInformation] object utilizing the\n/// [RouteInformationProvider]. The [RouteInformation] object is then serialized\n/// out and persisted. During state restoration, the object is deserialized and\n/// passed back to the [RouteInformationProvider], which turns it into a\n/// configuration for the [Router] again to restore its state from.\nclass RouteInformation {\n  /// Creates a route information object.\n  ///\n  /// Either `location` or `uri` must not be null.\n  const RouteInformation({\n    @Deprecated(\n      'Pass Uri.parse(location) to uri parameter instead. '\n      'This feature was deprecated after v3.8.0-3.0.pre.',\n    )\n    String? location,\n    Uri? uri,\n    this.state,\n  }) : _location = location,\n       _uri = uri,\n       assert((location != null) != (uri != null));\n\n  /// The location of the application.\n  ///\n  /// The string is usually in the format of multiple string identifiers with\n  /// slashes in between. ex: `/`, `/path`, `/path/to/the/app`.\n  @Deprecated(\n    'Use uri instead. '\n    'This feature was deprecated after v3.8.0-3.0.pre.',\n  )\n  String get location {\n    return _location ??\n        Uri.decodeComponent(\n          Uri(\n            path: uri.path.isEmpty ? '/' : uri.path,\n            queryParameters: uri.queryParametersAll.isEmpty ? null : uri.queryParametersAll,\n            fragment: uri.fragment.isEmpty ? null : uri.fragment,\n          ).toString(),\n        );\n  }\n\n  final String? _location;\n\n  /// The uri location of the application.\n  ///\n  /// The host and scheme will not be empty if this object is created from a\n  /// deep link request. They represents the website that redirect the deep\n  /// link.\n  ///\n  /// In web platform, the host and scheme are always empty.\n  Uri get uri {\n    if (_uri != null) {\n      return _uri;\n    }\n    return Uri.parse(_location!);\n  }\n\n  final Uri? _uri;\n\n  /// The state of the application in the [uri].\n  ///\n  /// The app can have different states even in the same location. For example,\n  /// the text inside a [TextField] or the scroll position in a [ScrollView].\n  /// These widget states can be stored in the [state].\n  ///\n  /// On the web, this information is stored in the browser history when the\n  /// [Router] reports this route information back to the web engine\n  /// through the [PlatformRouteInformationProvider]. The information\n  /// is then passed back, along with the [uri], when the user\n  /// clicks the back or forward buttons.\n  ///\n  /// This information is also serialized and persisted alongside the\n  /// [uri] for state restoration purposes. During state restoration,\n  /// the information is made available again to the [Router] so it can restore\n  /// its configuration to the previous state.\n  ///\n  /// The state must be serializable.\n  final Object? state;\n}\n\n/// A convenient bundle to configure a [Router] widget.\n///\n/// To configure a [Router] widget, one needs to provide several delegates,\n/// [RouteInformationProvider], [RouteInformationParser], [RouterDelegate],\n/// and [BackButtonDispatcher]. This abstract class provides way to bundle these\n/// delegates into a single object to configure a [Router].\n///\n/// The [backButtonDispatcher], [routeInformationProvider], and\n/// [routeInformationProvider] are optional.\n///\n/// The [routeInformationProvider] and [routeInformationParser] must\n/// both be provided or both not provided.\nclass RouterConfig<T> {\n  /// Creates a [RouterConfig].\n  ///\n  /// The [backButtonDispatcher], [routeInformationProvider], and\n  /// [routeInformationParser] are optional.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must both be\n  /// provided or both not provided.\n  const RouterConfig({\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n  }) : assert((routeInformationProvider == null) == (routeInformationParser == null));\n\n  /// The [RouteInformationProvider] that is used to configure the [Router].\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The [RouteInformationParser] that is used to configure the [Router].\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The [RouterDelegate] that is used to configure the [Router].\n  final RouterDelegate<T> routerDelegate;\n\n  /// The [BackButtonDispatcher] that is used to configure the [Router].\n  final BackButtonDispatcher? backButtonDispatcher;\n}\n\n/// The dispatcher for opening and closing pages of an application.\n///\n/// This widget listens for routing information from the operating system (e.g.\n/// an initial route provided on app startup, a new route obtained when an\n/// intent is received, or a notification that the user hit the system back\n/// button), parses route information into data of type `T`, and then converts\n/// that data into [Page] objects that it passes to a [Navigator].\n///\n/// Each part of this process can be overridden and configured as desired.\n///\n/// The [routeInformationProvider] can be overridden to change how the name of\n/// the route is obtained. The [RouteInformationProvider.value] is used as the\n/// initial route when the [Router] is first created. Subsequent notifications\n/// from the [RouteInformationProvider] to its listeners are treated as\n/// notifications that the route information has changed.\n///\n/// The [backButtonDispatcher] can be overridden to change how back button\n/// notifications are received. This must be a [BackButtonDispatcher], which is\n/// an object where callbacks can be registered, and which can be chained so\n/// that back button presses are delegated to subsidiary routers. The callbacks\n/// are invoked to indicate that the user is trying to close the current route\n/// (by pressing the system back button); the [Router] ensures that when this\n/// callback is invoked, the message is passed to the [routerDelegate] and its\n/// result is provided back to the [backButtonDispatcher]. Some platforms don't\n/// have back buttons (e.g. iOS and desktop platforms); on those platforms this\n/// notification is never sent. Typically, the [backButtonDispatcher] for the\n/// root router is an instance of [RootBackButtonDispatcher], which uses a\n/// [WidgetsBindingObserver] to listen to the `popRoute` notifications from\n/// [SystemChannels.navigation]. Nested [Router]s typically use a\n/// [ChildBackButtonDispatcher], which must be provided the\n/// [BackButtonDispatcher] of its ancestor [Router] (available via [Router.of]).\n///\n/// The [routeInformationParser] can be overridden to change how names obtained\n/// from the [routeInformationProvider] are interpreted. It must implement the\n/// [RouteInformationParser] interface, specialized with the same type as the\n/// [Router] itself. This type, `T`, represents the data type that the\n/// [routeInformationParser] will generate.\n///\n/// The [routerDelegate] can be overridden to change how the output of the\n/// [routeInformationParser] is interpreted. It must implement the\n/// [RouterDelegate] interface, also specialized with `T`; it takes as input\n/// the data (of type `T`) from the [routeInformationParser], and is responsible\n/// for providing a navigating widget to insert into the widget tree. The\n/// [RouterDelegate] interface is also [Listenable]; notifications are taken\n/// to mean that the [Router] needs to rebuild.\n///\n/// ## Concerns regarding asynchrony\n///\n/// Some of the APIs (notably those involving [RouteInformationParser] and\n/// [RouterDelegate]) are asynchronous.\n///\n/// When developing objects implementing these APIs, if the work can be done\n/// entirely synchronously, then consider using [SynchronousFuture] for the\n/// future returned from the relevant methods. This will allow the [Router] to\n/// proceed in a completely synchronous way, which removes a number of\n/// complications.\n///\n/// Using asynchronous computation is entirely reasonable, however, and the API\n/// is designed to support it. For example, maybe a set of images need to be\n/// loaded before a route can be shown; waiting for those images to be loaded\n/// before [RouterDelegate.setNewRoutePath] returns is a reasonable approach to\n/// handle this case.\n///\n/// If an asynchronous operation is ongoing when a new one is to be started, the\n/// precise behavior will depend on the exact circumstances, as follows:\n///\n/// If the active operation is a [routeInformationParser] parsing a new route information:\n/// that operation's result, if it ever completes, will be discarded.\n///\n/// If the active operation is a [routerDelegate] handling a pop request:\n/// the previous pop is immediately completed with \"false\", claiming that the\n/// previous pop was not handled (this may cause the application to close).\n///\n/// If the active operation is a [routerDelegate] handling an initial route\n/// or a pushed route, the result depends on the new operation. If the new\n/// operation is a pop request, then the original operation's result, if it ever\n/// completes, will be discarded. If the new operation is a push request,\n/// however, the [routeInformationParser] will be requested to start the parsing, and\n/// only if that finishes before the original [routerDelegate] request\n/// completes will that original request's result be discarded.\n///\n/// If the identity of the [Router] widget's delegates change while an\n/// asynchronous operation is in progress, to keep matters simple, all active\n/// asynchronous operations will have their results discarded. It is generally\n/// considered unusual for these delegates to change during the lifetime of the\n/// [Router].\n///\n/// If the [Router] itself is disposed while an asynchronous operation is in\n/// progress, all active asynchronous operations will have their results\n/// discarded also.\n///\n/// No explicit signals are provided to the [routeInformationParser] or\n/// [routerDelegate] to indicate when any of the above happens, so it is\n/// strongly recommended that [RouteInformationParser] and [RouterDelegate]\n/// implementations not perform extensive computation.\n///\n/// ## Application architectural design\n///\n/// An application can have zero, one, or many [Router] widgets, depending on\n/// its needs.\n///\n/// An application might have no [Router] widgets if it has only one \"screen\",\n/// or if the facilities provided by [Navigator] are sufficient. This is common\n/// for desktop applications, where subsidiary \"screens\" are represented using\n/// different windows rather than changing the active interface.\n///\n/// A particularly elaborate application might have multiple [Router] widgets,\n/// in a tree configuration, with the first handling the entire route parsing\n/// and making the result available for routers in the subtree. The routers in\n/// the subtree do not participate in route information parsing but merely take the\n/// result from the first router to build their sub routes.\n///\n/// Most applications only need a single [Router].\n///\n/// ## URL updates for web applications\n///\n/// In the web platform, keeping the URL in the browser's location bar up to\n/// date with the application state ensures that the browser constructs its\n/// history entry correctly, allowing its back and forward buttons to function\n/// as the user expects.\n///\n/// If an app state change leads to the [Router] rebuilding, the [Router] will\n/// retrieve the new route information from the [routerDelegate]'s\n/// [RouterDelegate.currentConfiguration] method and the\n/// [routeInformationParser]'s [RouteInformationParser.restoreRouteInformation]\n/// method.\n///\n/// If the location in the new route information is different from the\n/// current location, this is considered to be a navigation event, the\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] method\n/// calls [SystemNavigator.routeInformationUpdated] with `replace = false` to\n/// notify the engine, and through that the browser, to create a history entry\n/// with the new url. Otherwise,\n/// [PlatformRouteInformationProvider.routerReportsNewRouteInformation] calls\n/// [SystemNavigator.routeInformationUpdated] with `replace = true` to update\n/// the current history entry with the latest [RouteInformation].\n///\n/// One can force the [Router] to report new route information as navigation\n/// event to the [routeInformationProvider] (and thus the browser) even if the\n/// [RouteInformation.uri] has not changed by calling the [Router.navigate]\n/// method with a callback that performs the state change. This causes [Router]\n/// to call the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.navigate], and thus causes\n/// [PlatformRouteInformationProvider] to push a new history entry regardlessly.\n/// This allows one to support the browser's back and forward buttons without\n/// changing the URL. For example, the scroll position of a scroll view may be\n/// saved in the [RouteInformation.state]. Using [Router.navigate] to update the\n/// scroll position causes the browser to create a new history entry with the\n/// [RouteInformation.state] that stores this new scroll position. When the user\n/// clicks the back button, the app will go back to the previous scroll position\n/// without changing the URL in the location bar.\n///\n/// One can also force the [Router] to ignore a navigation event by making\n/// those changes during a callback passed to [Router.neglect]. The [Router]\n/// calls the [RouteInformationProvider.routerReportsNewRouteInformation] with\n/// [RouteInformationReportingType.neglect], and thus causes\n/// [PlatformRouteInformationProvider] to replace the current history entry\n/// regardlessly even if it detects location change.\n///\n/// To opt out of URL updates entirely, pass null for [routeInformationProvider]\n/// and [routeInformationParser]. This is not recommended in general, but may be\n/// appropriate in the following cases:\n///\n/// * The application does not target the web platform.\n///\n/// * There are multiple router widgets in the application. Only one [Router]\n///   widget should update the URL (typically the top-most one created by the\n///   [WidgetsApp.router], [MaterialApp.router], or [CupertinoApp.router]).\n///\n/// * The application does not need to implement in-app navigation using the\n///   browser's back and forward buttons.\n///\n/// In other cases, it is strongly recommended to implement the\n/// [RouterDelegate.currentConfiguration] and\n/// [RouteInformationParser.restoreRouteInformation] APIs to provide an optimal\n/// user experience when running on the web platform.\n///\n/// ## State Restoration\n///\n/// The [Router] will restore the current configuration of the [routerDelegate]\n/// during state restoration if it is configured with a [restorationScopeId] and\n/// state restoration is enabled for the subtree. For that, the value of\n/// [RouterDelegate.currentConfiguration] is serialized and persisted before the\n/// app is killed by the operating system. After the app is restarted, the value\n/// is deserialized and passed back to the [RouterDelegate] via a call to\n/// [RouterDelegate.setRestoredRoutePath] (which by default just calls\n/// [RouterDelegate.setNewRoutePath]). It is the responsibility of the\n/// [RouterDelegate] to use the configuration information provided to restore\n/// its internal state.\n///\n/// To serialize [RouterDelegate.currentConfiguration] and to deserialize it\n/// again, the [Router] calls [RouteInformationParser.restoreRouteInformation]\n/// and [RouteInformationParser.parseRouteInformation], respectively. Therefore,\n/// if a [restorationScopeId] is provided, a [routeInformationParser] must be\n/// configured as well.\nclass Router<T> extends StatefulWidget {\n  /// Creates a router.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] can be null if this\n  /// router does not depend on route information. A common example is a sub router\n  /// that builds its content completely based on the app state.\n  ///\n  /// The [routeInformationProvider] and [routeInformationParser] must\n  /// both be provided or not provided.\n  const Router({\n    super.key,\n    this.routeInformationProvider,\n    this.routeInformationParser,\n    required this.routerDelegate,\n    this.backButtonDispatcher,\n    this.restorationScopeId,\n  }) : assert(\n         routeInformationProvider == null || routeInformationParser != null,\n         'A routeInformationParser must be provided when a routeInformationProvider is specified.',\n       );\n\n  /// Creates a router with a [RouterConfig].\n  ///\n  /// The [RouterConfig.routeInformationProvider] and\n  /// [RouterConfig.routeInformationParser] can be null if this router does not\n  /// depend on route information. A common example is a sub router that builds\n  /// its content completely based on the app state.\n  ///\n  /// If the [RouterConfig.routeInformationProvider] is not null, then\n  /// [RouterConfig.routeInformationParser] must also not be\n  /// null.\n  factory Router.withConfig({\n    Key? key,\n    required RouterConfig<T> config,\n    String? restorationScopeId,\n  }) {\n    return Router<T>(\n      key: key,\n      routeInformationProvider: config.routeInformationProvider,\n      routeInformationParser: config.routeInformationParser,\n      routerDelegate: config.routerDelegate,\n      backButtonDispatcher: config.backButtonDispatcher,\n      restorationScopeId: restorationScopeId,\n    );\n  }\n\n  /// The route information provider for the router.\n  ///\n  /// The value at the time of first build will be used as the initial route.\n  /// The [Router] listens to this provider and rebuilds with new names when\n  /// it notifies.\n  ///\n  /// This can be null if this router does not rely on the route information\n  /// to build its content. In such case, the [routeInformationParser] must also\n  /// be null.\n  final RouteInformationProvider? routeInformationProvider;\n\n  /// The route information parser for the router.\n  ///\n  /// When the [Router] gets a new route information from the [routeInformationProvider],\n  /// the [Router] uses this delegate to parse the route information and produce a\n  /// configuration. The configuration will be used by [routerDelegate] and\n  /// eventually rebuilds the [Router] widget.\n  ///\n  /// Since this delegate is the primary consumer of the [routeInformationProvider],\n  /// it must not be null if [routeInformationProvider] is not null.\n  final RouteInformationParser<T>? routeInformationParser;\n\n  /// The router delegate for the router.\n  ///\n  /// This delegate consumes the configuration from [routeInformationParser] and\n  /// builds a navigating widget for the [Router].\n  ///\n  /// It is also the primary respondent for the [backButtonDispatcher]. The\n  /// [Router] relies on [RouterDelegate.popRoute] to handle the back\n  /// button.\n  ///\n  /// If the [RouterDelegate.currentConfiguration] returns a non-null object,\n  /// this [Router] will opt for URL updates.\n  final RouterDelegate<T> routerDelegate;\n\n  /// The back button dispatcher for the router.\n  ///\n  /// The two common alternatives are the [RootBackButtonDispatcher] for root\n  /// router, or the [ChildBackButtonDispatcher] for other routers.\n  final BackButtonDispatcher? backButtonDispatcher;\n\n  /// Restoration ID to save and restore the state of the [Router].\n  ///\n  /// If non-null, the [Router] will persist the [RouterDelegate]'s current\n  /// configuration (i.e. [RouterDelegate.currentConfiguration]). During state\n  /// restoration, the [Router] informs the [RouterDelegate] of the previous\n  /// configuration by calling [RouterDelegate.setRestoredRoutePath] (which by\n  /// default just calls [RouterDelegate.setNewRoutePath]). It is the\n  /// responsibility of the [RouterDelegate] to restore its internal state based\n  /// on the provided configuration.\n  ///\n  /// The router uses the [RouteInformationParser] to serialize and deserialize\n  /// [RouterDelegate.currentConfiguration]. Therefore, a\n  /// [routeInformationParser] must be provided when [restorationScopeId] is\n  /// non-null.\n  ///\n  /// See also:\n  ///\n  ///  * [RestorationManager], which explains how state restoration works in\n  ///    Flutter.\n  final String? restorationScopeId;\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no [Router] ancestor exists for the given context, this will assert in\n  /// debug mode, and throw an exception in release mode.\n  ///\n  /// See also:\n  ///\n  ///  * [maybeOf], which is a similar function, but it will return null instead\n  ///    of throwing an exception if no [Router] ancestor exists.\n  static Router<T> of<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    assert(() {\n      if (scope == null) {\n        throw FlutterError(\n          'Router operation requested with a context that does not include a Router.\\n'\n          'The context used to retrieve the Router must be that of a widget that '\n          'is a descendant of a Router widget.',\n        );\n      }\n      return true;\n    }());\n    return scope!.routerState.widget as Router<T>;\n  }\n\n  /// Retrieves the immediate [Router] ancestor from the given context.\n  ///\n  /// This method provides access to the delegates in the [Router]. For example,\n  /// this can be used to access the [backButtonDispatcher] of the parent router\n  /// when creating a [ChildBackButtonDispatcher] for a nested [Router].\n  ///\n  /// If no `Router` ancestor exists for the given context, this will return\n  /// null.\n  ///\n  /// See also:\n  ///\n  ///  * [of], a similar method that returns a non-nullable value, and will\n  ///    throw if no [Router] ancestor exists.\n  static Router<T>? maybeOf<T extends Object?>(BuildContext context) {\n    final _RouterScope? scope = context.dependOnInheritedWidgetOfExactType<_RouterScope>();\n    return scope?.routerState.widget as Router<T>?;\n  }\n\n  /// Forces the [Router] to run the [callback] and create a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will only report\n  /// them if it detects the [RouteInformation.uri] changes. Use this\n  /// method if you want the [Router] to report the route information even if\n  /// the location does not change. This can be useful when you want to\n  /// support the browser backward and forward button without changing the URL.\n  ///\n  /// For example, you can store certain state such as the scroll position into\n  /// the [RouteInformation.state]. If you use this method to update the\n  /// scroll position multiple times with the same URL, the browser will create\n  /// a stack of new history entries with the same URL but different\n  /// [RouteInformation.state]s that store the new scroll positions. If the user\n  /// click the backward button in the browser, the browser will restore the\n  /// scroll positions saved in history entries without changing the URL.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [neglect]: which forces the [Router] to not create a new history entry\n  ///    even if location does change.\n  static void navigate(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.navigate,\n      callback,\n    );\n  }\n\n  /// Forces the [Router] to run the [callback] without creating a new history\n  /// entry in the browser.\n  ///\n  /// The web application relies on the [Router] to report new route information\n  /// in order to create browser history entry. The [Router] will report them\n  /// automatically if it detects the [RouteInformation.uri] changes.\n  ///\n  /// Creating a new route history entry makes users feel they have visited a\n  /// new page, and the browser back button brings them back to previous history\n  /// entry. Use this method if you don't want the [Router] to create a new\n  /// route information even if it detects changes as a result of running the\n  /// [callback].\n  ///\n  /// Using this method will still update the URL and state in current history\n  /// entry.\n  ///\n  /// See also:\n  ///\n  ///  * [Router]: see the \"URL updates for web applications\" section for more\n  ///    information about route information reporting.\n  ///  * [navigate]: which forces the [Router] to create a new history entry\n  ///    even if location does not change.\n  static void neglect(BuildContext context, VoidCallback callback) {\n    final _RouterScope scope =\n        context.getElementForInheritedWidgetOfExactType<_RouterScope>()!.widget as _RouterScope;\n    scope.routerState._setStateWithExplicitReportStatus(\n      RouteInformationReportingType.neglect,\n      callback,\n    );\n  }\n\n  @override\n  State<Router<T>> createState() => _RouterState<T>();\n}\n\ntypedef _AsyncPassthrough<Q> = Future<Q> Function(Q);\ntypedef _RouteSetter<T> = Future<void> Function(T);\n\n/// The [Router]'s intention when it reports a new [RouteInformation] to the\n/// [RouteInformationProvider].\n///\n/// See also:\n///\n///  * [RouteInformationProvider.routerReportsNewRouteInformation]: which is\n///    called by the router when it has a new route information to report.\nenum RouteInformationReportingType {\n  /// Router does not have a specific intention.\n  ///\n  /// The router generates a new route information every time it detects route\n  /// information may have change due to a rebuild. This is the default type if\n  /// neither [Router.neglect] nor [Router.navigate] was used during the\n  /// rebuild.\n  none,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.neglect] call.\n  neglect,\n\n  /// The accompanying [RouteInformation] were generated during a\n  /// [Router.navigate] call.\n  navigate,\n}\n\nclass _RouterState<T> extends State<Router<T>> with RestorationMixin {\n  Object? _currentRouterTransaction;\n  RouteInformationReportingType? _currentIntentionToReport;\n  final _RestorableRouteInformation _routeInformation = _RestorableRouteInformation();\n  late bool _routeParsePending;\n\n  @override\n  String? get restorationId => widget.restorationScopeId;\n\n  @override\n  void initState() {\n    super.initState();\n    widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n  }\n\n  @override\n  void restoreState(RestorationBucket? oldBucket, bool initialRestore) {\n    registerForRestoration(_routeInformation, 'route');\n    if (_routeInformation.value != null) {\n      assert(widget.routeInformationParser != null);\n      _processRouteInformation(\n        _routeInformation.value!,\n        () => widget.routerDelegate.setRestoredRoutePath,\n      );\n    } else if (widget.routeInformationProvider != null) {\n      _processRouteInformation(\n        widget.routeInformationProvider!.value,\n        () => widget.routerDelegate.setInitialRoutePath,\n      );\n    }\n  }\n\n  bool _routeInformationReportingTaskScheduled = false;\n\n  void _scheduleRouteInformationReportingTask() {\n    if (_routeInformationReportingTaskScheduled || widget.routeInformationProvider == null) {\n      return;\n    }\n    assert(_currentIntentionToReport != null);\n    _routeInformationReportingTaskScheduled = true;\n    SchedulerBinding.instance.addPostFrameCallback(\n      _reportRouteInformation,\n      debugLabel: 'Router.reportRouteInfo',\n    );\n  }\n\n  void _reportRouteInformation(Duration timestamp) {\n    if (!mounted) {\n      return;\n    }\n\n    assert(_routeInformationReportingTaskScheduled);\n    _routeInformationReportingTaskScheduled = false;\n\n    if (_routeInformation.value != null) {\n      final RouteInformation currentRouteInformation = _routeInformation.value!;\n      assert(_currentIntentionToReport != null);\n      widget.routeInformationProvider!.routerReportsNewRouteInformation(\n        currentRouteInformation,\n        type: _currentIntentionToReport!,\n      );\n    }\n    _currentIntentionToReport = RouteInformationReportingType.none;\n  }\n\n  RouteInformation? _retrieveNewRouteInformation() {\n    final T? configuration = widget.routerDelegate.currentConfiguration;\n    if (configuration == null) {\n      return null;\n    }\n    return widget.routeInformationParser?.restoreRouteInformation(configuration);\n  }\n\n  void _setStateWithExplicitReportStatus(RouteInformationReportingType status, VoidCallback fn) {\n    assert(status.index >= RouteInformationReportingType.neglect.index);\n    assert(() {\n      if (_currentIntentionToReport != null &&\n          _currentIntentionToReport != RouteInformationReportingType.none &&\n          _currentIntentionToReport != status) {\n        FlutterError.reportError(\n          const FlutterErrorDetails(\n            exception:\n                'Both Router.navigate and Router.neglect have been called in this '\n                'build cycle, and the Router cannot decide whether to report the '\n                'route information. Please make sure only one of them is called '\n                'within the same build cycle.',\n          ),\n        );\n      }\n      return true;\n    }());\n    _currentIntentionToReport = status;\n    _scheduleRouteInformationReportingTask();\n    fn();\n  }\n\n  void _maybeNeedToReportRouteInformation() {\n    _routeInformation.value = _retrieveNewRouteInformation();\n    _currentIntentionToReport ??= RouteInformationReportingType.none;\n    _scheduleRouteInformationReportingTask();\n  }\n\n  @override\n  void didChangeDependencies() {\n    _routeParsePending = true;\n    super.didChangeDependencies();\n    // The super.didChangeDependencies may have parsed the route information.\n    // This can happen if the didChangeDependencies is triggered by state\n    // restoration or first build.\n    final RouteInformation? currentRouteInformation =\n        _routeInformation.value ?? widget.routeInformationProvider?.value;\n    if (currentRouteInformation != null && _routeParsePending) {\n      _processRouteInformation(\n        currentRouteInformation,\n        () => widget.routerDelegate.setNewRoutePath,\n      );\n    }\n    _routeParsePending = false;\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  void didUpdateWidget(Router<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider ||\n        widget.backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        widget.routeInformationParser != oldWidget.routeInformationParser ||\n        widget.routerDelegate != oldWidget.routerDelegate) {\n      _currentRouterTransaction = Object();\n    }\n    if (widget.routeInformationProvider != oldWidget.routeInformationProvider) {\n      oldWidget.routeInformationProvider?.removeListener(\n        _handleRouteInformationProviderNotification,\n      );\n      widget.routeInformationProvider?.addListener(_handleRouteInformationProviderNotification);\n      if (oldWidget.routeInformationProvider?.value != widget.routeInformationProvider?.value) {\n        _handleRouteInformationProviderNotification();\n      }\n    }\n    if (widget.backButtonDispatcher != oldWidget.backButtonDispatcher) {\n      oldWidget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n      widget.backButtonDispatcher?.addCallback(_handleBackButtonDispatcherNotification);\n    }\n    if (widget.routerDelegate != oldWidget.routerDelegate) {\n      oldWidget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n      widget.routerDelegate.addListener(_handleRouterDelegateNotification);\n      _maybeNeedToReportRouteInformation();\n    }\n  }\n\n  @override\n  void dispose() {\n    _routeInformation.dispose();\n    widget.routeInformationProvider?.removeListener(_handleRouteInformationProviderNotification);\n    widget.backButtonDispatcher?.removeCallback(_handleBackButtonDispatcherNotification);\n    widget.routerDelegate.removeListener(_handleRouterDelegateNotification);\n    _currentRouterTransaction = null;\n    super.dispose();\n  }\n\n  void _processRouteInformation(\n    RouteInformation information,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    assert(_routeParsePending);\n    _routeParsePending = false;\n    _currentRouterTransaction = Object();\n    widget.routeInformationParser!\n        .parseRouteInformationWithDependencies(information, context)\n        .then<void>(_processParsedRouteInformation(_currentRouterTransaction, delegateRouteSetter));\n  }\n\n  _RouteSetter<T> _processParsedRouteInformation(\n    Object? transaction,\n    ValueGetter<_RouteSetter<T>> delegateRouteSetter,\n  ) {\n    return (T data) async {\n      if (_currentRouterTransaction != transaction) {\n        return;\n      }\n      await delegateRouteSetter()(data);\n      if (_currentRouterTransaction == transaction) {\n        _rebuild();\n      }\n    };\n  }\n\n  void _handleRouteInformationProviderNotification() {\n    _routeParsePending = true;\n    _processRouteInformation(\n      widget.routeInformationProvider!.value,\n      () => widget.routerDelegate.setNewRoutePath,\n    );\n  }\n\n  Future<bool> _handleBackButtonDispatcherNotification() {\n    _currentRouterTransaction = Object();\n    return widget.routerDelegate.popRoute().then<bool>(\n      _handleRoutePopped(_currentRouterTransaction),\n    );\n  }\n\n  _AsyncPassthrough<bool> _handleRoutePopped(Object? transaction) {\n    return (bool data) {\n      if (transaction != _currentRouterTransaction) {\n        // A rebuilt was trigger from a different source. Returns true to\n        // prevent bubbling.\n        return SynchronousFuture<bool>(true);\n      }\n      _rebuild();\n      return SynchronousFuture<bool>(data);\n    };\n  }\n\n  Future<void> _rebuild([void value]) {\n    setState(() {\n      /* routerDelegate is ready to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n    return SynchronousFuture<void>(value);\n  }\n\n  void _handleRouterDelegateNotification() {\n    setState(() {\n      /* routerDelegate wants to rebuild */\n    });\n    _maybeNeedToReportRouteInformation();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return UnmanagedRestorationScope(\n      bucket: bucket,\n      child: _RouterScope(\n        routeInformationProvider: widget.routeInformationProvider,\n        backButtonDispatcher: widget.backButtonDispatcher,\n        routeInformationParser: widget.routeInformationParser,\n        routerDelegate: widget.routerDelegate,\n        routerState: this,\n        child: Builder(\n          // Use a Builder so that the build method below will have a\n          // BuildContext that contains the _RouterScope. This also prevents\n          // dependencies look ups in routerDelegate from rebuilding Router\n          // widget that may result in re-parsing the route information.\n          builder: widget.routerDelegate.build,\n        ),\n      ),\n    );\n  }\n}\n\nclass _RouterScope extends InheritedWidget {\n  const _RouterScope({\n    required this.routeInformationProvider,\n    required this.backButtonDispatcher,\n    required this.routeInformationParser,\n    required this.routerDelegate,\n    required this.routerState,\n    required super.child,\n  }) : assert(routeInformationProvider == null || routeInformationParser != null);\n\n  final ValueListenable<RouteInformation?>? routeInformationProvider;\n  final BackButtonDispatcher? backButtonDispatcher;\n  final RouteInformationParser<Object?>? routeInformationParser;\n  final RouterDelegate<Object?> routerDelegate;\n  final _RouterState<Object?> routerState;\n\n  @override\n  bool updateShouldNotify(_RouterScope oldWidget) {\n    return routeInformationProvider != oldWidget.routeInformationProvider ||\n        backButtonDispatcher != oldWidget.backButtonDispatcher ||\n        routeInformationParser != oldWidget.routeInformationParser ||\n        routerDelegate != oldWidget.routerDelegate ||\n        routerState != oldWidget.routerState;\n  }\n}\n\n/// A class that can be extended or mixed in that invokes a single callback,\n/// which then returns a value.\n///\n/// While multiple callbacks can be registered, when a notification is\n/// dispatched there must be only a single callback. The return values of\n/// multiple callbacks are not aggregated.\n///\n/// `T` is the return value expected from the callback.\n///\n/// See also:\n///\n///  * [Listenable] and its subclasses, which provide a similar mechanism for\n///    one-way signaling.\nclass _CallbackHookProvider<T> {\n  final ObserverList<ValueGetter<T>> _callbacks = ObserverList<ValueGetter<T>>();\n\n  /// Whether a callback is currently registered.\n  @protected\n  bool get hasCallbacks => _callbacks.isNotEmpty;\n\n  /// Register the callback to be called when the object changes.\n  ///\n  /// If other callbacks have already been registered, they must be removed\n  /// (with [removeCallback]) before the callback is next called.\n  void addCallback(ValueGetter<T> callback) => _callbacks.add(callback);\n\n  /// Remove a previously registered callback.\n  ///\n  /// If the given callback is not registered, the call is ignored.\n  void removeCallback(ValueGetter<T> callback) => _callbacks.remove(callback);\n\n  /// Calls the (single) registered callback and returns its result.\n  ///\n  /// If no callback is registered, or if the callback throws, returns\n  /// `defaultValue`.\n  ///\n  /// Call this method whenever the callback is to be invoked. If there is more\n  /// than one callback registered, this method will throw a [StateError].\n  ///\n  /// Exceptions thrown by callbacks will be caught and reported using\n  /// [FlutterError.reportError].\n  @protected\n  @pragma('vm:notify-debugger-on-exception')\n  T invokeCallback(T defaultValue) {\n    if (_callbacks.isEmpty) {\n      return defaultValue;\n    }\n    try {\n      return _callbacks.single();\n    } catch (exception, stack) {\n      FlutterError.reportError(\n        FlutterErrorDetails(\n          exception: exception,\n          stack: stack,\n          library: 'widget library',\n          context: ErrorDescription('while invoking the callback for $runtimeType'),\n          informationCollector:\n              () => <DiagnosticsNode>[\n                DiagnosticsProperty<_CallbackHookProvider<T>>(\n                  'The $runtimeType that invoked the callback was',\n                  this,\n                  style: DiagnosticsTreeStyle.errorProperty,\n                ),\n              ],\n        ),\n      );\n      return defaultValue;\n    }\n  }\n}\n\n/// Report to a [Router] when the user taps the back button on platforms that\n/// support back buttons (such as Android).\n///\n/// When [Router] widgets are nested, consider using a\n/// [ChildBackButtonDispatcher], passing it the parent [BackButtonDispatcher],\n/// so that the back button requests get dispatched to the appropriate [Router].\n/// To make this work properly, it's important that whenever a [Router] thinks\n/// it should get the back button messages (e.g. after the user taps inside it),\n/// it calls [takePriority] on its [BackButtonDispatcher] (or\n/// [ChildBackButtonDispatcher]) instance.\n///\n/// The class takes a single callback, which must return a [Future<bool>]. The\n/// callback's semantics match [WidgetsBindingObserver.didPopRoute]'s, namely,\n/// the callback should return a future that completes to true if it can handle\n/// the pop request, and a future that completes to false otherwise.\nabstract class BackButtonDispatcher extends _CallbackHookProvider<Future<bool>> {\n  late final LinkedHashSet<ChildBackButtonDispatcher> _children =\n      <ChildBackButtonDispatcher>{} as LinkedHashSet<ChildBackButtonDispatcher>;\n\n  @override\n  bool get hasCallbacks => super.hasCallbacks || (_children.isNotEmpty);\n\n  /// Handles a pop route request.\n  ///\n  /// This method prioritizes the children list in reverse order and calls\n  /// [ChildBackButtonDispatcher.notifiedByParent] on them. If any of them\n  /// handles the request (by returning a future with true), it exits this\n  /// method by returning this future. Otherwise, it keeps moving on to the next\n  /// child until a child handles the request. If none of the children handles\n  /// the request, this back button dispatcher will then try to handle the request\n  /// by itself. This back button dispatcher handles the request by notifying the\n  /// router which in turn calls the [RouterDelegate.popRoute] and returns its\n  /// result.\n  ///\n  /// To decide whether this back button dispatcher will handle the pop route\n  /// request, you can override the [RouterDelegate.popRoute] of the router\n  /// delegate you pass into the router with this back button dispatcher to\n  /// return a future of true or false.\n  @override\n  Future<bool> invokeCallback(Future<bool> defaultValue) {\n    if (_children.isNotEmpty) {\n      final List<ChildBackButtonDispatcher> children = _children.toList();\n      int childIndex = children.length - 1;\n\n      Future<bool> notifyNextChild(bool result) {\n        // If the previous child handles the callback, we return the result.\n        if (result) {\n          return SynchronousFuture<bool>(result);\n        }\n        // If the previous child did not handle the callback, we ask the next\n        // child to handle the it.\n        if (childIndex > 0) {\n          childIndex -= 1;\n          return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n        }\n        // If none of the child handles the callback, the parent will then handle it.\n        return super.invokeCallback(defaultValue);\n      }\n\n      return children[childIndex].notifiedByParent(defaultValue).then<bool>(notifyNextChild);\n    }\n    return super.invokeCallback(defaultValue);\n  }\n\n  /// Creates a [ChildBackButtonDispatcher] that is a direct descendant of this\n  /// back button dispatcher.\n  ///\n  /// To participate in handling the pop route request, call the [takePriority]\n  /// on the [ChildBackButtonDispatcher] created from this method.\n  ///\n  /// When the pop route request is handled by this back button dispatcher, it\n  /// propagate the request to its direct descendants that have called the\n  /// [takePriority] method. If there are multiple candidates, the latest one\n  /// that called the [takePriority] wins the right to handle the request. If\n  /// the latest one does not handle the request (by returning a future of\n  /// false in [ChildBackButtonDispatcher.notifiedByParent]), the second latest\n  /// one will then have the right to handle the request. This dispatcher\n  /// continues finding the next candidate until there are no more candidates\n  /// and finally handles the request itself.\n  ChildBackButtonDispatcher createChildBackButtonDispatcher() {\n    return ChildBackButtonDispatcher(this);\n  }\n\n  /// Make this [BackButtonDispatcher] take priority among its peers.\n  ///\n  /// This has no effect when a [BackButtonDispatcher] has no parents and no\n  /// children. If a [BackButtonDispatcher] does have parents or children,\n  /// however, it causes this object to be the one to dispatch the notification\n  /// when the parent would normally notify its callback.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to take priority.\n  void takePriority() => _children.clear();\n\n  /// Mark the given child as taking priority over this object and the other\n  /// children.\n  ///\n  /// This causes [invokeCallback] to defer to the given child instead of\n  /// calling this object's callback.\n  ///\n  /// Children are stored in a list, so that if the current child is removed\n  /// using [forget], a previous child will return to take its place. When\n  /// [takePriority] is called, the list is cleared.\n  ///\n  /// Calling this again without first calling [forget] moves the child back to\n  /// the head of the list.\n  ///\n  /// The [BackButtonDispatcher] must have a listener registered before it can\n  /// be told to defer to a child.\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    _children.remove(child); // child may or may not be in the set already\n    _children.add(child);\n  }\n\n  /// Causes the given child to be removed from the list of children to which\n  /// this object might defer, as if [deferTo] had never been called for that\n  /// child.\n  ///\n  /// This should only be called once per child, even if [deferTo] was called\n  /// multiple times for that child.\n  ///\n  /// If no children are left in the list, this object will stop deferring to\n  /// its children. (This is not the same as calling [takePriority], since, if\n  /// this object itself is a [ChildBackButtonDispatcher], [takePriority] would\n  /// additionally attempt to claim priority from its parent, whereas removing\n  /// the last child does not.)\n  void forget(ChildBackButtonDispatcher child) => _children.remove(child);\n}\n\n/// The default implementation of back button dispatcher for the root router.\n///\n/// This dispatcher listens to platform pop route notifications. When the\n/// platform wants to pop the current route, this dispatcher calls the\n/// [BackButtonDispatcher.invokeCallback] method to handle the request.\nclass RootBackButtonDispatcher extends BackButtonDispatcher with WidgetsBindingObserver {\n  /// Create a root back button dispatcher.\n  RootBackButtonDispatcher();\n\n  @override\n  void addCallback(ValueGetter<Future<bool>> callback) {\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addCallback(callback);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  Future<bool> didPopRoute() => invokeCallback(Future<bool>.value(false));\n}\n\n/// A variant of [BackButtonDispatcher] which listens to notifications from a\n/// parent back button dispatcher, and can take priority from its parent for the\n/// handling of such notifications.\n///\n/// Useful when [Router]s are being nested within each other.\n///\n/// Use [Router.of] to obtain a reference to the nearest ancestor [Router], from\n/// which the [Router.backButtonDispatcher] can be found, and then used as the\n/// [parent] of the [ChildBackButtonDispatcher].\nclass ChildBackButtonDispatcher extends BackButtonDispatcher {\n  /// Creates a back button dispatcher that acts as the child of another.\n  ChildBackButtonDispatcher(this.parent);\n\n  /// The back button dispatcher that this object will attempt to take priority\n  /// over when [takePriority] is called.\n  ///\n  /// The parent must have a listener registered before this child object can\n  /// have its [takePriority] or [deferTo] methods used.\n  final BackButtonDispatcher parent;\n\n  /// The parent of this child back button dispatcher decide to let this\n  /// child to handle the invoke the callback request in\n  /// [BackButtonDispatcher.invokeCallback].\n  ///\n  /// Return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  @protected\n  Future<bool> notifiedByParent(Future<bool> defaultValue) {\n    return invokeCallback(defaultValue);\n  }\n\n  @override\n  void takePriority() {\n    parent.deferTo(this);\n    super.takePriority();\n  }\n\n  @override\n  void deferTo(ChildBackButtonDispatcher child) {\n    assert(hasCallbacks);\n    parent.deferTo(this);\n    super.deferTo(child);\n  }\n\n  @override\n  void removeCallback(ValueGetter<Future<bool>> callback) {\n    super.removeCallback(callback);\n    if (!hasCallbacks) {\n      parent.forget(this);\n    }\n  }\n}\n\n/// A convenience widget that registers a callback for when the back button is pressed.\n///\n/// In order to use this widget, there must be an ancestor [Router] widget in the tree\n/// that has a [RootBackButtonDispatcher]. e.g. The [Router] widget created by the\n/// [MaterialApp.router] has a built-in [RootBackButtonDispatcher] by default.\n///\n/// It only applies to platforms that accept back button clicks, such as Android.\n///\n/// It can be useful for scenarios, in which you create a different state in your\n/// screen but don't want to use a new page for that.\nclass BackButtonListener extends StatefulWidget {\n  /// Creates a BackButtonListener widget .\n  const BackButtonListener({super.key, required this.child, required this.onBackButtonPressed});\n\n  /// The widget below this widget in the tree.\n  final Widget child;\n\n  /// The callback function that will be called when the back button is pressed.\n  ///\n  /// It must return a boolean future with true if this child will handle the request;\n  /// otherwise, return a boolean future with false.\n  final ValueGetter<Future<bool>> onBackButtonPressed;\n\n  @override\n  State<BackButtonListener> createState() => _BackButtonListenerState();\n}\n\nclass _BackButtonListenerState extends State<BackButtonListener> {\n  BackButtonDispatcher? dispatcher;\n\n  @override\n  void didChangeDependencies() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n\n    final BackButtonDispatcher? rootBackDispatcher = Router.of(context).backButtonDispatcher;\n    assert(\n      rootBackDispatcher != null,\n      'The parent router must have a backButtonDispatcher to use this widget',\n    );\n\n    dispatcher =\n        rootBackDispatcher!.createChildBackButtonDispatcher()\n          ..addCallback(widget.onBackButtonPressed)\n          ..takePriority();\n    super.didChangeDependencies();\n  }\n\n  @override\n  void didUpdateWidget(covariant BackButtonListener oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.onBackButtonPressed != widget.onBackButtonPressed) {\n      dispatcher?.removeCallback(oldWidget.onBackButtonPressed);\n      dispatcher?.addCallback(widget.onBackButtonPressed);\n      dispatcher?.takePriority();\n    }\n  }\n\n  @override\n  void dispose() {\n    dispatcher?.removeCallback(widget.onBackButtonPressed);\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) => widget.child;\n}\n\n/// A delegate that is used by the [Router] widget to parse a route information\n/// into a configuration of type T.\n///\n/// This delegate is used when the [Router] widget is first built with initial\n/// route information from [Router.routeInformationProvider] and any subsequent\n/// new route notifications from it. The [Router] widget calls the [parseRouteInformation]\n/// with the route information from [Router.routeInformationProvider].\n///\n/// One of the [parseRouteInformation] or\n/// [parseRouteInformationWithDependencies] must be implemented, otherwise a\n/// runtime error will be thrown.\nabstract class RouteInformationParser<T> {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const RouteInformationParser();\n\n  /// {@template flutter.widgets.RouteInformationParser.parseRouteInformation}\n  /// Converts the given route information into parsed data to pass to a\n  /// [RouterDelegate].\n  ///\n  /// The method should return a future which completes when the parsing is\n  /// complete. The parsing may be asynchronous if, e.g., the parser needs to\n  /// communicate with the OEM thread to obtain additional data about the route.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to pass the data to the [RouterDelegate].\n  /// {@endtemplate}\n  ///\n  /// One can implement [parseRouteInformationWithDependencies] instead if\n  /// the parsing depends on other dependencies from the [BuildContext].\n  Future<T> parseRouteInformation(RouteInformation routeInformation) {\n    throw UnimplementedError(\n      'One of the parseRouteInformation or '\n      'parseRouteInformationWithDependencies must be implemented',\n    );\n  }\n\n  /// {@macro flutter.widgets.RouteInformationParser.parseRouteInformation}\n  ///\n  /// The input [BuildContext] can be used for looking up [InheritedWidget]s\n  /// If one uses [BuildContext.dependOnInheritedWidgetOfExactType], a\n  /// dependency will be created. The [Router] will re-parse the\n  /// [RouteInformation] from its [RouteInformationProvider] if the dependency\n  /// notifies its listeners.\n  ///\n  /// One can also use [BuildContext.getElementForInheritedWidgetOfExactType] to\n  /// look up [InheritedWidget]s without creating dependencies.\n  Future<T> parseRouteInformationWithDependencies(\n    RouteInformation routeInformation,\n    BuildContext context,\n  ) {\n    return parseRouteInformation(routeInformation);\n  }\n\n  /// Restore the route information from the given configuration.\n  ///\n  /// This may return null, in which case the browser history will not be\n  /// updated and state restoration is disabled. See [Router]'s documentation\n  /// for details.\n  ///\n  /// The [parseRouteInformation] method must produce an equivalent\n  /// configuration when passed this method's return value.\n  RouteInformation? restoreRouteInformation(T configuration) => null;\n}\n\n/// A delegate that is used by the [Router] widget to build and configure a\n/// navigating widget.\n///\n/// This delegate is the core piece of the [Router] widget. It responds to\n/// push route and pop route intents from the engine and notifies the [Router]\n/// to rebuild. It also acts as a builder for the [Router] widget and builds a\n/// navigating widget, typically a [Navigator], when the [Router] widget\n/// builds.\n///\n/// When the engine pushes a new route, the route information is parsed by the\n/// [RouteInformationParser] to produce a configuration of type T. The router\n/// delegate receives the configuration through [setInitialRoutePath] or\n/// [setNewRoutePath] to configure itself and builds the latest navigating\n/// widget when asked ([build]).\n///\n/// When implementing subclasses, consider defining a [Listenable] app state object to be\n/// used for building the navigating widget. The router delegate would update\n/// the app state accordingly and notify its own listeners when the app state has\n/// changed and when it receive route related engine intents (e.g.\n/// [setNewRoutePath], [setInitialRoutePath], or [popRoute]).\n///\n/// All subclass must implement [setNewRoutePath], [popRoute], and [build].\n///\n/// ## State Restoration\n///\n/// If the [Router] owning this delegate is configured for state restoration, it\n/// will persist and restore the configuration of this [RouterDelegate] using\n/// the following mechanism: Before the app is killed by the operating system,\n/// the value of [currentConfiguration] is serialized out and persisted. After\n/// the app has restarted, the value is deserialized and passed back to the\n/// [RouterDelegate] via a call to [setRestoredRoutePath] (which by default just\n/// calls [setNewRoutePath]). It is the responsibility of the [RouterDelegate]\n/// to use the configuration information provided to restore its internal state.\n///\n/// See also:\n///\n///  * [RouteInformationParser], which is responsible for parsing the route\n///    information to a configuration before passing in to router delegate.\n///  * [Router], which is the widget that wires all the delegates together to\n///    provide a fully functional routing solution.\nabstract class RouterDelegate<T> extends Listenable {\n  /// Called by the [Router] at startup with the structure that the\n  /// [RouteInformationParser] obtained from parsing the initial route.\n  ///\n  /// This should configure the [RouterDelegate] so that when [build] is\n  /// invoked, it will create a widget tree that matches the initial route.\n  ///\n  /// By default, this method forwards the [configuration] to [setNewRoutePath].\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  ///\n  /// See also:\n  ///\n  ///  * [setRestoredRoutePath], which is called instead of this method during\n  ///    state restoration.\n  Future<void> setInitialRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] during state restoration.\n  ///\n  /// When the [Router] is configured for state restoration, it will persist\n  /// the value of [currentConfiguration] during state serialization. During\n  /// state restoration, the [Router] calls this method (instead of\n  /// [setInitialRoutePath]) to pass the previous configuration back to the\n  /// delegate. It is the responsibility of the delegate to restore its internal\n  /// state based on the provided configuration.\n  ///\n  /// By default, this method forwards the `configuration` to [setNewRoutePath].\n  Future<void> setRestoredRoutePath(T configuration) {\n    return setNewRoutePath(configuration);\n  }\n\n  /// Called by the [Router] when the [Router.routeInformationProvider] reports that a\n  /// new route has been pushed to the application by the operating system.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<void> setNewRoutePath(T configuration);\n\n  /// Called by the [Router] when the [Router.backButtonDispatcher] reports that\n  /// the operating system is requesting that the current route be popped.\n  ///\n  /// The method should return a boolean [Future] to indicate whether this\n  /// delegate handles the request. Returning false will cause the entire app\n  /// to be popped.\n  ///\n  /// Consider using a [SynchronousFuture] if the result can be computed\n  /// synchronously, so that the [Router] does not need to wait for the next\n  /// microtask to schedule a build.\n  Future<bool> popRoute();\n\n  /// Called by the [Router] when it detects a route information may have\n  /// changed as a result of rebuild.\n  ///\n  /// If this getter returns non-null, the [Router] will start to report new\n  /// route information back to the engine. In web applications, the new\n  /// route information is used for populating browser history in order to\n  /// support the forward and the backward buttons.\n  ///\n  /// When overriding this method, the configuration returned by this getter\n  /// must be able to construct the current app state and build the widget\n  /// with the same configuration in the [build] method if it is passed back\n  /// to the [setNewRoutePath]. Otherwise, the browser backward and forward\n  /// buttons will not work properly.\n  ///\n  /// By default, this getter returns null, which prevents the [Router] from\n  /// reporting the route information. To opt in, a subclass can override this\n  /// getter to return the current configuration.\n  ///\n  /// At most one [Router] can opt in to route information reporting. Typically,\n  /// only the top-most [Router] created by [WidgetsApp.router] should opt for\n  /// route information reporting.\n  ///\n  /// ## State Restoration\n  ///\n  /// This getter is also used by the [Router] to implement state restoration.\n  /// During state serialization, the [Router] will persist the current\n  /// configuration and during state restoration pass it back to the delegate\n  /// by calling [setRestoredRoutePath].\n  T? get currentConfiguration => null;\n\n  /// Called by the [Router] to obtain the widget tree that represents the\n  /// current state.\n  ///\n  /// This is called whenever the [Future]s returned by [setInitialRoutePath],\n  /// [setNewRoutePath], or [setRestoredRoutePath] complete as well as when this\n  /// notifies its clients (see the [Listenable] interface, which this interface\n  /// includes). In addition, it may be called at other times. It is important,\n  /// therefore, that the methods above do not update the state that the [build]\n  /// method uses before they complete their respective futures.\n  ///\n  /// Typically this method returns a suitably-configured [Navigator]. If you do\n  /// plan to create a navigator, consider using the\n  /// [PopNavigatorRouterDelegateMixin]. If state restoration is enabled for the\n  /// [Router] using this delegate, consider providing a non-null\n  /// [Navigator.restorationScopeId] to the [Navigator] returned by this method.\n  ///\n  /// This method must not return null.\n  ///\n  /// The `context` is the [Router]'s build context.\n  Widget build(BuildContext context);\n}\n\n/// A route information provider that provides route information for the\n/// [Router] widget\n///\n/// This provider is responsible for handing the route information through [value]\n/// getter and notifies listeners, typically the [Router] widget, when a new\n/// route information is available.\n///\n/// When the router opts for route information reporting (by overriding the\n/// [RouterDelegate.currentConfiguration] to return non-null), override the\n/// [routerReportsNewRouteInformation] method to process the route information.\n///\n/// See also:\n///\n///  * [PlatformRouteInformationProvider], which wires up the itself with the\n///    [WidgetsBindingObserver.didPushRoute] to propagate platform push route\n///    intent to the [Router] widget, as well as reports new route information\n///    from the [Router] back to the engine by overriding the\n///    [routerReportsNewRouteInformation].\nabstract class RouteInformationProvider extends ValueListenable<RouteInformation> {\n  /// A callback called when the [Router] widget reports new route information\n  ///\n  /// The subclasses can override this method to update theirs values or trigger\n  /// other side effects. For example, the [PlatformRouteInformationProvider]\n  /// overrides this method to report the route information back to the engine.\n  ///\n  /// The `routeInformation` is the new route information generated by the\n  /// Router rebuild, and it can be the same or different from the\n  /// [value].\n  ///\n  /// The `type` denotes the [Router]'s intention when it reports this\n  /// `routeInformation`. It is useful when deciding how to update the internal\n  /// state of [RouteInformationProvider] subclass with the `routeInformation`.\n  /// For example, [PlatformRouteInformationProvider] uses this property to\n  /// decide whether to push or replace the browser history entry with the new\n  /// `routeInformation`.\n  ///\n  /// For more information on how [Router] determines a navigation event, see\n  /// the \"URL updates for web applications\" section in the [Router]\n  /// documentation.\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {}\n}\n\n/// The route information provider that propagates the platform route information changes.\n///\n/// This provider also reports the new route information from the [Router] widget\n/// back to engine using message channel method, the\n/// [SystemNavigator.routeInformationUpdated].\n///\n/// Each time [SystemNavigator.routeInformationUpdated] is called, the\n/// [SystemNavigator.selectMultiEntryHistory] method is also called. This\n/// overrides the initialization behavior of\n/// [Navigator.reportsRouteUpdateToEngine].\nclass PlatformRouteInformationProvider extends RouteInformationProvider\n    with WidgetsBindingObserver, ChangeNotifier {\n  /// Create a platform route information provider.\n  ///\n  /// Use the [initialRouteInformation] to set the default route information for this\n  /// provider.\n  PlatformRouteInformationProvider({required RouteInformation initialRouteInformation})\n    : _value = initialRouteInformation {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  static bool _equals(Uri a, Uri b) {\n    return a.path == b.path &&\n        a.fragment == b.fragment &&\n        const DeepCollectionEquality.unordered().equals(a.queryParametersAll, b.queryParametersAll);\n  }\n\n  @override\n  void routerReportsNewRouteInformation(\n    RouteInformation routeInformation, {\n    RouteInformationReportingType type = RouteInformationReportingType.none,\n  }) {\n    SystemNavigator.selectMultiEntryHistory();\n    SystemNavigator.routeInformationUpdated(\n      uri: routeInformation.uri,\n      state: routeInformation.state,\n      replace: switch (type) {\n        RouteInformationReportingType.neglect => true,\n        RouteInformationReportingType.navigate => false,\n        RouteInformationReportingType.none => _equals(_valueInEngine.uri, routeInformation.uri),\n      },\n    );\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n  }\n\n  @override\n  RouteInformation get value => _value;\n  RouteInformation _value;\n\n  RouteInformation _valueInEngine = RouteInformation(\n    uri: Uri.parse(WidgetsBinding.instance.platformDispatcher.defaultRouteName),\n  );\n\n  void _platformReportsNewRouteInformation(RouteInformation routeInformation) {\n    if (_value == routeInformation) {\n      return;\n    }\n    _value = routeInformation;\n    _valueInEngine = routeInformation;\n    notifyListeners();\n  }\n\n  @override\n  void addListener(VoidCallback listener) {\n    if (!hasListeners) {\n      WidgetsBinding.instance.addObserver(this);\n    }\n    super.addListener(listener);\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    super.removeListener(listener);\n    if (!hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n  }\n\n  @override\n  void dispose() {\n    // In practice, this will rarely be called. We assume that the listeners\n    // will be added and removed in a coherent fashion such that when the object\n    // is no longer being used, there's no listener, and so it will get garbage\n    // collected.\n    if (hasListeners) {\n      WidgetsBinding.instance.removeObserver(this);\n    }\n    super.dispose();\n  }\n\n  @override\n  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {\n    assert(hasListeners);\n    _platformReportsNewRouteInformation(routeInformation);\n    return true;\n  }\n}\n\n/// A mixin that wires [RouterDelegate.popRoute] to the [Navigator] it builds.\n///\n/// This mixin calls [Navigator.maybePop] when it receives an Android back\n/// button intent through the [RouterDelegate.popRoute]. Using this mixin\n/// guarantees that the back button still respects pageless routes in the\n/// navigator.\n///\n/// Only use this mixin if you plan to build a navigator in the\n/// [RouterDelegate.build].\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> {\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState;\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false);\n  }\n}\n\nclass _RestorableRouteInformation extends RestorableValue<RouteInformation?> {\n  @override\n  RouteInformation? createDefaultValue() => null;\n\n  @override\n  void didUpdateValue(RouteInformation? oldValue) {\n    notifyListeners();\n  }\n\n  @override\n  RouteInformation? fromPrimitives(Object? data) {\n    if (data == null) {\n      return null;\n    }\n    assert(data is List<Object?> && data.length == 2);\n    final List<Object?> castedData = data as List<Object?>;\n    final String? uri = castedData.first as String?;\n    if (uri == null) {\n      return null;\n    }\n    return RouteInformation(uri: Uri.parse(uri), state: castedData.last);\n  }\n\n  @override\n  Object? toPrimitives() {\n    return value == null ? null : <Object?>[value!.uri.toString(), value!.state];\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 9: PopNavigatorRouterDelegateMixin\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 9: PopNavigatorRouterDelegateMixin\n\nWelcome back! We've covered the essential pieces of Flutter's Declarative Router: how it gets information ([Chapter 1: RouteInformation](01_routeinformation_.md), [Chapter 2: RouteInformationProvider](02_routeinformationprovider_.md)), how it understands that information ([Chapter 3: RouteInformationParser](03_routeinformationparser_.md)), how it builds the UI based on it ([Chapter 4: RouterDelegate](04_routerdelegate_.md)), and how it coordinates everything ([Chapter 5: Router](05_router_.md)). We also looked at how the system back button is handled ([Chapter 6: BackButtonDispatcher](06_backbuttondispatcher_.md), [Chapter 7: RootBackButtonDispatcher](07_rootbackbuttondispatcher_.md), [Chapter 8: ChildBackButtonDispatcher](08_childbuttondispatcher_.md)).\n\nIn [Chapter 4](04_routerdelegate_.md), when we discussed the `RouterDelegate`, we mentioned that it's responsible for handling the `popRoute()` method, which is called when the system back button is pressed (via the [BackButtonDispatcher](06_backbuttondispatcher_.md) and [Router](05_router_.md)). We also saw that a `RouterDelegate` typically builds a `Navigator` to manage screens using a stack of `Page` objects.\n\nHandling `popRoute()` manually can be a bit tricky, especially if your `RouterDelegate` is managing a complex `Navigator` stack. You need to check if the `Navigator` can pop a page, perform the pop, and return the correct boolean result (`true` if a page was popped, `false` otherwise).\n\nThis is where the `PopNavigatorRouterDelegateMixin` comes to the rescue!\n\n## What is PopNavigatorRouterDelegateMixin?\n\nThe `PopNavigatorRouterDelegateMixin` is a **helpful tool** that you can mix into your `RouterDelegate` class. Its sole purpose is to provide a standard implementation for the `RouterDelegate`'s required `popRoute()` method that automatically interacts with a `Navigator`.\n\nThink of it as a predefined answer key for the back button question that your `RouterDelegate` gets asked. When the system back button is pressed, the [Router](05_router_.md) calls your `RouterDelegate`'s `popRoute()` method. If you've mixed in `PopNavigatorRouterDelegateMixin`, this mixin handles the call by:\n\n1.  Finding the `Navigator` associated with the `RouterDelegate` (using a special `GlobalKey` provided by the mixin).\n2.  Asking that `Navigator` if it can pop the current page using `Navigator.maybePop()`.\n3.  Performing the pop action on the `Navigator` if possible.\n4.  Returning the `Future<bool>` result from `Navigator.maybePop()`, which is `true` if a route was popped, and `false` otherwise.\n\nEssentially, it connects the back button behavior initiated by the [BackButtonDispatcher](06_backbuttondispatcher_.md) directly to the standard page-stack management of a `Navigator`, without you having to write that plumbing code yourself.\n\nHere's the back button flow with the mixin:\n\n```mermaid\nsequenceDiagram\n    participant RootDispatcher as RootBackButtonDispatcher\n    participant Router as Flutter Router\n    participant Delegate as RouterDelegate (with Mixin)\n    participant Mixin as PopNavigatorRouterDelegateMixin\n    participant Navigator as Flutter Navigator\n\n    RootDispatcher->>Router: Back button pressed event\n    Router->>Delegate: Calls popRoute()\n    Delegate->>Mixin: Method call is handled by the mixin\n    Mixin->>Navigator: Calls maybePop() on the Navigator\n    Navigator-->>Mixin: Returns true/false Future\n    Mixin-->>Delegate: Returns true/false Future\n    Delegate-->>Router: Returns true/false Future\n    Router-->>RootDispatcher: Notifies result (handled or not)\n```\n\nThis diagram shows how the mixin seamlessly steps in to handle the `popRoute` call and delegate the actual popping work to the `Navigator`.\n\n## Why Use PopNavigatorRouterDelegateMixin?\n\nIf your `RouterDelegate` primarily manages navigation using a single `Navigator` (which is a very common pattern, especially for flat or linear navigation flows), this mixin simplifies your code significantly. You avoid writing boilerplate code to find the `Navigator`, call `maybePop`, and return the result.\n\nIt promotes clean separation of concerns:\n*   Your `RouterDelegate` handles *how* to build the UI based on the configuration and *what* pages go into the `Navigator`.\n*   The `PopNavigatorRouterDelegateMixin` handles the standard *interaction* between the back button event and the `Navigator`.\n\nUsing the mixin is highly recommended whenever your `RouterDelegate` includes a `Navigator` whose back stack should correspond to the system back button behavior.\n\n## How to Use PopNavigatorRouterDelegateMixin\n\nUsing `PopNavigatorRouterDelegateMixin` is straightforward. You simply mix it into your `RouterDelegate` class definition and provide the necessary `GlobalKey<NavigatorState>`.\n\nLet's revisit our `MyAppRouterDelegate` from [Chapter 4](04_routerdelegate_.md) and see how we already used the mixin.\n\n```dart\nimport 'package:flutter/foundation.dart'; // For SynchronousFuture\nimport 'package:flutter/material.dart';   // For Navigator, GlobalKey, MaterialPage\n\n// Re-using MyAppRouteConfiguration from previous chapters\nenum MyAppPath {\n  home,\n  itemDetail,\n}\n\nclass MyAppRouteConfiguration { // ... definition as before ... }\n\n// Our RouterDelegate using the mixin\nclass MyAppRouterDelegate extends RouterDelegate<MyAppRouteConfiguration>\n    with ChangeNotifier, PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration> { // *** Mixin Used Here! ***\n\n  // *** Required by PopNavigatorRouterDelegateMixin ***\n  // This is the GlobalKey that the mixin will use to find the Navigator\n  @override\n  final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();\n\n  MyAppRouteConfiguration? _currentConfiguration;\n\n  @override\n  MyAppRouteConfiguration? get currentConfiguration => _currentConfiguration;\n\n  @override\n  Future<void> setNewRoutePath(MyAppRouteConfiguration configuration) {\n    _currentConfiguration = configuration;\n    notifyListeners(); // Notify the Router to rebuild\n    return SynchronousFuture<void>(null);\n  }\n\n  // *** popRoute() is now implemented by the mixin! ***\n  // We DO NOT need to write the popRoute method here anymore if we use the mixin.\n\n  @override\n  Widget build(BuildContext context) {\n    List<Page> pages = [];\n\n    pages.add(\n       MaterialPage(\n         child: HomePage( // ... uses setNewRoutePath to navigate ... ),\n         key: const ValueKey('HomePage'),\n       )\n    );\n\n    if (_currentConfiguration?.isItemDetailPage == true) {\n      pages.add(\n        MaterialPage(\n          child: ItemDetailPage(itemId: _currentConfiguration!.itemId!),\n          key: ValueKey('ItemDetailPage-${_currentConfiguration!.itemId}'),\n        )\n      );\n    }\n\n    // Build a Navigator with the determined list of pages\n    return Navigator(\n      key: navigatorKey, // *** Use the mixin's navigatorKey here! ***\n      pages: pages,\n      onPopPage: (route, result) {\n        // This is called by the Navigator when a page's route is popped.\n        // It's triggered by things like the AppBar back button.\n        // We still need to handle this to update our internal configuration.\n        if (!route.didPop(result)) {\n          return false;\n        }\n\n        // Update config based on which page was popped.\n        // In this simple case, going back from ItemDetail leads to Home.\n         if (_currentConfiguration?.isItemDetailPage == true) {\n           setNewRoutePath(MyAppRouteConfiguration.home());\n        }\n\n        return true;\n      },\n    );\n  }\n  // dispose method inherited from ChangeNotifier\n}\n\n// HomePage and ItemDetailPage widgets as before\n```\n\nThe key changes are:\n\n1.  We add `with PopNavigatorRouterDelegateMixin<MyAppRouteConfiguration>` to the class definition. The `<MyAppRouteConfiguration>` part tells the mixin the type of configuration our `RouterDelegate` uses, although the mixin doesn't directly use the configuration type; it just needs to match the delegate's definition.\n2.  We provide the required `navigatorKey` getter: `final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();`. This creates a `GlobalKey` instance and makes it available to the mixin.\n3.  **We remove our own implementation of the `popRoute()` method.** The mixin now provides it for us.\n4.  **Crucially, when building the `Navigator`, we assign the mixin's `navigatorKey` to the `Navigator`'s `key` property:** `key: navigatorKey`. This allows the mixin's `popRoute` implementation to find and interact with *this specific* `Navigator` instance using `navigatorKey.currentState`.\n\nNow, thanks to the mixin, when the system back button is pressed and the [Router](05_router_.md) calls our delegate's `popRoute()`, the mixin will automatically execute `navigatorKey.currentState?.maybePop()` and return the result. The standard back button behavior of popping the top screen from the `Navigator` stack is handled for us!\n\nThe `onPopPage` callback in the `Navigator` is still necessary because it handles pops triggered *within* the `Navigator` itself (like the back arrow generated by a `MaterialApp`'s `AppBar`). The mixin handles the system back button event which comes from *outside* the `Navigator` via the [BackButtonDispatcher](06_backbuttondispatcher_.md) and [Router](05_router_.md). You often need both: `onPopPage` to update your delegate's internal state when the `Navigator` pops, and the mixin for `popRoute` to tell the `Navigator` *to* pop when the system back button is pressed.\n\n## Internal View (How Flutter Uses PopNavigatorRouterDelegateMixin)\n\nLet's look at the implementation of `PopNavigatorRouterDelegateMixin` within `packages/flutter/lib/src/widgets/router.dart`.\n\n```dart\n// Snippet from packages/flutter/lib/src/widgets/router.dart\nmixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T> { // 'on' constraint that this is for RouterDelegate<T>\n  /// The key used for retrieving the current navigator.\n  ///\n  /// When using this mixin, be sure to use this key to create the navigator.\n  GlobalKey<NavigatorState>? get navigatorKey;\n\n  @override\n  Future<bool> popRoute() {\n    final NavigatorState? navigator = navigatorKey?.currentState; // Get the NavigatorState using the provided key\n    return navigator?.maybePop() ?? SynchronousFuture<bool>(false); // Call maybePop and return its result\n  }\n}\n```\n\nThis is the entire implementation of the mixin's core logic!\n\n1.  `mixin PopNavigatorRouterDelegateMixin<T> on RouterDelegate<T>`: This declares the mixin and uses the `on` keyword to specify that it can only be mixed into classes that implement `RouterDelegate<T>`.\n2.  `GlobalKey<NavigatorState>? get navigatorKey;`: This is the abstract getter that you *must* implement in your class when you mix in `PopNavigatorRouterDelegateMixin`. The mixin needs a way to access a `GlobalKey` connected to the `Navigator`.\n3.  `@override Future<bool> popRoute() { ... }`: This overrides the `popRoute` method required by the `RouterDelegate` interface.\n    *   `final NavigatorState? navigator = navigatorKey?.currentState;`: This line attempts to get the current state of the `Navigator` widget associated with `navigatorKey`. If the `Navigator` is not yet built, or the key isn't associated with one, `navigator` will be null.\n    *   `return navigator?.maybePop() ?? SynchronousFuture<bool>(false);`: This is the heart of it.\n        *   `navigator?.maybePop()`: Calls the `maybePop()` method on the `NavigatorState` if `navigator` is not null. `maybePop()` attempts to pop the current route off the stack. It returns a `Future<bool>` that completes with `true` if a route was successfully popped, and `false` otherwise (e.g., if there's only one route left on the stack and it's the original route).\n        *   `?? SynchronousFuture<bool>(false)`: This is the null-aware coalescing operator. If `navigator?.maybePop()` returns null (e.g., because `navigator` was null), it defaults to returning a `SynchronousFuture` that completes with `false`. This handles cases where the `Navigator` isn't available yet.\n\nThis minimal code effectively hooks the back button event (received by `popRoute`) directly to the standard popping mechanism of the `Navigator` associated with the `navigatorKey`. Because `Navigator.maybePop()` internally checks if it *can* pop before actually doing so, the mixin provides robust default behavior that won't accidentally pop fundamental routes before the app is ready to close.\n\n## Conclusion\n\nThe `PopNavigatorRouterDelegateMixin` is a very useful helper for `RouterDelegate` classes that manage navigation using a `Navigator`. By mixing it in and providing a `GlobalKey` for your `Navigator`, you get a default implementation of the `popRoute()` method that automatically tells the `Navigator` to try and pop a route. This simplifies the connection between the system back button ([BackButtonDispatcher](06_backbuttondispatcher_.md) -> [Router](05_router_.md)) and the standard page-stack management of a `Navigator`, allowing your app to behave as users expect when they press the back button without requiring you to write intricate pop handling code in your delegate.\n\nWe've now covered all the core components of Flutter's Declarative Router system and how they work together to handle both incoming route information and outgoing user actions like the back button. Understanding these pieces gives you a solid foundation for building powerful and flexible navigation in your Flutter applications.\n\nThis is the final chapter in this introductory series on Flutter's Declarative Router! Congratulations on making it this far! You now have a foundational understanding of the delegates and widgets that make up this system.\n\n"}