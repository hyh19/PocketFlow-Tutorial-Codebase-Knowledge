{"\nFor the project `flutter_timer`:\n\nCodebase Context:\n--- File Index 0: lib/main.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_timer/app.dart';\n\nvoid main() => runApp(const App());\n\n\n--- File Index 1: lib/ticker.dart ---\nclass Ticker {\n  const Ticker();\n  Stream<int> tick({required int ticks}) {\n    return Stream.periodic(const Duration(seconds: 1), (x) => ticks - x - 1)\n        .take(ticks);\n  }\n}\n\n\n--- File Index 2: lib/app.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass App extends StatelessWidget {\n  const App({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Timer',\n      theme: ThemeData(\n        colorScheme: const ColorScheme.light(\n          primary: Color.fromRGBO(72, 74, 126, 1),\n        ),\n      ),\n      home: const TimerPage(),\n    );\n  }\n}\n\n\n--- File Index 3: lib/timer/timer.dart ---\nexport 'bloc/timer_bloc.dart';\nexport 'view/timer_page.dart';\n\n\n--- File Index 4: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File Index 5: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\n--- File Index 6: lib/timer/bloc/timer_state.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerState extends Equatable {\n  const TimerState(this.duration);\n  final int duration;\n\n  @override\n  List<Object> get props => [duration];\n}\n\nfinal class TimerInitial extends TimerState {\n  const TimerInitial(super.duration);\n\n  @override\n  String toString() => 'TimerInitial { duration: $duration }';\n}\n\nfinal class TimerRunPause extends TimerState {\n  const TimerRunPause(super.duration);\n\n  @override\n  String toString() => 'TimerRunPause { duration: $duration }';\n}\n\nfinal class TimerRunInProgress extends TimerState {\n  const TimerRunInProgress(super.duration);\n\n  @override\n  String toString() => 'TimerRunInProgress { duration: $duration }';\n}\n\nfinal class TimerRunComplete extends TimerState {\n  const TimerRunComplete() : super(0);\n}\n\n\n--- File Index 7: lib/timer/bloc/timer_event.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerEvent {\n  const TimerEvent();\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration});\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused();\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed();\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset();\n}\n\nclass _TimerTicked extends TimerEvent {\n  const _TimerTicked({required this.duration});\n  final int duration;\n}\n\n\n\n\nAnalyze the codebase context.\nIdentify the top 5-10 core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n- 0 # lib/main.dart\n- 1 # lib/ticker.dart\n- 2 # lib/app.dart\n- 3 # lib/timer/timer.dart\n- 4 # lib/timer/view/timer_page.dart\n- 5 # lib/timer/bloc/timer_bloc.dart\n- 6 # lib/timer/bloc/timer_state.dart\n- 7 # lib/timer/bloc/timer_event.dart\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization\n  description: |\n    Another core concept, similar to a blueprint for objects.\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to 10 abstractions\n```": "```yaml\n- name: |\n    TimerBloc\n  description: |\n    The TimerBloc is like the brain of the timer. It knows the current state of the timer (like how much time is left, if it's running, paused, or complete) and reacts to actions (events) like starting, pausing, resuming, or resetting the timer. It uses the Ticker to count down the seconds.\n  file_indices:\n    - 5 # lib/timer/bloc/timer_bloc.dart\n    - 4 # lib/timer/view/timer_page.dart\n    - 7 # lib/timer/bloc/timer_event.dart\n    - 6 # lib/timer/bloc/timer_state.dart\n- name: |\n    TimerState\n  description: |\n    TimerState represents the different situations the timer can be in. Think of these like status messages: is the timer just waiting to start (\"Initial\"), is it actively counting down (\"RunInProgress\"), is it temporarily stopped (\"RunPause\"), or has it reached zero (\"RunComplete\")? Each state also holds the current remaining duration.\n  file_indices:\n    - 6 # lib/timer/bloc/timer_state.dart\n    - 5 # lib/timer/bloc/timer_bloc.dart\n    - 4 # lib/timer/view/timer_page.dart\n- name: |\n    TimerEvent\n  description: |\n    TimerEvent is like sending a command to the TimerBloc. These are the actions that can happen to the timer, such as \"Start the timer!\" (TimerStarted), \"Pause the timer!\" (TimerPaused), \"Resume the timer!\" (TimerResumed), or \"Reset the timer to the beginning!\" (TimerReset). The Bloc listens for these events and changes its state accordingly.\n  file_indices:\n    - 7 # lib/timer/bloc/timer_event.dart\n    - 5 # lib/timer/bloc/timer_bloc.dart\n- name: |\n    Ticker\n  description: |\n    The Ticker is like a simple clock that can count down from a specific number every second. When you ask the Ticker to \"tick\" for a certain duration, it will provide a stream of numbers, decreasing by one each second, until it reaches zero. The TimerBloc uses this to know when a second has passed and update its state.\n  file_indices:\n    - 1 # lib/ticker.dart\n    - 5 # lib/timer/bloc/timer_bloc.dart\n    - 4 # lib/timer/view/timer_page.dart\n- name: |\n    TimerPage/TimerView\n  description: |\n    These are the visual parts of the timer application, what you see on the screen. TimerPage is the main screen that sets up the TimerBloc. TimerView is the actual layout containing the timer text display and the buttons (Actions) for controlling the timer. They get information from the TimerBloc and tell it what to do based on user interactions.\n  file_indices:\n    - 4 # lib/timer/view/timer_page.dart\n- name: |\n    Actions (Widget)\n  description: |\n    The Actions widget is responsible for showing the correct set of buttons based on the current state of the timer. When the timer is running, you see pause and reset buttons. When it's paused, you see play and reset buttons, and so on. It reads the TimerBloc's state to decide which buttons to display and sends events to the Bloc when a button is pressed.\n  file_indices:\n    - 4 # lib/timer/view/timer_page.dart\n    - 5 # lib/timer/bloc/timer_bloc.dart\n    - 7 # lib/timer/bloc/timer_event.dart\n- name: |\n    TimerText (Widget)\n  description: |\n    The TimerText widget is the display that shows the remaining time on the screen. It listens to the `duration` property in the TimerBloc's state and formats that number into a \"minutes:seconds\" string that is easy for users to read.\n  file_indices:\n    - 4 # lib/timer/view/timer_page.dart\n    - 6 # lib/timer/bloc/timer_state.dart\n```", "\nBased on the following abstractions and relevant code snippets from the project `flutter_timer`:\n\nList of Abstraction Indices and Names:\n0 # TimerBloc\n\n1 # TimerState\n\n2 # TimerEvent\n\n3 # Ticker\n\n4 # TimerPage/TimerView\n\n5 # Actions (Widget)\n\n6 # TimerText (Widget)\n\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\\n- Index 0: TimerBloc\n (Relevant file indices: [4, 5, 6, 7])\\n  Description: The TimerBloc is like the brain of the timer. It knows the current state of the timer (like how much time is left, if it's running, paused, or complete) and reacts to actions (events) like starting, pausing, resuming, or resetting the timer. It uses the Ticker to count down the seconds.\n\\n- Index 1: TimerState\n (Relevant file indices: [4, 5, 6])\\n  Description: TimerState represents the different situations the timer can be in. Think of these like status messages: is the timer just waiting to start (\"Initial\"), is it actively counting down (\"RunInProgress\"), is it temporarily stopped (\"RunPause\"), or has it reached zero (\"RunComplete\")? Each state also holds the current remaining duration.\n\\n- Index 2: TimerEvent\n (Relevant file indices: [5, 7])\\n  Description: TimerEvent is like sending a command to the TimerBloc. These are the actions that can happen to the timer, such as \"Start the timer!\" (TimerStarted), \"Pause the timer!\" (TimerPaused), \"Resume the timer!\" (TimerResumed), or \"Reset the timer to the beginning!\" (TimerReset). The Bloc listens for these events and changes its state accordingly.\n\\n- Index 3: Ticker\n (Relevant file indices: [1, 4, 5])\\n  Description: The Ticker is like a simple clock that can count down from a specific number every second. When you ask the Ticker to \"tick\" for a certain duration, it will provide a stream of numbers, decreasing by one each second, until it reaches zero. The TimerBloc uses this to know when a second has passed and update its state.\n\\n- Index 4: TimerPage/TimerView\n (Relevant file indices: [4])\\n  Description: These are the visual parts of the timer application, what you see on the screen. TimerPage is the main screen that sets up the TimerBloc. TimerView is the actual layout containing the timer text display and the buttons (Actions) for controlling the timer. They get information from the TimerBloc and tell it what to do based on user interactions.\n\\n- Index 5: Actions (Widget)\n (Relevant file indices: [4, 5, 7])\\n  Description: The Actions widget is responsible for showing the correct set of buttons based on the current state of the timer. When the timer is running, you see pause and reset buttons. When it's paused, you see play and reset buttons, and so on. It reads the TimerBloc's state to decide which buttons to display and sends events to the Bloc when a button is pressed.\n\\n- Index 6: TimerText (Widget)\n (Relevant file indices: [4, 6])\\n  Description: The TimerText widget is the display that shows the remaining time on the screen. It listens to the `duration` property in the TimerBloc's state and formats that number into a \"minutes:seconds\" string that is easy for users to read.\n\\n\\nRelevant File Snippets (Referenced by Index and Path):\\n--- File: 1 # lib/ticker.dart ---\\nclass Ticker {\n  const Ticker();\n  Stream<int> tick({required int ticks}) {\n    return Stream.periodic(const Duration(seconds: 1), (x) => ticks - x - 1)\n        .take(ticks);\n  }\n}\n\\n\\n--- File: 4 # lib/timer/view/timer_page.dart ---\\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\\n\\n--- File: 5 # lib/timer/bloc/timer_bloc.dart ---\\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\\n\\n--- File: 6 # lib/timer/bloc/timer_state.dart ---\\npart of 'timer_bloc.dart';\n\nsealed class TimerState extends Equatable {\n  const TimerState(this.duration);\n  final int duration;\n\n  @override\n  List<Object> get props => [duration];\n}\n\nfinal class TimerInitial extends TimerState {\n  const TimerInitial(super.duration);\n\n  @override\n  String toString() => 'TimerInitial { duration: $duration }';\n}\n\nfinal class TimerRunPause extends TimerState {\n  const TimerRunPause(super.duration);\n\n  @override\n  String toString() => 'TimerRunPause { duration: $duration }';\n}\n\nfinal class TimerRunInProgress extends TimerState {\n  const TimerRunInProgress(super.duration);\n\n  @override\n  String toString() => 'TimerRunInProgress { duration: $duration }';\n}\n\nfinal class TimerRunComplete extends TimerState {\n  const TimerRunComplete() : super(0);\n}\n\\n\\n--- File: 7 # lib/timer/bloc/timer_event.dart ---\\npart of 'timer_bloc.dart';\n\nsealed class TimerEvent {\n  const TimerEvent();\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration});\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused();\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed();\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset();\n}\n\nclass _TimerTicked extends TimerEvent {\n  const _TimerTicked({required this.duration});\n  final int duration;\n}\n\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project.\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\"\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\"\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  This project is a simple **timer** application built with Flutter.\n  It **counts down** from a set time, allowing you to **start**, **pause**, **resume**, and **reset** it using on-screen buttons.\n  The timer's state and actions are managed by a central \"brain\" that uses a \"clock\" to keep track of the passing seconds and updates the display.\nrelationships:\n  - from_abstraction: 0 # TimerBloc\n    to_abstraction: 1 # TimerState\n    label: \"Emits\"\n  - from_abstraction: 2 # TimerEvent\n    to_abstraction: 0 # TimerBloc\n    label: \"Triggers actions in\"\n  - from_abstraction: 3 # Ticker\n    to_abstraction: 0 # TimerBloc\n    label: \"Provides tick stream to\"\n  - from_abstraction: 4 # TimerPage/TimerView\n    to_abstraction: 0 # TimerBloc\n    label: \"Provides Bloc to\"\n  - from_abstraction: 4 # TimerPage/TimerView\n    to_abstraction: 5 # Actions (Widget)\n    label: \"Contains\"\n  - from_abstraction: 4 # TimerPage/TimerView\n    to_abstraction: 6 # TimerText (Widget)\n    label: \"Contains\"\n  - from_abstraction: 5 # Actions (Widget)\n    to_abstraction: 0 # TimerBloc\n    label: \"Sends Events to\"\n  - from_abstraction: 6 # TimerText (Widget)\n    to_abstraction: 0 # TimerBloc\n    label: \"Reads State from\"\n  - from_abstraction: 1 # TimerState\n    to_abstraction: 5 # Actions (Widget)\n    label: \"Determines UI in\"\n```", "\nGiven the following project abstractions and their relationships for the project ```` flutter_timer ````:\n\nAbstractions (Index # Name):\n- 0 # TimerBloc\n\n- 1 # TimerState\n\n- 2 # TimerEvent\n\n- 3 # Ticker\n\n- 4 # TimerPage/TimerView\n\n- 5 # Actions (Widget)\n\n- 6 # TimerText (Widget)\n\n\nContext about relationships and project summary:\nProject Summary:\nThis project is a simple **timer** application built with Flutter.\nIt **counts down** from a set time, allowing you to **start**, **pause**, **resume**, and **reset** it using on-screen buttons.\nThe timer's state and actions are managed by a central \"brain\" that uses a \"clock\" to keep track of the passing seconds and updates the display.\n\n\nRelationships (Indices refer to abstractions above):\n- From 0 (TimerBloc\n) to 1 (TimerState\n): Emits\n- From 2 (TimerEvent\n) to 0 (TimerBloc\n): Triggers actions in\n- From 3 (Ticker\n) to 0 (TimerBloc\n): Provides tick stream to\n- From 4 (TimerPage/TimerView\n) to 0 (TimerBloc\n): Provides Bloc to\n- From 4 (TimerPage/TimerView\n) to 5 (Actions (Widget)\n): Contains\n- From 4 (TimerPage/TimerView\n) to 6 (TimerText (Widget)\n): Contains\n- From 5 (Actions (Widget)\n) to 0 (TimerBloc\n): Sends Events to\n- From 6 (TimerText (Widget)\n) to 0 (TimerBloc\n): Reads State from\n- From 1 (TimerState\n) to 5 (Actions (Widget)\n): Determines UI in\n\n\nIf you are going to make a tutorial for ```` flutter_timer ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 4 # TimerPage/TimerView\n- 5 # Actions (Widget)\n- 6 # TimerText (Widget)\n- 2 # TimerEvent\n- 0 # TimerBloc\n- 1 # TimerState\n- 3 # Ticker\n```", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"TimerPage/TimerView\n\". This is Chapter 1.\n\nConcept Details:\n- Name: TimerPage/TimerView\n\n- Description:\nThese are the visual parts of the timer application, what you see on the screen. TimerPage is the main screen that sets up the TimerBloc. TimerView is the actual layout containing the timer text display and the buttons (Actions) for controlling the timer. They get information from the TimerBloc and tell it what to do based on user interactions.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: TimerPage/TimerView\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"Actions (Widget)\n\". This is Chapter 2.\n\nConcept Details:\n- Name: Actions (Widget)\n\n- Description:\nThe Actions widget is responsible for showing the correct set of buttons based on the current state of the timer. When the timer is running, you see pause and reset buttons. When it's paused, you see play and reset buttons, and so on. It reads the TimerBloc's state to decide which buttons to display and sends events to the Bloc when a button is pressed.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_event.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerEvent {\n  const TimerEvent();\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration});\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused();\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed();\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset();\n}\n\nclass _TimerTicked extends TimerEvent {\n  const _TimerTicked({required this.duration});\n  final int duration;\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2: Actions (Widget)\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"TimerText (Widget)\n\". This is Chapter 3.\n\nConcept Details:\n- Name: TimerText (Widget)\n\n- Description:\nThe TimerText widget is the display that shows the remaining time on the screen. It listens to the `duration` property in the TimerBloc's state and formats that number into a \"minutes:seconds\" string that is easy for users to read.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n---\n# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_state.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerState extends Equatable {\n  const TimerState(this.duration);\n  final int duration;\n\n  @override\n  List<Object> get props => [duration];\n}\n\nfinal class TimerInitial extends TimerState {\n  const TimerInitial(super.duration);\n\n  @override\n  String toString() => 'TimerInitial { duration: $duration }';\n}\n\nfinal class TimerRunPause extends TimerState {\n  const TimerRunPause(super.duration);\n\n  @override\n  String toString() => 'TimerRunPause { duration: $duration }';\n}\n\nfinal class TimerRunInProgress extends TimerState {\n  const TimerRunInProgress(super.duration);\n\n  @override\n  String toString() => 'TimerRunInProgress { duration: $duration }';\n}\n\nfinal class TimerRunComplete extends TimerState {\n  const TimerRunComplete() : super(0);\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3: TimerText (Widget)\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3: TimerText (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we saw the overall screen structure. In [Chapter 2: Actions (Widget)](02_actions__widget__.md), we learned how the buttons on our timer app decide what to show and how they tell the \"brain\" ([TimerBloc](05_timerbloc_.md)) what to do.\n\nNow, let's look at the part of the screen that's arguably the most important for a timer: the display that shows the time counting down! This is handled by our `TimerText` widget.\n\n### Seeing the Time: The Job of TimerText\n\nImagine looking at a digital clock. You don't see raw numbers like `180` (seconds). You see a friendly format like \"03:00\". The `TimerText` widget does exactly this: it takes the total number of seconds from our timer's \"brain\" ([TimerBloc](05_timerbloc_.md)) and turns it into a nice \"minutes:seconds\" string that's easy for us to read.\n\nIts main job is simply to *display* the current duration of the timer. It doesn't manage the duration itself; it just shows whatever number the [TimerBloc](05_timerbloc_.md) tells it to display.\n\n### How TimerText Gets the Time\n\nJust like the `Actions` widget, the `TimerText` widget needs to know what's happening with the timer's state. It specifically cares about the `duration` property within the [TimerState](06_timerstate_.md).\n\nTo get this information and *react* when it changes, the `TimerText` widget also uses a powerful tool called `BlocConsumer` or `BlocSelector`/`context.select`. In this case, we'll use `context.select` which is a neat way to just listen to a very specific part of the state.\n\nHere's the simplified code for the `TimerText` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/timer/bloc/timer_bloc.dart'; // We need the TimerBloc definition\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. Get the duration from the TimerBloc state\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n    // 2. Convert seconds into minutes and seconds format\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n\n    // 3. Display the formatted time\n    return Text(\n      '$minutesStr:$secondsStr',\n      // Add styling for big text\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge /* maybe .copyWith(...) */,\n    );\n  }\n}\n```\n\nLet's break it down:\n\n1.  `final duration = context.select((TimerBloc bloc) => bloc.state.duration);`: This is the key line! `context.select` lets this widget \"listen\" specifically to the `duration` variable inside the current state of the `TimerBloc`. Whenever the `duration` changes in the [TimerBloc](05_timerbloc_.md)'s state, this widget will rebuild and update the displayed time.\n2.  Formatting the Time: The code then takes the `duration` (which is in seconds) and performs some simple math to figure out the minutes and remaining seconds.\n    *   `duration / 60)$: This divides the total seconds by 60 to get the total minutes (including fractions).\n    *   `% 60)$: The modulo operator (`%`) gives us the remainder after dividing by 60. This gives us the remaining seconds.\n    *   `.floor()`: Rounds down to the nearest whole number for the minutes.\n    *   `.toString()`: Converts the numbers to text.\n    *   `.padLeft(2, '0')`: This is important! It makes sure the numbers like `5` become `05` so the format is consistent (like \"03:05\" instead of \"3:5\").\n3.  `return Text('$minutesStr:$secondsStr', ...);`: Finally, a standard Flutter `Text` widget is used to show the formatted string, applying a large text style to make it prominent on the screen.\n\nSo, the `TimerText` widget is like the display screen of our timer. It passively watches the timer's brain ([TimerBloc](05_timerbloc_.md)) and updates itself every time the brain says the time has changed.\n\n### The Flow: State Changes -> Text Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `TimerText` widget to update the time display:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (for the tick)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions)\n    TimerBloc-->Ticker: Start ticking\n    loop Every second\n        Ticker-->TimerBloc: Tick! Duration -= 1 second\n        TimerBloc->TimerBloc: Changes State (duration updates)\n        TimerBloc-->TimerText: Notifies of new state (with updated duration)\n        TimerText->TimerText: Rebuilds widget\n        TimerText-->User: Shows updated time on screen\n    end\n```\n\nThis diagram shows that the `TimerText` widget doesn't cause any changes itself. It just listens to the [TimerBloc](05_timerbloc_.md) and updates its display whenever the `duration` value within the [TimerBloc](05_timerbloc_.md)'s state changes. This happens frequently when the timer is running.\n\nYou can see the full, very short code for the `TimerText` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `TimerText` widget is a simple but crucial part of our timer app's user interface. Its sole responsibility is to display the time that it receives from the [TimerBloc](05_timerbloc_.md) in a user-friendly \"minutes:seconds\" format. By using `context.select`, it efficiently listens only for changes in the duration without needing to know anything else about the timer's internal workings.\n\nWe've now covered the main visual components of our timer: the overall screen (`TimerPage`/`TimerView`), the control buttons (`Actions`), and the time display (`TimerText`). But how does the timer actually *count* downwards and manage its state? That's where the core logic comes in, driven by Timer Events, States, and the Bloc itself.\n\nIn the next chapter, we'll introduce the concept of [TimerEvent](04_timerevent_.md), which are the messages our UI sends to the [TimerBloc](05_timerbloc_.md) to tell it what to do.\n\n[Next Chapter: TimerEvent](04_timerevent_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"TimerEvent\n\". This is Chapter 4.\n\nConcept Details:\n- Name: TimerEvent\n\n- Description:\nTimerEvent is like sending a command to the TimerBloc. These are the actions that can happen to the timer, such as \"Start the timer!\" (TimerStarted), \"Pause the timer!\" (TimerPaused), \"Resume the timer!\" (TimerResumed), or \"Reset the timer to the beginning!\" (TimerReset). The Bloc listens for these events and changes its state accordingly.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n---\n# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)\n---\n# Chapter 3: TimerText (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we saw the overall screen structure. In [Chapter 2: Actions (Widget)](02_actions__widget__.md), we learned how the buttons on our timer app decide what to show and how they tell the \"brain\" ([TimerBloc](05_timerbloc_.md)) what to do.\n\nNow, let's look at the part of the screen that's arguably the most important for a timer: the display that shows the time counting down! This is handled by our `TimerText` widget.\n\n### Seeing the Time: The Job of TimerText\n\nImagine looking at a digital clock. You don't see raw numbers like `180` (seconds). You see a friendly format like \"03:00\". The `TimerText` widget does exactly this: it takes the total number of seconds from our timer's \"brain\" ([TimerBloc](05_timerbloc_.md)) and turns it into a nice \"minutes:seconds\" string that's easy for us to read.\n\nIts main job is simply to *display* the current duration of the timer. It doesn't manage the duration itself; it just shows whatever number the [TimerBloc](05_timerbloc_.md) tells it to display.\n\n### How TimerText Gets the Time\n\nJust like the `Actions` widget, the `TimerText` widget needs to know what's happening with the timer's state. It specifically cares about the `duration` property within the [TimerState](06_timerstate_.md).\n\nTo get this information and *react* when it changes, the `TimerText` widget also uses a powerful tool called `BlocConsumer` or `BlocSelector`/`context.select`. In this case, we'll use `context.select` which is a neat way to just listen to a very specific part of the state.\n\nHere's the simplified code for the `TimerText` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/timer/bloc/timer_bloc.dart'; // We need the TimerBloc definition\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. Get the duration from the TimerBloc state\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n    // 2. Convert seconds into minutes and seconds format\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n\n    // 3. Display the formatted time\n    return Text(\n      '$minutesStr:$secondsStr',\n      // Add styling for big text\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge /* maybe .copyWith(...) */,\n    );\n  }\n}\n```\n\nLet's break it down:\n\n1.  `final duration = context.select((TimerBloc bloc) => bloc.state.duration);`: This is the key line! `context.select` lets this widget \"listen\" specifically to the `duration` variable inside the current state of the `TimerBloc`. Whenever the `duration` changes in the [TimerBloc](05_timerbloc_.md)'s state, this widget will rebuild and update the displayed time.\n2.  Formatting the Time: The code then takes the `duration` (which is in seconds) and performs some simple math to figure out the minutes and remaining seconds.\n    *   `duration / 60)$: This divides the total seconds by 60 to get the total minutes (including fractions).\n    *   `% 60)$: The modulo operator (`%`) gives us the remainder after dividing by 60. This gives us the remaining seconds.\n    *   `.floor()`: Rounds down to the nearest whole number for the minutes.\n    *   `.toString()`: Converts the numbers to text.\n    *   `.padLeft(2, '0')`: This is important! It makes sure the numbers like `5` become `05` so the format is consistent (like \"03:05\" instead of \"3:5\").\n3.  `return Text('$minutesStr:$secondsStr', ...);`: Finally, a standard Flutter `Text` widget is used to show the formatted string, applying a large text style to make it prominent on the screen.\n\nSo, the `TimerText` widget is like the display screen of our timer. It passively watches the timer's brain ([TimerBloc](05_timerbloc_.md)) and updates itself every time the brain says the time has changed.\n\n### The Flow: State Changes -> Text Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `TimerText` widget to update the time display:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (for the tick)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions)\n    TimerBloc-->Ticker: Start ticking\n    loop Every second\n        Ticker-->TimerBloc: Tick! Duration -= 1 second\n        TimerBloc->TimerBloc: Changes State (duration updates)\n        TimerBloc-->TimerText: Notifies of new state (with updated duration)\n        TimerText->TimerText: Rebuilds widget\n        TimerText-->User: Shows updated time on screen\n    end\n```\n\nThis diagram shows that the `TimerText` widget doesn't cause any changes itself. It just listens to the [TimerBloc](05_timerbloc_.md) and updates its display whenever the `duration` value within the [TimerBloc](05_timerbloc_.md)'s state changes. This happens frequently when the timer is running.\n\nYou can see the full, very short code for the `TimerText` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `TimerText` widget is a simple but crucial part of our timer app's user interface. Its sole responsibility is to display the time that it receives from the [TimerBloc](05_timerbloc_.md) in a user-friendly \"minutes:seconds\" format. By using `context.select`, it efficiently listens only for changes in the duration without needing to know anything else about the timer's internal workings.\n\nWe've now covered the main visual components of our timer: the overall screen (`TimerPage`/`TimerView`), the control buttons (`Actions`), and the time display (`TimerText`). But how does the timer actually *count* downwards and manage its state? That's where the core logic comes in, driven by Timer Events, States, and the Bloc itself.\n\nIn the next chapter, we'll introduce the concept of [TimerEvent](04_timerevent_.md), which are the messages our UI sends to the [TimerBloc](05_timerbloc_.md) to tell it what to do.\n\n[Next Chapter: TimerEvent](04_timerevent_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_event.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerEvent {\n  const TimerEvent();\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration});\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused();\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed();\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset();\n}\n\nclass _TimerTicked extends TimerEvent {\n  const _TimerTicked({required this.duration});\n  final int duration;\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4: TimerEvent\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4: TimerEvent\n\nWelcome back, future Flutter developer! In the last few chapters, we looked at what our timer app looks like ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons you press ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and where the time is shown ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)).\n\nBut how do the buttons (`Actions`) actually *tell* the timer to do something, like start counting, pause, or reset? They can't directly change the timer's internal working because that logic lives in the \"brain,\" the [TimerBloc](05_timerbloc_.md).\n\nThis is where `TimerEvent` comes in!\n\n### What is a TimerEvent? Sending Commands to the Brain\n\nThink of the [TimerBloc](05_timerbloc_.md) as a military commander who needs instructions. You, the user, are giving these instructions by tapping buttons on the screen. A `TimerEvent` is like sending a specific **command** to the commander ([TimerBloc](05_timerbloc_.md)).\n\nWhen you tap the \"Start\" button, the `Actions` widget doesn't just say \"Start!\". It sends a structured message, a `TimerStarted` event, to the [TimerBloc](05_timerbloc_.md). When you tap \"Pause\", it sends a `TimerPaused` event, and so on.\n\nThe [TimerBloc](05_timerbloc_.md) is constantly listening for these `TimerEvent` commands. When it receives one, it processes the command and updates the timer's state (like changing from \"paused\" to \"running\").\n\n### The Different Commands (TimerEvents)\n\nIn our timer app, we have a few main commands you can send. Each command is represented by a different type of `TimerEvent`:\n\n*   `TimerStarted`: \"Commander! Start counting down the timer!\" This event usually includes how long the timer should start with.\n*   `TimerPaused`: \"Commander! Stop counting for now, but remember the current time!\"\n*   `TimerResumed`: \"Commander! Okay, you can continue counting down from where you left off!\"\n*   `TimerReset`: \"Commander! Forget everything and set the timer back to its initial time!\"\n*   `_TimerTicked`: This is a special *internal* event. It's like the second hand on a clock ticking. The brain ([TimerBloc](05_timerbloc_.md)) sends this event to *itself* every second to remind itself to decrease the duration. You, the user, don't send this one!\n\nThese events are defined in a file called `timer_event.dart`.\n\n```dart\n// Inside lib/timer/bloc/timer_event.dart\n\npart of 'timer_bloc.dart'; // This connects it to the TimerBloc file\n\nsealed class TimerEvent {\n  const TimerEvent(); // All timer events share this base\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration}); // Tells the bloc the starting duration\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused(); // No extra info needed\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed(); // No extra info needed\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset(); // No extra info needed\n}\n\nclass _TimerTicked extends TimerEvent { // Notice the underscore - it's private!\n  const _TimerTicked({required this.duration}); // Tells the bloc the new duration\n  final int duration;\n}\n```\n\nLet's look at this simple code:\n\n*   `sealed class TimerEvent`: This is the base for all our commands. Think of it as the category \"Timer Commands\". `sealed` means all the *specific* commands must be defined in the same file.\n*   `final class ... extends TimerEvent`: Each specific command (`TimerStarted`, `TimerPaused`, etc.) is defined as a `class` that \"extends\" `TimerEvent`. This means they *are* a type of `TimerEvent`.\n*   `TimerStarted` needs a `duration` because when you start a timer, you need to know how long it should run.\n*   `_TimerTicked` also needs a `duration` because it reports the new time every second. The underscore `_` at the beginning means this event is only used *inside* the `timer_bloc.dart` file and is not sent from the UI.\n\n### Sending Events from Actions (Widget)\n\nNow let's see how the `Actions` widget uses these events. Remember from [Chapter 2: Actions (Widget)](02_actions__widget_.md) that when you tap a button, the `onPressed` function runs:\n\n```dart\n// Simplified snippet from Actions widget\n// ...\nonPressed: () {\n  // This line gets the TimerBloc instance\n  context.read<TimerBloc>()\n      // This line ADDS the event to the bloc!\n      .add(const TimerPaused()); // Or TimerStarted, TimerResumed, TimerReset\n},\n// ...\n```\n\nThis is the crucial connection! `context.read<TimerBloc>()` finds the [TimerBloc](05_timerbloc_.md) that was provided higher up in the widget tree ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)). Then, `.add(...)` sends the specific `TimerEvent` command to that [TimerBloc](05_bloc_.md).\n\nIt's like pointing at the commander and saying, \"Commander! Execute the 'Pause Timer' command!\"\n\n### How the TimerBloc Responds to Events\n\nThe [TimerBloc](05_timerbloc_.md) has special instructions for what to do when it receives each type of `TimerEvent`.\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart constructor\nTimerBloc(...) : ... {\n  on<TimerStarted>(_onStarted); // When TimerStarted arrives, call _onStarted method\n  on<TimerPaused>(_onPaused);   // When TimerPaused arrives, call _onPaused method\n  on<TimerResumed>(_onResumed); // When TimerResumed arrives, call _onResumed method\n  on<TimerReset>(_onReset);     // When TimerReset arrives, call _onReset method\n  on<_TimerTicked>(_onTicked);   // When _TimerTicked arrives, call _onTicked method\n}\n```\n\nThe `on<EventType>(methodName)` lines tell the [TimerBloc](05_timerbloc_.md): \"Whenever you receive a `EventType` event, run the code inside the `methodName` function.\" These methods (`_onStarted`, `_onPaused`, etc.) are where the actual timer logic happens (we'll explore this more in [Chapter 5: TimerBloc](05_timerbloc_.md)).\n\nWhen a `TimerEvent` is received, the corresponding method is called. Inside that method, the [TimerBloc](05_timerbloc_.md) will perform the necessary actions (like starting a tick timer, pausing it) and crucially, **emit** a new [TimerState](06_timerstate_.md) to describe the timer's *new* condition.\n\n### The Flow: User -> Event -> Bloc -> State -> UI\n\nHere's a simplified picture of how a user action (like tapping \"Start\") flows through our system using a `TimerEvent`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant TimerText as TimerText Widget\n\n    User->Actions: Taps \"Start\" Button\n    Actions->TimerEvent: Creates TimerStarted Event\n    Actions->TimerBloc: Adds TimerStarted Event\n    TimerBloc->TimerBloc: Processes TimerStarted Event (e.g., starts counting)\n    TimerBloc->TimerState: Creates New TimerState (e.g., TimerRunInProgress)\n    TimerBloc-->TimerBloc: Emits New TimerState\n    TimerBloc-->Actions: Notifies of New State (Actions may rebuild)\n    TimerBloc-->TimerText: Notifies of New State (TimerText rebuilds if duration changed)\n    TimerText-->User: Shows updated time (\"02:59\")\n```\n\nIn this flow:\n\n1.  You tap a button in the `Actions` widget.\n2.  The `Actions` widget creates the correct `TimerEvent` (the command).\n3.  The `Actions` widget sends (adds) this event to the `TimerBloc`.\n4.  The `TimerBloc` receives and processes the event according to its rules (the `on` handlers).\n5.  Based on the event, the `TimerBloc` decides what the new condition of the timer should be and creates a new `TimerState`.\n6.  The `TimerBloc` broadcasts (\"emits\") this new `TimerState`.\n7.  Widgets like `Actions` and `TimerText` are listening to the `TimerBloc`. When they hear about a new state, they update themselves accordingly (e.g., `Actions` shows different buttons, `TimerText` shows the new duration).\n\n### Conclusion\n\n`TimerEvent`s are the way our user interface (specifically the `Actions` widget) communicates with the core logic \"brain,\" the [TimerBloc](05_timerbloc_.md). They represent the *intent* of the user \u2013 what they want the timer to *do*. By sending these clear, structured commands, we keep the UI simple (it just sends messages) and the logic centralized in the [TimerBloc](05_timerbloc_.md), which knows how to act upon these commands.\n\nWe now understand how the UI sends commands. Next, we'll dive deep into the [TimerBloc](05_timerbloc_.md) itself to see how it receives these events and uses them to manage the timer's duration and state.\n\n[Next Chapter: TimerBloc](05_timerbloc_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"TimerBloc\n\". This is Chapter 5.\n\nConcept Details:\n- Name: TimerBloc\n\n- Description:\nThe TimerBloc is like the brain of the timer. It knows the current state of the timer (like how much time is left, if it's running, paused, or complete) and reacts to actions (events) like starting, pausing, resuming, or resetting the timer. It uses the Ticker to count down the seconds.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n---\n# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)\n---\n# Chapter 3: TimerText (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we saw the overall screen structure. In [Chapter 2: Actions (Widget)](02_actions__widget__.md), we learned how the buttons on our timer app decide what to show and how they tell the \"brain\" ([TimerBloc](05_timerbloc_.md)) what to do.\n\nNow, let's look at the part of the screen that's arguably the most important for a timer: the display that shows the time counting down! This is handled by our `TimerText` widget.\n\n### Seeing the Time: The Job of TimerText\n\nImagine looking at a digital clock. You don't see raw numbers like `180` (seconds). You see a friendly format like \"03:00\". The `TimerText` widget does exactly this: it takes the total number of seconds from our timer's \"brain\" ([TimerBloc](05_timerbloc_.md)) and turns it into a nice \"minutes:seconds\" string that's easy for us to read.\n\nIts main job is simply to *display* the current duration of the timer. It doesn't manage the duration itself; it just shows whatever number the [TimerBloc](05_timerbloc_.md) tells it to display.\n\n### How TimerText Gets the Time\n\nJust like the `Actions` widget, the `TimerText` widget needs to know what's happening with the timer's state. It specifically cares about the `duration` property within the [TimerState](06_timerstate_.md).\n\nTo get this information and *react* when it changes, the `TimerText` widget also uses a powerful tool called `BlocConsumer` or `BlocSelector`/`context.select`. In this case, we'll use `context.select` which is a neat way to just listen to a very specific part of the state.\n\nHere's the simplified code for the `TimerText` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/timer/bloc/timer_bloc.dart'; // We need the TimerBloc definition\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. Get the duration from the TimerBloc state\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n    // 2. Convert seconds into minutes and seconds format\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n\n    // 3. Display the formatted time\n    return Text(\n      '$minutesStr:$secondsStr',\n      // Add styling for big text\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge /* maybe .copyWith(...) */,\n    );\n  }\n}\n```\n\nLet's break it down:\n\n1.  `final duration = context.select((TimerBloc bloc) => bloc.state.duration);`: This is the key line! `context.select` lets this widget \"listen\" specifically to the `duration` variable inside the current state of the `TimerBloc`. Whenever the `duration` changes in the [TimerBloc](05_timerbloc_.md)'s state, this widget will rebuild and update the displayed time.\n2.  Formatting the Time: The code then takes the `duration` (which is in seconds) and performs some simple math to figure out the minutes and remaining seconds.\n    *   `duration / 60)$: This divides the total seconds by 60 to get the total minutes (including fractions).\n    *   `% 60)$: The modulo operator (`%`) gives us the remainder after dividing by 60. This gives us the remaining seconds.\n    *   `.floor()`: Rounds down to the nearest whole number for the minutes.\n    *   `.toString()`: Converts the numbers to text.\n    *   `.padLeft(2, '0')`: This is important! It makes sure the numbers like `5` become `05` so the format is consistent (like \"03:05\" instead of \"3:5\").\n3.  `return Text('$minutesStr:$secondsStr', ...);`: Finally, a standard Flutter `Text` widget is used to show the formatted string, applying a large text style to make it prominent on the screen.\n\nSo, the `TimerText` widget is like the display screen of our timer. It passively watches the timer's brain ([TimerBloc](05_timerbloc_.md)) and updates itself every time the brain says the time has changed.\n\n### The Flow: State Changes -> Text Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `TimerText` widget to update the time display:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (for the tick)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions)\n    TimerBloc-->Ticker: Start ticking\n    loop Every second\n        Ticker-->TimerBloc: Tick! Duration -= 1 second\n        TimerBloc->TimerBloc: Changes State (duration updates)\n        TimerBloc-->TimerText: Notifies of new state (with updated duration)\n        TimerText->TimerText: Rebuilds widget\n        TimerText-->User: Shows updated time on screen\n    end\n```\n\nThis diagram shows that the `TimerText` widget doesn't cause any changes itself. It just listens to the [TimerBloc](05_timerbloc_.md) and updates its display whenever the `duration` value within the [TimerBloc](05_timerbloc_.md)'s state changes. This happens frequently when the timer is running.\n\nYou can see the full, very short code for the `TimerText` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `TimerText` widget is a simple but crucial part of our timer app's user interface. Its sole responsibility is to display the time that it receives from the [TimerBloc](05_timerbloc_.md) in a user-friendly \"minutes:seconds\" format. By using `context.select`, it efficiently listens only for changes in the duration without needing to know anything else about the timer's internal workings.\n\nWe've now covered the main visual components of our timer: the overall screen (`TimerPage`/`TimerView`), the control buttons (`Actions`), and the time display (`TimerText`). But how does the timer actually *count* downwards and manage its state? That's where the core logic comes in, driven by Timer Events, States, and the Bloc itself.\n\nIn the next chapter, we'll introduce the concept of [TimerEvent](04_timerevent_.md), which are the messages our UI sends to the [TimerBloc](05_timerbloc_.md) to tell it what to do.\n\n[Next Chapter: TimerEvent](04_timerevent_.md)\n---\n# Chapter 4: TimerEvent\n\nWelcome back, future Flutter developer! In the last few chapters, we looked at what our timer app looks like ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons you press ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and where the time is shown ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)).\n\nBut how do the buttons (`Actions`) actually *tell* the timer to do something, like start counting, pause, or reset? They can't directly change the timer's internal working because that logic lives in the \"brain,\" the [TimerBloc](05_timerbloc_.md).\n\nThis is where `TimerEvent` comes in!\n\n### What is a TimerEvent? Sending Commands to the Brain\n\nThink of the [TimerBloc](05_timerbloc_.md) as a military commander who needs instructions. You, the user, are giving these instructions by tapping buttons on the screen. A `TimerEvent` is like sending a specific **command** to the commander ([TimerBloc](05_timerbloc_.md)).\n\nWhen you tap the \"Start\" button, the `Actions` widget doesn't just say \"Start!\". It sends a structured message, a `TimerStarted` event, to the [TimerBloc](05_timerbloc_.md). When you tap \"Pause\", it sends a `TimerPaused` event, and so on.\n\nThe [TimerBloc](05_timerbloc_.md) is constantly listening for these `TimerEvent` commands. When it receives one, it processes the command and updates the timer's state (like changing from \"paused\" to \"running\").\n\n### The Different Commands (TimerEvents)\n\nIn our timer app, we have a few main commands you can send. Each command is represented by a different type of `TimerEvent`:\n\n*   `TimerStarted`: \"Commander! Start counting down the timer!\" This event usually includes how long the timer should start with.\n*   `TimerPaused`: \"Commander! Stop counting for now, but remember the current time!\"\n*   `TimerResumed`: \"Commander! Okay, you can continue counting down from where you left off!\"\n*   `TimerReset`: \"Commander! Forget everything and set the timer back to its initial time!\"\n*   `_TimerTicked`: This is a special *internal* event. It's like the second hand on a clock ticking. The brain ([TimerBloc](05_timerbloc_.md)) sends this event to *itself* every second to remind itself to decrease the duration. You, the user, don't send this one!\n\nThese events are defined in a file called `timer_event.dart`.\n\n```dart\n// Inside lib/timer/bloc/timer_event.dart\n\npart of 'timer_bloc.dart'; // This connects it to the TimerBloc file\n\nsealed class TimerEvent {\n  const TimerEvent(); // All timer events share this base\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration}); // Tells the bloc the starting duration\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused(); // No extra info needed\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed(); // No extra info needed\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset(); // No extra info needed\n}\n\nclass _TimerTicked extends TimerEvent { // Notice the underscore - it's private!\n  const _TimerTicked({required this.duration}); // Tells the bloc the new duration\n  final int duration;\n}\n```\n\nLet's look at this simple code:\n\n*   `sealed class TimerEvent`: This is the base for all our commands. Think of it as the category \"Timer Commands\". `sealed` means all the *specific* commands must be defined in the same file.\n*   `final class ... extends TimerEvent`: Each specific command (`TimerStarted`, `TimerPaused`, etc.) is defined as a `class` that \"extends\" `TimerEvent`. This means they *are* a type of `TimerEvent`.\n*   `TimerStarted` needs a `duration` because when you start a timer, you need to know how long it should run.\n*   `_TimerTicked` also needs a `duration` because it reports the new time every second. The underscore `_` at the beginning means this event is only used *inside* the `timer_bloc.dart` file and is not sent from the UI.\n\n### Sending Events from Actions (Widget)\n\nNow let's see how the `Actions` widget uses these events. Remember from [Chapter 2: Actions (Widget)](02_actions__widget_.md) that when you tap a button, the `onPressed` function runs:\n\n```dart\n// Simplified snippet from Actions widget\n// ...\nonPressed: () {\n  // This line gets the TimerBloc instance\n  context.read<TimerBloc>()\n      // This line ADDS the event to the bloc!\n      .add(const TimerPaused()); // Or TimerStarted, TimerResumed, TimerReset\n},\n// ...\n```\n\nThis is the crucial connection! `context.read<TimerBloc>()` finds the [TimerBloc](05_timerbloc_.md) that was provided higher up in the widget tree ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)). Then, `.add(...)` sends the specific `TimerEvent` command to that [TimerBloc](05_bloc_.md).\n\nIt's like pointing at the commander and saying, \"Commander! Execute the 'Pause Timer' command!\"\n\n### How the TimerBloc Responds to Events\n\nThe [TimerBloc](05_timerbloc_.md) has special instructions for what to do when it receives each type of `TimerEvent`.\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart constructor\nTimerBloc(...) : ... {\n  on<TimerStarted>(_onStarted); // When TimerStarted arrives, call _onStarted method\n  on<TimerPaused>(_onPaused);   // When TimerPaused arrives, call _onPaused method\n  on<TimerResumed>(_onResumed); // When TimerResumed arrives, call _onResumed method\n  on<TimerReset>(_onReset);     // When TimerReset arrives, call _onReset method\n  on<_TimerTicked>(_onTicked);   // When _TimerTicked arrives, call _onTicked method\n}\n```\n\nThe `on<EventType>(methodName)` lines tell the [TimerBloc](05_timerbloc_.md): \"Whenever you receive a `EventType` event, run the code inside the `methodName` function.\" These methods (`_onStarted`, `_onPaused`, etc.) are where the actual timer logic happens (we'll explore this more in [Chapter 5: TimerBloc](05_timerbloc_.md)).\n\nWhen a `TimerEvent` is received, the corresponding method is called. Inside that method, the [TimerBloc](05_timerbloc_.md) will perform the necessary actions (like starting a tick timer, pausing it) and crucially, **emit** a new [TimerState](06_timerstate_.md) to describe the timer's *new* condition.\n\n### The Flow: User -> Event -> Bloc -> State -> UI\n\nHere's a simplified picture of how a user action (like tapping \"Start\") flows through our system using a `TimerEvent`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant TimerText as TimerText Widget\n\n    User->Actions: Taps \"Start\" Button\n    Actions->TimerEvent: Creates TimerStarted Event\n    Actions->TimerBloc: Adds TimerStarted Event\n    TimerBloc->TimerBloc: Processes TimerStarted Event (e.g., starts counting)\n    TimerBloc->TimerState: Creates New TimerState (e.g., TimerRunInProgress)\n    TimerBloc-->TimerBloc: Emits New TimerState\n    TimerBloc-->Actions: Notifies of New State (Actions may rebuild)\n    TimerBloc-->TimerText: Notifies of New State (TimerText rebuilds if duration changed)\n    TimerText-->User: Shows updated time (\"02:59\")\n```\n\nIn this flow:\n\n1.  You tap a button in the `Actions` widget.\n2.  The `Actions` widget creates the correct `TimerEvent` (the command).\n3.  The `Actions` widget sends (adds) this event to the `TimerBloc`.\n4.  The `TimerBloc` receives and processes the event according to its rules (the `on` handlers).\n5.  Based on the event, the `TimerBloc` decides what the new condition of the timer should be and creates a new `TimerState`.\n6.  The `TimerBloc` broadcasts (\"emits\") this new `TimerState`.\n7.  Widgets like `Actions` and `TimerText` are listening to the `TimerBloc`. When they hear about a new state, they update themselves accordingly (e.g., `Actions` shows different buttons, `TimerText` shows the new duration).\n\n### Conclusion\n\n`TimerEvent`s are the way our user interface (specifically the `Actions` widget) communicates with the core logic \"brain,\" the [TimerBloc](05_timerbloc_.md). They represent the *intent* of the user \u2013 what they want the timer to *do*. By sending these clear, structured commands, we keep the UI simple (it just sends messages) and the logic centralized in the [TimerBloc](05_timerbloc_.md), which knows how to act upon these commands.\n\nWe now understand how the UI sends commands. Next, we'll dive deep into the [TimerBloc](05_timerbloc_.md) itself to see how it receives these events and uses them to manage the timer's duration and state.\n\n[Next Chapter: TimerBloc](05_timerbloc_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_state.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerState extends Equatable {\n  const TimerState(this.duration);\n  final int duration;\n\n  @override\n  List<Object> get props => [duration];\n}\n\nfinal class TimerInitial extends TimerState {\n  const TimerInitial(super.duration);\n\n  @override\n  String toString() => 'TimerInitial { duration: $duration }';\n}\n\nfinal class TimerRunPause extends TimerState {\n  const TimerRunPause(super.duration);\n\n  @override\n  String toString() => 'TimerRunPause { duration: $duration }';\n}\n\nfinal class TimerRunInProgress extends TimerState {\n  const TimerRunInProgress(super.duration);\n\n  @override\n  String toString() => 'TimerRunInProgress { duration: $duration }';\n}\n\nfinal class TimerRunComplete extends TimerState {\n  const TimerRunComplete() : super(0);\n}\n\n\n--- File: lib/timer/bloc/timer_event.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerEvent {\n  const TimerEvent();\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration});\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused();\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed();\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset();\n}\n\nclass _TimerTicked extends TimerEvent {\n  const _TimerTicked({required this.duration});\n  final int duration;\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5: TimerBloc\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5: TimerBloc\n\nAlright, welcome back! In our previous chapters, we built the look and feel of our timer: the main screen ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and the time display ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)). We also learned about [TimerEvent](04_timerevent_.md)s ([Chapter 4: TimerEvent](04_timerevent_.md)), which are the \"commands\" our buttons send to the timer.\n\nNow, it's time to meet the **brain** of our timer app: the `TimerBloc`. This is where all the important decisions are made and where the timer actually counts down.\n\n### What is the TimerBloc? The Brain of the Timer\n\nImagine the `TimerBloc` is the central control room for our timer. It holds all the important information:\n\n*   How much time is currently left?\n*   Is the timer running, paused, or finished?\n\nAnd it knows how to react to the commands ([TimerEvent](04_timerevent_.md)s) sent its way:\n\n*   When it gets a \"Start\" command, it starts counting down.\n*   When it gets a \"Pause\" command, it stops counting.\n*   When it gets a \"Reset\" command, it sets the time back to the beginning.\n*   When it gets a \"_TimerTicked\" event (its internal reminder), it subtracts one second from the time.\n\nThe `TimerBloc` works with a special helper called a [Ticker](07_ticker_.md) to actually count the seconds. We'll learn more about the [Ticker](07_ticker_.md) in a later chapter, but for now, think of it as the stopwatch that the `TimerBloc` tells to start and stop.\n\nThe `TimerBloc` is built using a powerful pattern called **Bloc** (Business Logic Component), which helps separate the user interface (what you see) from the business logic (how things work).\n\n### TimerBloc's Main Responsibilities\n\nThe `TimerBloc` has two main jobs:\n\n1.  **Manage the State:** It keeps track of the timer's current condition ([TimerState](06_timerstate_.md)). Is it just starting (`TimerInitial`)? Is it counting down (`TimerRunInProgress`)? Is it paused (`TimerRunPause`)? Has it finished (`TimerRunComplete`)? It holds the current `duration` (time left) as part of this state.\n2.  **Process Events:** It listens for [TimerEvent](04_timerevent_.md)s (the commands from the UI or from itself) and updates the state accordingly.\n\n### How TimerBloc Works: Receiving Events and Emitting States\n\nHere's the basic cycle of the `TimerBloc`:\n\n1.  The `TimerBloc` starts with an initial state, usually `TimerInitial` with a default duration (like 60 seconds).\n2.  It waits for an event.\n3.  Something happens that sends an event (like the user tapping a button, or the [Ticker](07_ticker_.md) \"ticking\").\n4.  The `TimerBloc` receives the event.\n5.  Based on the type of event and its current state, the `TimerBloc` decides what the new state should be.\n6.  The `TimerBloc` *emits* (sends out) this new state.\n7.  Widgets that are listening to the `TimerBloc` (like `TimerText` and `Actions`) receive the new state and update themselves to show the latest information.\n8.  Go back to step 2 and wait for the next event.\n\nLet's look at the core structure of the `TimerBloc` code:\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  // Constructor: this is where the bloc is created\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) { // Start with the initial state\n    // These are the handlers for each event type\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker; // Holds a reference to the Ticker helper\n  static const int _duration = 60; // The initial timer duration\n\n  StreamSubscription<int>? _tickerSubscription; // Manages the ticking\n\n  @override\n  Future<void> close() {\n    // Clean up the ticker when the bloc is closed\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  // Methods that handle specific events (explained below)\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) { ... }\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) { ... }\n  void _onResumed(TimerResumed event, Emitter<TimerState> emit) { ... }\n  void _onReset(TimerReset event, Emitter<TimerState> emit) { ... }\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) { ... }\n}\n```\n\nIn this code:\n\n*   `class TimerBloc extends Bloc<TimerEvent, TimerState>`: This declares our `TimerBloc`. It inherits powerful features from the `Bloc` class. The `<TimerEvent, TimerState>` tells the Bloc that it will receive `TimerEvent`s and manage `TimerState`s.\n*   `super(const TimerInitial(_duration))`: When the `TimerBloc` is created, this line tells it to start with the `TimerInitial` state, setting the initial duration to `_duration` (60 seconds).\n*   `on<EventType>(_onMethod)`: These lines are the event handlers. They connect each `TimerEvent` type (like `TimerStarted`) to a specific method (`_onStarted`) that contains the logic for handling that event. The `Emitter<TimerState> emit` parameter in the handler methods is crucial \u2013 it's used to **emit** new states.\n*   `_ticker`: This stores the [Ticker](07_ticker_.md) object, which helps us count down the seconds.\n*   `_tickerSubscription`: When the timer is running, the `Ticker` sends out a signal every second. This subscription is like the connection cable that receives those signals. We need to manage it to start and stop the ticking.\n*   `close()`: This method is called when the `TimerBloc` is no longer needed (like when the screen is closed). It's important to clean up the `_tickerSubscription` to prevent memory leaks.\n\n### Handling Specific Events (The Logic)\n\nNow let's briefly look at what happens inside the event handler methods (the `_on...` functions). Remember, their job is to take an event and emit a new state. The `emit` function is how the bloc tells the world its state has changed.\n\n#### 1. Handling `TimerStarted` (`_onStarted`)\n\nWhen the `TimerBloc` receives a `TimerStarted` event:\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  emit(TimerRunInProgress(event.duration)); // 1. Change state to Running\n  _tickerSubscription?.cancel();           // 2. Stop any previous ticking\n  _tickerSubscription = _ticker           // 3. Start a new ticker subscription\n      .tick(ticks: event.duration)\n      .listen((duration) => add(_TimerTicked(duration: duration))); // 4. For each tick, add a _TimerTicked event\n}\n```\n\n1.  `emit(TimerRunInProgress(event.duration))`: It immediately changes the state to `TimerRunInProgress`, setting the current duration to the one provided by the `TimerStarted` event.\n2.  `_tickerSubscription?.cancel()`: It stops any existing tick timer (in case you hit Start twice).\n3.  `_ticker.tick(ticks: event.duration)`: It tells the [Ticker](07_ticker_.md) to start ticking down from the specified `duration`.\n4.  `.listen(...) => add(_TimerTicked(duration: duration))`: This is important! For every \"tick\" the [Ticker](07_ticker_.md) sends, the `TimerBloc` receives the updated `duration` and internally sends (adds) a `_TimerTicked` event to *itself*.\n\n#### 2. Handling `_TimerTicked` (`_onTicked`)\n\nThis is the event that makes the timer count down. It's sent by the [Ticker](07_ticker_.md) (via the subscription).\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n  emit(\n    event.duration > 0\n        ? TimerRunInProgress(event.duration) // 1. If time left, stay Running\n        : const TimerRunComplete(),        // 2. If time is 0, change to Complete\n  );\n}\n```\n\n1.  `event.duration > 0 ? TimerRunInProgress(event.duration)`: If the new duration received from the [Ticker](07_ticker_.md) is greater than 0, the state is updated to `TimerRunInProgress` with the new duration. This causes the `TimerText` widget to update.\n2.  `: const TimerRunComplete()`: If the duration reaches 0, the state is changed to `TimerRunComplete`.\n\n#### 3. Handling `TimerPaused` (`_onPaused`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n  if (state is TimerRunInProgress) { // 1. Only pause if it's currently running\n    _tickerSubscription?.pause();   // 2. Tell the ticker to pause\n    emit(TimerRunPause(state.duration)); // 3. Change state to Paused\n  }\n}\n```\n\n1.  It first checks if the current state is `TimerRunInProgress`. You can only pause a running timer!\n2.  `_tickerSubscription?.pause()`: It tells the [Ticker](07_ticker_.md) to pause its counting.\n3.  `emit(TimerRunPause(state.duration))`: It changes the state to `TimerRunPause`, remembering the duration at which it was paused.\n\n#### 4. Handling `TimerResumed` (`_onResumed`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n  if (state is TimerRunPause) { // 1. Only resume if it's currently paused\n    _tickerSubscription?.resume(); // 2. Tell the ticker to resume\n    emit(TimerRunInProgress(state.duration)); // 3. Change state back to Running\n  }\n}\n```\n\n1.  It checks if the current state is `TimerRunPause`. You can only resume a paused timer!\n2.  `_tickerSubscription?.resume()`: It tells the [Ticker](07_ticker_.md) to continue counting.\n3.  `emit(TimerRunInProgress(state.duration))`: It changes the state back to `TimerRunInProgress`.\n\n#### 5. Handling `TimerReset` (`_onReset`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onReset(TimerReset event, Emitter<TimerState> emit) {\n  _tickerSubscription?.cancel(); // 1. Stop the ticker completely\n  emit(const TimerInitial(_duration)); // 2. Change state back to initial\n}\n```\n\n1.  `_tickerSubscription?.cancel()`: This stops the [Ticker](07_ticker_.md) from counting, no matter what it was doing (running or paused).\n2.  `emit(const TimerInitial(_duration))`: It sets the state back to `TimerInitial` with the original duration.\n\n### The Flow: Events In, States Out\n\nHere's a diagram showing how the `TimerBloc` acts as the central hub, receiving events and emitting states that affect the UI:\n\n```mermaid\nsequenceDiagram\n    participant UI as UI Widgets (Actions, TimerText)\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant Ticker as Ticker (Counts Seconds)\n\n    UI->TimerEvent: User Action (e.g., Tap Start) creates Event\n    TimerEvent->TimerBloc: Event is added to the Bloc\n    TimerBloc->TimerBloc: Bloc processes Event based on its type (on methods)\n    opt TimerStarted / TimerResumed\n        TimerBloc->Ticker: Tell Ticker to start/resume\n        loop Every Second (while running)\n            Ticker-->TimerBloc: Send _TimerTicked Event to Bloc\n            TimerBloc->TimerBloc: Bloc processes _TimerTicked Event\n            TimerBloc->TimerState: Creates new TimerState (updated duration)\n            TimerBloc-->TimerBloc: Emits new TimerState\n        end\n    end\n    opt TimerPaused\n        TimerBloc->Ticker: Tell Ticker to pause\n        TimerBloc->TimerState: Creates new TimerState (Pause)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n        opt TimerReset\n        TimerBloc->Ticker: Tell Ticker to cancel\n        TimerBloc->TimerState: Creates new TimerState (Initial)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n\n    TimerBloc-->UI: New TimerState is received by listeners (BlocBuilder, select)\n    UI->UI: UI updates its display (buttons, time text) based on the new state\n```\n\nThis diagram shows that the `TimerBloc` sits in the middle, reacting to events and producing states. The [Ticker](07_ticker_.md) is a dependency that helps the `TimerBloc` execute the \"start\" and \"tick\" logic.\n\n### Conclusion\n\nThe `TimerBloc` is the core logic handler for our timer application. It receives `TimerEvent` commands, uses a [Ticker](07_ticker_.md) to manage the countdown, and updates its internal `TimerState` which it then emits for the UI to react to. By separating this logic into the `TimerBloc`, our UI widgets remain simple and focused on just displaying information and sending events. This makes our app organized and easier to manage.\n\nWe've seen how the `TimerBloc` *manages* the state by changing it. In the next chapter, we'll take a closer look at what the `TimerState` itself is and the different conditions it can represent.\n\n[Next Chapter: TimerState](06_timerstate_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"TimerState\n\". This is Chapter 6.\n\nConcept Details:\n- Name: TimerState\n\n- Description:\nTimerState represents the different situations the timer can be in. Think of these like status messages: is the timer just waiting to start (\"Initial\"), is it actively counting down (\"RunInProgress\"), is it temporarily stopped (\"RunPause\"), or has it reached zero (\"RunComplete\")? Each state also holds the current remaining duration.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n---\n# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)\n---\n# Chapter 3: TimerText (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we saw the overall screen structure. In [Chapter 2: Actions (Widget)](02_actions__widget__.md), we learned how the buttons on our timer app decide what to show and how they tell the \"brain\" ([TimerBloc](05_timerbloc_.md)) what to do.\n\nNow, let's look at the part of the screen that's arguably the most important for a timer: the display that shows the time counting down! This is handled by our `TimerText` widget.\n\n### Seeing the Time: The Job of TimerText\n\nImagine looking at a digital clock. You don't see raw numbers like `180` (seconds). You see a friendly format like \"03:00\". The `TimerText` widget does exactly this: it takes the total number of seconds from our timer's \"brain\" ([TimerBloc](05_timerbloc_.md)) and turns it into a nice \"minutes:seconds\" string that's easy for us to read.\n\nIts main job is simply to *display* the current duration of the timer. It doesn't manage the duration itself; it just shows whatever number the [TimerBloc](05_timerbloc_.md) tells it to display.\n\n### How TimerText Gets the Time\n\nJust like the `Actions` widget, the `TimerText` widget needs to know what's happening with the timer's state. It specifically cares about the `duration` property within the [TimerState](06_timerstate_.md).\n\nTo get this information and *react* when it changes, the `TimerText` widget also uses a powerful tool called `BlocConsumer` or `BlocSelector`/`context.select`. In this case, we'll use `context.select` which is a neat way to just listen to a very specific part of the state.\n\nHere's the simplified code for the `TimerText` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/timer/bloc/timer_bloc.dart'; // We need the TimerBloc definition\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. Get the duration from the TimerBloc state\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n    // 2. Convert seconds into minutes and seconds format\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n\n    // 3. Display the formatted time\n    return Text(\n      '$minutesStr:$secondsStr',\n      // Add styling for big text\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge /* maybe .copyWith(...) */,\n    );\n  }\n}\n```\n\nLet's break it down:\n\n1.  `final duration = context.select((TimerBloc bloc) => bloc.state.duration);`: This is the key line! `context.select` lets this widget \"listen\" specifically to the `duration` variable inside the current state of the `TimerBloc`. Whenever the `duration` changes in the [TimerBloc](05_timerbloc_.md)'s state, this widget will rebuild and update the displayed time.\n2.  Formatting the Time: The code then takes the `duration` (which is in seconds) and performs some simple math to figure out the minutes and remaining seconds.\n    *   `duration / 60)$: This divides the total seconds by 60 to get the total minutes (including fractions).\n    *   `% 60)$: The modulo operator (`%`) gives us the remainder after dividing by 60. This gives us the remaining seconds.\n    *   `.floor()`: Rounds down to the nearest whole number for the minutes.\n    *   `.toString()`: Converts the numbers to text.\n    *   `.padLeft(2, '0')`: This is important! It makes sure the numbers like `5` become `05` so the format is consistent (like \"03:05\" instead of \"3:5\").\n3.  `return Text('$minutesStr:$secondsStr', ...);`: Finally, a standard Flutter `Text` widget is used to show the formatted string, applying a large text style to make it prominent on the screen.\n\nSo, the `TimerText` widget is like the display screen of our timer. It passively watches the timer's brain ([TimerBloc](05_timerbloc_.md)) and updates itself every time the brain says the time has changed.\n\n### The Flow: State Changes -> Text Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `TimerText` widget to update the time display:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (for the tick)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions)\n    TimerBloc-->Ticker: Start ticking\n    loop Every second\n        Ticker-->TimerBloc: Tick! Duration -= 1 second\n        TimerBloc->TimerBloc: Changes State (duration updates)\n        TimerBloc-->TimerText: Notifies of new state (with updated duration)\n        TimerText->TimerText: Rebuilds widget\n        TimerText-->User: Shows updated time on screen\n    end\n```\n\nThis diagram shows that the `TimerText` widget doesn't cause any changes itself. It just listens to the [TimerBloc](05_timerbloc_.md) and updates its display whenever the `duration` value within the [TimerBloc](05_timerbloc_.md)'s state changes. This happens frequently when the timer is running.\n\nYou can see the full, very short code for the `TimerText` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `TimerText` widget is a simple but crucial part of our timer app's user interface. Its sole responsibility is to display the time that it receives from the [TimerBloc](05_timerbloc_.md) in a user-friendly \"minutes:seconds\" format. By using `context.select`, it efficiently listens only for changes in the duration without needing to know anything else about the timer's internal workings.\n\nWe've now covered the main visual components of our timer: the overall screen (`TimerPage`/`TimerView`), the control buttons (`Actions`), and the time display (`TimerText`). But how does the timer actually *count* downwards and manage its state? That's where the core logic comes in, driven by Timer Events, States, and the Bloc itself.\n\nIn the next chapter, we'll introduce the concept of [TimerEvent](04_timerevent_.md), which are the messages our UI sends to the [TimerBloc](05_timerbloc_.md) to tell it what to do.\n\n[Next Chapter: TimerEvent](04_timerevent_.md)\n---\n# Chapter 4: TimerEvent\n\nWelcome back, future Flutter developer! In the last few chapters, we looked at what our timer app looks like ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons you press ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and where the time is shown ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)).\n\nBut how do the buttons (`Actions`) actually *tell* the timer to do something, like start counting, pause, or reset? They can't directly change the timer's internal working because that logic lives in the \"brain,\" the [TimerBloc](05_timerbloc_.md).\n\nThis is where `TimerEvent` comes in!\n\n### What is a TimerEvent? Sending Commands to the Brain\n\nThink of the [TimerBloc](05_timerbloc_.md) as a military commander who needs instructions. You, the user, are giving these instructions by tapping buttons on the screen. A `TimerEvent` is like sending a specific **command** to the commander ([TimerBloc](05_timerbloc_.md)).\n\nWhen you tap the \"Start\" button, the `Actions` widget doesn't just say \"Start!\". It sends a structured message, a `TimerStarted` event, to the [TimerBloc](05_timerbloc_.md). When you tap \"Pause\", it sends a `TimerPaused` event, and so on.\n\nThe [TimerBloc](05_timerbloc_.md) is constantly listening for these `TimerEvent` commands. When it receives one, it processes the command and updates the timer's state (like changing from \"paused\" to \"running\").\n\n### The Different Commands (TimerEvents)\n\nIn our timer app, we have a few main commands you can send. Each command is represented by a different type of `TimerEvent`:\n\n*   `TimerStarted`: \"Commander! Start counting down the timer!\" This event usually includes how long the timer should start with.\n*   `TimerPaused`: \"Commander! Stop counting for now, but remember the current time!\"\n*   `TimerResumed`: \"Commander! Okay, you can continue counting down from where you left off!\"\n*   `TimerReset`: \"Commander! Forget everything and set the timer back to its initial time!\"\n*   `_TimerTicked`: This is a special *internal* event. It's like the second hand on a clock ticking. The brain ([TimerBloc](05_timerbloc_.md)) sends this event to *itself* every second to remind itself to decrease the duration. You, the user, don't send this one!\n\nThese events are defined in a file called `timer_event.dart`.\n\n```dart\n// Inside lib/timer/bloc/timer_event.dart\n\npart of 'timer_bloc.dart'; // This connects it to the TimerBloc file\n\nsealed class TimerEvent {\n  const TimerEvent(); // All timer events share this base\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration}); // Tells the bloc the starting duration\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused(); // No extra info needed\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed(); // No extra info needed\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset(); // No extra info needed\n}\n\nclass _TimerTicked extends TimerEvent { // Notice the underscore - it's private!\n  const _TimerTicked({required this.duration}); // Tells the bloc the new duration\n  final int duration;\n}\n```\n\nLet's look at this simple code:\n\n*   `sealed class TimerEvent`: This is the base for all our commands. Think of it as the category \"Timer Commands\". `sealed` means all the *specific* commands must be defined in the same file.\n*   `final class ... extends TimerEvent`: Each specific command (`TimerStarted`, `TimerPaused`, etc.) is defined as a `class` that \"extends\" `TimerEvent`. This means they *are* a type of `TimerEvent`.\n*   `TimerStarted` needs a `duration` because when you start a timer, you need to know how long it should run.\n*   `_TimerTicked` also needs a `duration` because it reports the new time every second. The underscore `_` at the beginning means this event is only used *inside* the `timer_bloc.dart` file and is not sent from the UI.\n\n### Sending Events from Actions (Widget)\n\nNow let's see how the `Actions` widget uses these events. Remember from [Chapter 2: Actions (Widget)](02_actions__widget_.md) that when you tap a button, the `onPressed` function runs:\n\n```dart\n// Simplified snippet from Actions widget\n// ...\nonPressed: () {\n  // This line gets the TimerBloc instance\n  context.read<TimerBloc>()\n      // This line ADDS the event to the bloc!\n      .add(const TimerPaused()); // Or TimerStarted, TimerResumed, TimerReset\n},\n// ...\n```\n\nThis is the crucial connection! `context.read<TimerBloc>()` finds the [TimerBloc](05_timerbloc_.md) that was provided higher up in the widget tree ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)). Then, `.add(...)` sends the specific `TimerEvent` command to that [TimerBloc](05_bloc_.md).\n\nIt's like pointing at the commander and saying, \"Commander! Execute the 'Pause Timer' command!\"\n\n### How the TimerBloc Responds to Events\n\nThe [TimerBloc](05_timerbloc_.md) has special instructions for what to do when it receives each type of `TimerEvent`.\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart constructor\nTimerBloc(...) : ... {\n  on<TimerStarted>(_onStarted); // When TimerStarted arrives, call _onStarted method\n  on<TimerPaused>(_onPaused);   // When TimerPaused arrives, call _onPaused method\n  on<TimerResumed>(_onResumed); // When TimerResumed arrives, call _onResumed method\n  on<TimerReset>(_onReset);     // When TimerReset arrives, call _onReset method\n  on<_TimerTicked>(_onTicked);   // When _TimerTicked arrives, call _onTicked method\n}\n```\n\nThe `on<EventType>(methodName)` lines tell the [TimerBloc](05_timerbloc_.md): \"Whenever you receive a `EventType` event, run the code inside the `methodName` function.\" These methods (`_onStarted`, `_onPaused`, etc.) are where the actual timer logic happens (we'll explore this more in [Chapter 5: TimerBloc](05_timerbloc_.md)).\n\nWhen a `TimerEvent` is received, the corresponding method is called. Inside that method, the [TimerBloc](05_timerbloc_.md) will perform the necessary actions (like starting a tick timer, pausing it) and crucially, **emit** a new [TimerState](06_timerstate_.md) to describe the timer's *new* condition.\n\n### The Flow: User -> Event -> Bloc -> State -> UI\n\nHere's a simplified picture of how a user action (like tapping \"Start\") flows through our system using a `TimerEvent`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant TimerText as TimerText Widget\n\n    User->Actions: Taps \"Start\" Button\n    Actions->TimerEvent: Creates TimerStarted Event\n    Actions->TimerBloc: Adds TimerStarted Event\n    TimerBloc->TimerBloc: Processes TimerStarted Event (e.g., starts counting)\n    TimerBloc->TimerState: Creates New TimerState (e.g., TimerRunInProgress)\n    TimerBloc-->TimerBloc: Emits New TimerState\n    TimerBloc-->Actions: Notifies of New State (Actions may rebuild)\n    TimerBloc-->TimerText: Notifies of New State (TimerText rebuilds if duration changed)\n    TimerText-->User: Shows updated time (\"02:59\")\n```\n\nIn this flow:\n\n1.  You tap a button in the `Actions` widget.\n2.  The `Actions` widget creates the correct `TimerEvent` (the command).\n3.  The `Actions` widget sends (adds) this event to the `TimerBloc`.\n4.  The `TimerBloc` receives and processes the event according to its rules (the `on` handlers).\n5.  Based on the event, the `TimerBloc` decides what the new condition of the timer should be and creates a new `TimerState`.\n6.  The `TimerBloc` broadcasts (\"emits\") this new `TimerState`.\n7.  Widgets like `Actions` and `TimerText` are listening to the `TimerBloc`. When they hear about a new state, they update themselves accordingly (e.g., `Actions` shows different buttons, `TimerText` shows the new duration).\n\n### Conclusion\n\n`TimerEvent`s are the way our user interface (specifically the `Actions` widget) communicates with the core logic \"brain,\" the [TimerBloc](05_timerbloc_.md). They represent the *intent* of the user \u2013 what they want the timer to *do*. By sending these clear, structured commands, we keep the UI simple (it just sends messages) and the logic centralized in the [TimerBloc](05_timerbloc_.md), which knows how to act upon these commands.\n\nWe now understand how the UI sends commands. Next, we'll dive deep into the [TimerBloc](05_timerbloc_.md) itself to see how it receives these events and uses them to manage the timer's duration and state.\n\n[Next Chapter: TimerBloc](05_timerbloc_.md)\n---\n# Chapter 5: TimerBloc\n\nAlright, welcome back! In our previous chapters, we built the look and feel of our timer: the main screen ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and the time display ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)). We also learned about [TimerEvent](04_timerevent_.md)s ([Chapter 4: TimerEvent](04_timerevent_.md)), which are the \"commands\" our buttons send to the timer.\n\nNow, it's time to meet the **brain** of our timer app: the `TimerBloc`. This is where all the important decisions are made and where the timer actually counts down.\n\n### What is the TimerBloc? The Brain of the Timer\n\nImagine the `TimerBloc` is the central control room for our timer. It holds all the important information:\n\n*   How much time is currently left?\n*   Is the timer running, paused, or finished?\n\nAnd it knows how to react to the commands ([TimerEvent](04_timerevent_.md)s) sent its way:\n\n*   When it gets a \"Start\" command, it starts counting down.\n*   When it gets a \"Pause\" command, it stops counting.\n*   When it gets a \"Reset\" command, it sets the time back to the beginning.\n*   When it gets a \"_TimerTicked\" event (its internal reminder), it subtracts one second from the time.\n\nThe `TimerBloc` works with a special helper called a [Ticker](07_ticker_.md) to actually count the seconds. We'll learn more about the [Ticker](07_ticker_.md) in a later chapter, but for now, think of it as the stopwatch that the `TimerBloc` tells to start and stop.\n\nThe `TimerBloc` is built using a powerful pattern called **Bloc** (Business Logic Component), which helps separate the user interface (what you see) from the business logic (how things work).\n\n### TimerBloc's Main Responsibilities\n\nThe `TimerBloc` has two main jobs:\n\n1.  **Manage the State:** It keeps track of the timer's current condition ([TimerState](06_timerstate_.md)). Is it just starting (`TimerInitial`)? Is it counting down (`TimerRunInProgress`)? Is it paused (`TimerRunPause`)? Has it finished (`TimerRunComplete`)? It holds the current `duration` (time left) as part of this state.\n2.  **Process Events:** It listens for [TimerEvent](04_timerevent_.md)s (the commands from the UI or from itself) and updates the state accordingly.\n\n### How TimerBloc Works: Receiving Events and Emitting States\n\nHere's the basic cycle of the `TimerBloc`:\n\n1.  The `TimerBloc` starts with an initial state, usually `TimerInitial` with a default duration (like 60 seconds).\n2.  It waits for an event.\n3.  Something happens that sends an event (like the user tapping a button, or the [Ticker](07_ticker_.md) \"ticking\").\n4.  The `TimerBloc` receives the event.\n5.  Based on the type of event and its current state, the `TimerBloc` decides what the new state should be.\n6.  The `TimerBloc` *emits* (sends out) this new state.\n7.  Widgets that are listening to the `TimerBloc` (like `TimerText` and `Actions`) receive the new state and update themselves to show the latest information.\n8.  Go back to step 2 and wait for the next event.\n\nLet's look at the core structure of the `TimerBloc` code:\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  // Constructor: this is where the bloc is created\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) { // Start with the initial state\n    // These are the handlers for each event type\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker; // Holds a reference to the Ticker helper\n  static const int _duration = 60; // The initial timer duration\n\n  StreamSubscription<int>? _tickerSubscription; // Manages the ticking\n\n  @override\n  Future<void> close() {\n    // Clean up the ticker when the bloc is closed\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  // Methods that handle specific events (explained below)\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) { ... }\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) { ... }\n  void _onResumed(TimerResumed event, Emitter<TimerState> emit) { ... }\n  void _onReset(TimerReset event, Emitter<TimerState> emit) { ... }\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) { ... }\n}\n```\n\nIn this code:\n\n*   `class TimerBloc extends Bloc<TimerEvent, TimerState>`: This declares our `TimerBloc`. It inherits powerful features from the `Bloc` class. The `<TimerEvent, TimerState>` tells the Bloc that it will receive `TimerEvent`s and manage `TimerState`s.\n*   `super(const TimerInitial(_duration))`: When the `TimerBloc` is created, this line tells it to start with the `TimerInitial` state, setting the initial duration to `_duration` (60 seconds).\n*   `on<EventType>(_onMethod)`: These lines are the event handlers. They connect each `TimerEvent` type (like `TimerStarted`) to a specific method (`_onStarted`) that contains the logic for handling that event. The `Emitter<TimerState> emit` parameter in the handler methods is crucial \u2013 it's used to **emit** new states.\n*   `_ticker`: This stores the [Ticker](07_ticker_.md) object, which helps us count down the seconds.\n*   `_tickerSubscription`: When the timer is running, the `Ticker` sends out a signal every second. This subscription is like the connection cable that receives those signals. We need to manage it to start and stop the ticking.\n*   `close()`: This method is called when the `TimerBloc` is no longer needed (like when the screen is closed). It's important to clean up the `_tickerSubscription` to prevent memory leaks.\n\n### Handling Specific Events (The Logic)\n\nNow let's briefly look at what happens inside the event handler methods (the `_on...` functions). Remember, their job is to take an event and emit a new state. The `emit` function is how the bloc tells the world its state has changed.\n\n#### 1. Handling `TimerStarted` (`_onStarted`)\n\nWhen the `TimerBloc` receives a `TimerStarted` event:\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  emit(TimerRunInProgress(event.duration)); // 1. Change state to Running\n  _tickerSubscription?.cancel();           // 2. Stop any previous ticking\n  _tickerSubscription = _ticker           // 3. Start a new ticker subscription\n      .tick(ticks: event.duration)\n      .listen((duration) => add(_TimerTicked(duration: duration))); // 4. For each tick, add a _TimerTicked event\n}\n```\n\n1.  `emit(TimerRunInProgress(event.duration))`: It immediately changes the state to `TimerRunInProgress`, setting the current duration to the one provided by the `TimerStarted` event.\n2.  `_tickerSubscription?.cancel()`: It stops any existing tick timer (in case you hit Start twice).\n3.  `_ticker.tick(ticks: event.duration)`: It tells the [Ticker](07_ticker_.md) to start ticking down from the specified `duration`.\n4.  `.listen(...) => add(_TimerTicked(duration: duration))`: This is important! For every \"tick\" the [Ticker](07_ticker_.md) sends, the `TimerBloc` receives the updated `duration` and internally sends (adds) a `_TimerTicked` event to *itself*.\n\n#### 2. Handling `_TimerTicked` (`_onTicked`)\n\nThis is the event that makes the timer count down. It's sent by the [Ticker](07_ticker_.md) (via the subscription).\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n  emit(\n    event.duration > 0\n        ? TimerRunInProgress(event.duration) // 1. If time left, stay Running\n        : const TimerRunComplete(),        // 2. If time is 0, change to Complete\n  );\n}\n```\n\n1.  `event.duration > 0 ? TimerRunInProgress(event.duration)`: If the new duration received from the [Ticker](07_ticker_.md) is greater than 0, the state is updated to `TimerRunInProgress` with the new duration. This causes the `TimerText` widget to update.\n2.  `: const TimerRunComplete()`: If the duration reaches 0, the state is changed to `TimerRunComplete`.\n\n#### 3. Handling `TimerPaused` (`_onPaused`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n  if (state is TimerRunInProgress) { // 1. Only pause if it's currently running\n    _tickerSubscription?.pause();   // 2. Tell the ticker to pause\n    emit(TimerRunPause(state.duration)); // 3. Change state to Paused\n  }\n}\n```\n\n1.  It first checks if the current state is `TimerRunInProgress`. You can only pause a running timer!\n2.  `_tickerSubscription?.pause()`: It tells the [Ticker](07_ticker_.md) to pause its counting.\n3.  `emit(TimerRunPause(state.duration))`: It changes the state to `TimerRunPause`, remembering the duration at which it was paused.\n\n#### 4. Handling `TimerResumed` (`_onResumed`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n  if (state is TimerRunPause) { // 1. Only resume if it's currently paused\n    _tickerSubscription?.resume(); // 2. Tell the ticker to resume\n    emit(TimerRunInProgress(state.duration)); // 3. Change state back to Running\n  }\n}\n```\n\n1.  It checks if the current state is `TimerRunPause`. You can only resume a paused timer!\n2.  `_tickerSubscription?.resume()`: It tells the [Ticker](07_ticker_.md) to continue counting.\n3.  `emit(TimerRunInProgress(state.duration))`: It changes the state back to `TimerRunInProgress`.\n\n#### 5. Handling `TimerReset` (`_onReset`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onReset(TimerReset event, Emitter<TimerState> emit) {\n  _tickerSubscription?.cancel(); // 1. Stop the ticker completely\n  emit(const TimerInitial(_duration)); // 2. Change state back to initial\n}\n```\n\n1.  `_tickerSubscription?.cancel()`: This stops the [Ticker](07_ticker_.md) from counting, no matter what it was doing (running or paused).\n2.  `emit(const TimerInitial(_duration))`: It sets the state back to `TimerInitial` with the original duration.\n\n### The Flow: Events In, States Out\n\nHere's a diagram showing how the `TimerBloc` acts as the central hub, receiving events and emitting states that affect the UI:\n\n```mermaid\nsequenceDiagram\n    participant UI as UI Widgets (Actions, TimerText)\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant Ticker as Ticker (Counts Seconds)\n\n    UI->TimerEvent: User Action (e.g., Tap Start) creates Event\n    TimerEvent->TimerBloc: Event is added to the Bloc\n    TimerBloc->TimerBloc: Bloc processes Event based on its type (on methods)\n    opt TimerStarted / TimerResumed\n        TimerBloc->Ticker: Tell Ticker to start/resume\n        loop Every Second (while running)\n            Ticker-->TimerBloc: Send _TimerTicked Event to Bloc\n            TimerBloc->TimerBloc: Bloc processes _TimerTicked Event\n            TimerBloc->TimerState: Creates new TimerState (updated duration)\n            TimerBloc-->TimerBloc: Emits new TimerState\n        end\n    end\n    opt TimerPaused\n        TimerBloc->Ticker: Tell Ticker to pause\n        TimerBloc->TimerState: Creates new TimerState (Pause)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n        opt TimerReset\n        TimerBloc->Ticker: Tell Ticker to cancel\n        TimerBloc->TimerState: Creates new TimerState (Initial)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n\n    TimerBloc-->UI: New TimerState is received by listeners (BlocBuilder, select)\n    UI->UI: UI updates its display (buttons, time text) based on the new state\n```\n\nThis diagram shows that the `TimerBloc` sits in the middle, reacting to events and producing states. The [Ticker](07_ticker_.md) is a dependency that helps the `TimerBloc` execute the \"start\" and \"tick\" logic.\n\n### Conclusion\n\nThe `TimerBloc` is the core logic handler for our timer application. It receives `TimerEvent` commands, uses a [Ticker](07_ticker_.md) to manage the countdown, and updates its internal `TimerState` which it then emits for the UI to react to. By separating this logic into the `TimerBloc`, our UI widgets remain simple and focused on just displaying information and sending events. This makes our app organized and easier to manage.\n\nWe've seen how the `TimerBloc` *manages* the state by changing it. In the next chapter, we'll take a closer look at what the `TimerState` itself is and the different conditions it can represent.\n\n[Next Chapter: TimerState](06_timerstate_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_state.dart ---\npart of 'timer_bloc.dart';\n\nsealed class TimerState extends Equatable {\n  const TimerState(this.duration);\n  final int duration;\n\n  @override\n  List<Object> get props => [duration];\n}\n\nfinal class TimerInitial extends TimerState {\n  const TimerInitial(super.duration);\n\n  @override\n  String toString() => 'TimerInitial { duration: $duration }';\n}\n\nfinal class TimerRunPause extends TimerState {\n  const TimerRunPause(super.duration);\n\n  @override\n  String toString() => 'TimerRunPause { duration: $duration }';\n}\n\nfinal class TimerRunInProgress extends TimerState {\n  const TimerRunInProgress(super.duration);\n\n  @override\n  String toString() => 'TimerRunInProgress { duration: $duration }';\n}\n\nfinal class TimerRunComplete extends TimerState {\n  const TimerRunComplete() : super(0);\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6: TimerState\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6: TimerState\n\nWelcome back! In the last chapter, [Chapter 5: TimerBloc](05_timerbloc_.md), we learned about the brain of our timer application, the `TimerBloc`. We saw how it receives commands ([TimerEvent](04_timerevent_.md)s) and uses a [Ticker](07_ticker_.md) to count down.\n\nToday, we'll focus on something the `TimerBloc` *manages*: the `TimerState`. Think of the `TimerState` as the **status message** of our timer. It tells us, and importantly, it tells our UI widgets ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), [Chapter 2: Actions (Widget)](02_actions__widget_.md), [Chapter 3: TimerText (Widget)](03_timertext__widget_.md)), exactly what the timer is doing right now.\n\n### What is TimerState? The Timer's Current Status\n\nImagine your phone when you're using a timer app. You see the time counting down, and the buttons change. The app knows whether it's \"Running\", \"Paused\", or if it has \"Finished\". This current condition is the timer's `State`.\n\nThe `TimerState` in our app serves this exact purpose. It's a piece of data that describes:\n\n1.  **What is the timer currently doing?** (Is it waiting, running, paused, or finished?)\n2.  **What is the current duration (time left)?**\n\nEvery time something important happens with the timer (like starting, pausing, or a second ticking by), the `TimerBloc` calculates the *new* status and creates a new `TimerState` to represent it. It then \"emits\" this new state so that interested parts of the app (like the widgets) can react.\n\n### The Different Statuses (TimerStates)\n\nOur timer can be in four main situations, and each is represented by a different type of `TimerState`. These are defined in the `timer_state.dart` file:\n\n```dart\n// Inside lib/timer/bloc/timer_state.dart\n\npart of 'timer_bloc.dart'; // Connects it to the TimerBloc file\n\nsealed class TimerState extends Equatable { // Base for all statuses\n  const TimerState(this.duration); // All states know the current duration\n  final int duration; // The time left in seconds\n\n  @override\n  List<Object> get props => [duration]; // Helps Bloc know when the state *really* changed\n}\n\nfinal class TimerInitial extends TimerState { // 1. Waiting to start\n  const TimerInitial(super.duration);\n  // ... formatting for printing the state ...\n}\n\nfinal class TimerRunPause extends TimerState { // 2. Temporarily stopped\n  const TimerRunPause(super.duration);\n    // ... formatting ...\n}\n\nfinal class TimerRunInProgress extends TimerState { // 3. Actively counting down\n  const TimerRunInProgress(super.duration);\n    // ... formatting ...\n}\n\nfinal class TimerRunComplete extends TimerState { // 4. Reached zero\n  const TimerRunComplete() : super(0); // Duration is 0 when complete\n    // ... formatting ...\n}\n```\n\nLet's break down these statuses:\n\n1.  **`TimerInitial`**: This is the very first state when the timer starts. It's like taking a fresh timer out of the box. It knows the *starting* duration, but it's not counting down yet.\n2.  **`TimerRunPause`**: The timer was counting down but is now temporarily stopped. It remembers how much time was left when it was paused.\n3.  **`TimerRunInProgress`**: The timer is actively counting down, second by second. This state holds the current duration remaining.\n4.  **`TimerRunComplete`**: The timer has successfully reached zero seconds!\n\nNotice that *all* these states inherit from a base `TimerState` class and *all* of them have a `duration` property. This is important because both our `TimerText` ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)) and `Actions` ([Chapter 2: Actions (Widget)](02_actions__widget_.md)) widgets need access to the current duration and the state type.\n\n*   `sealed class TimerState`: Like `TimerEvent`, this means all the distinct state types are defined in this one file.\n*   `const TimerState(this.duration)`: This constructor in the base class ensures that every state *must* have a duration associated with it.\n*   `final class ... extends TimerState`: Each specific state is a class inheriting from `TimerState`.\n*   `TimerRunComplete() : super(0)`: The `TimerRunComplete` state always sets its duration to 0, since the countdown is finished.\n\n### How Widgets Use TimerState\n\nOur UI widgets don't *change* the `TimerState`; they *listen* to the `TimerBloc` and read the current `TimerState` to know what to show.\n\n#### TimerText and TimerState\n\nThe `TimerText` widget only cares about one thing from the state: the `duration`.\n\n```dart\n// Inside TimerText widget (lib/timer/view/timer_page.dart)\n@override\nWidget build(BuildContext context) {\n  // This line reads the 'duration' property from the current TimerBloc state\n  final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n  // ... rest of the code formats and displays the duration ...\n  return Text('$minutesStr:$secondsStr', ...);\n}\n```\n\nAs we saw in [Chapter 3: TimerText (Widget)](03_timertext__widget_.md), `context.select` is used to specifically listen for changes to `bloc.state.duration`. Whenever the `TimerBloc` emits a new state *and* that new state's `duration` is different, the `TimerText` widget rebuilds itself to show the updated time. It doesn't need to know *which type* of state it is (Initial, InProgress, etc.), just the duration.\n\n#### Actions (Widget) and TimerState\n\nThe `Actions` widget, on the other hand, cares about *both* the type of state *and* sometimes the duration (for the initial \"Start\" button).\n\n```dart\n// Inside Actions widget (lib/timer/view/timer_page.dart)\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>(\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // Rebuild mainly when state TYPE changes\n    builder: (context, state) {\n      return Row(\n        children: [\n          ...switch (state) { // The 'switch' checks the state's TYPE\n            TimerInitial() => [\n              // Show Start button\n              FloatingActionButton(\n                onPressed: () => context\n                    .read<TimerBloc>()\n                    .add(TimerStarted(duration: state.duration)), // Uses initial duration\n                child: const Icon(Icons.play_arrow),\n              ),\n            ],\n            TimerRunInProgress() => [\n              // Show Pause and Reset buttons\n              // ...\n            ],\n            TimerRunPause() => [\n              // Show Play and Reset buttons\n              // ...\n            ],\n            TimerRunComplete() => [\n              // Show Reset button\n              // ...\n            ]\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nAs discussed in [Chapter 2: Actions (Widget)](02_actions__widget_.md), the `BlocBuilder` provides the current `state` object. The `switch (state)` statement looks at the specific *type* of `TimerState` (e.g., `TimerInitial`, `TimerRunInProgress`) and then displays the corresponding buttons. When in the `TimerInitial` state, it accesses `state.duration` to know the starting value to send in the `TimerStarted` event.\n\nThis is a powerful concept: the UI widgets are \"reactive\". They simply update themselves whenever the *state* of the underlying logic (`TimerBloc`) changes. They don't need to contain complex logic about *when* to change buttons; the `TimerBloc` updates the state, and the `Actions` widget automatically displays the correct buttons for that state.\n\n### How the TimerBloc Changes TimerState\n\nThe `TimerBloc` is the *only* part of our app that is allowed to create and \"emit\" new `TimerState` objects. This happens inside the event handler methods we saw in [Chapter 5: TimerBloc](05_timerbloc_.md). Each handler (`_onStarted`, `_onTicked`, etc.) uses the `emit` function to broadcast the new status.\n\n```dart\n// Inside TimerBloc's _onStarted method (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  // ... before emitting ...\n  emit(TimerRunInProgress(event.duration)); // <-- Creating and emitting a new TimerRunInProgress state\n  // ... after emitting ...\n}\n\n// Inside TimerBloc's _onTicked method (lib/timer/bloc/timer_bloc.dart)\nvoid _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n  emit(\n    // Creating and emitting either TimerRunInProgress or TimerRunComplete\n    event.duration > 0\n        ? TimerRunInProgress(event.duration)\n        : const TimerRunComplete(),\n  );\n}\n\n// Inside TimerBloc's _onPaused method (lib/timer/bloc/timer_bloc.dart)\nvoid _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n  if (state is TimerRunInProgress) {\n    // ... before emitting ...\n    emit(TimerRunPause(state.duration)); // <-- Creating and emitting a new TimerRunPause state\n  }\n}\n\n// And so on for _onResumed and _onReset...\n```\n\nThe `TimerBloc`'s responsibility is to calculate the *next* appropriate state after processing an event and then emit that new state.\n\n### The Flow: Bloc Changes State -> UI Reacts to State\n\nHere's a sequence showing how the `TimerBloc` changing the `TimerState` impacts the UI:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (Counts Seconds)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant Actions as Actions Widget\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions & TimerStarted event)\n    TimerBloc->Ticker: Start Ticking\n    loop Every Second (while running)\n        Ticker-->TimerBloc: Send _TimerTicked Event\n        TimerBloc->TimerBloc: Processes _TimerTicked (duration - 1)\n        alt If duration > 0\n            TimerBloc->TimerState: Creates new TimerRunInProgress state (updated duration)\n        else If duration == 0\n             TimerBloc->TimerState: Creates new TimerRunComplete state (duration 0)\n         end\n        TimerBloc-->TimerBloc: Emits New TimerState\n        TimerBloc-->Actions: Notifies Actions of New State\n        Actions->Actions: Actions checks state type, remains TimerRunInProgress\n        TimerBloc-->TimerText: Notifies TimerText of New State\n        TimerText->TimerText: TimerText checks state duration\n        alt If state duration changed\n            TimerText->TimerText: Rebuilds with new duration\n            TimerText-->User: Shows updated time\n        end\n        opt If TimerRunComplete\n             TimerBloc-->Actions: Notifies Actions of New State\n             Actions->Actions: Actions checks state type, sees TimerRunComplete\n             Actions->Actions: Rebuilds to show only Reset button\n             Actions-->User: Buttons change\n         end\n    end\n```\n\nThis shows that the `TimerState` emitted by the `TimerBloc` is the trigger for the UI to update. The `Actions` widget reacts primarily to the *type* of state, while the `TimerText` widget reacts primarily to the `duration` within the state.\n\n### Conclusion\n\n`TimerState` represents the different life stages or conditions of our timer (Initial, Running, Paused, Complete). It holds not just the status but also the crucial piece of information: the current duration. The `TimerBloc` is responsible for managing and emitting these states, while our UI widgets listen to the `TimerBloc` and automatically update their appearance and behavior based on the current `TimerState`. This separation of concerns, powered by Bloc, makes our timer app's logic and UI easy to reason about.\n\nWe've now seen how the internal state is represented. In the next chapter, we'll look at the final piece of the puzzle: the [Ticker](07_ticker_.md), which is the simple component that actually performs the second-by-second countdown.\n\n[Next Chapter: Ticker](07_ticker_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter_timer` about the concept: \"Ticker\n\". This is Chapter 7.\n\nConcept Details:\n- Name: Ticker\n\n- Description:\nThe Ticker is like a simple clock that can count down from a specific number every second. When you ask the Ticker to \"tick\" for a certain duration, it will provide a stream of numbers, decreasing by one each second, until it reaches zero. The TimerBloc uses this to know when a second has passed and update its state.\n\n\nComplete Tutorial Structure:\n1. [TimerPage/TimerView\n](01_timerpage_timerview_.md)\n2. [Actions (Widget)\n](02_actions__widget__.md)\n3. [TimerText (Widget)\n](03_timertext__widget__.md)\n4. [TimerEvent\n](04_timerevent_.md)\n5. [TimerBloc\n](05_timerbloc_.md)\n6. [TimerState\n](06_timerstate_.md)\n7. [Ticker\n](07_ticker_.md)\n\nContext from previous chapters:\n# Chapter 1: TimerPage/TimerView\n\nWelcome to the exciting world of building a timer application with Flutter! In this first chapter, we'll dive into the basic building blocks you see on the screen: the `TimerPage` and the `TimerView`.\n\nThink of our timer app like a physical timer you might use in your kitchen. There are two main parts:\n\n1.  **The whole timer device:** This is like our `TimerPage`. It's the main container that holds everything together and sets up all the internal workings.\n2.  **What you see on the front:** This is like our `TimerView`. It's the screen that shows the time counting down and the buttons (like Start, Pause, Reset) you press to control the timer.\n\nSo, the `TimerPage` is the main screen that gets our timer ready to go, and the `TimerView` is the part you actually look at and interact with. They work together to make the visual part of our timer app.\n\nLet's look at how these concepts are put together in our code.\n\n### TimerPage: Setting the Stage\n\nThe `TimerPage` is simple but important. Its main job is to set up something called a [TimerBloc](05_timerbloc_.md). We'll learn more about what a [TimerBloc](05_timerbloc_.md) is later, but for now, just know it's like the \"brain\" of our timer. It handles all the logic \u2013 like counting down the time, keeping track of whether the timer is running or paused, and so on.\n\nHere's a simplified look at the `TimerPage` code:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart'; // Don't worry about Ticker yet\nimport 'package:flutter_timer/timer/timer.dart'; // Imports TimerBloc and more\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider( // Setting up the TimerBloc\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(), // Displaying the TimerView\n    );\n  }\n}\n```\n\nIn this code:\n\n*   We use `BlocProvider` to make our `TimerBloc` available to other parts of the app that need it (specifically the `TimerView` and its internal parts).\n*   We then display the `TimerView` (`const TimerView()`), which is what the user will actually see.\n\nSo, `TimerPage` is like preparing the stage and setting up the main actor (the `TimerBloc`).\n\n### TimerView: What You See and Touch\n\nThe `TimerView` is where all the visual elements of our timer come together. This is where you'll see the time displayed and the buttons to control the timer.\n\nHere's a simplified look at the structure of the `TimerView`:\n\n```dart\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold( // Basic layout structure\n      body: Stack( // Allows stacking widgets\n        children: [\n          Background(), // A background gradient (visual detail)\n          Column( // Arranges items vertically\n            mainAxisAlignment: MainAxisAlignment.center, // Centers content\n            children: <Widget>[\n              Padding( // Adds space around the TimerText\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()), // Displays the time\n              ),\n              Actions(), // Contains the buttons\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\nInside the `TimerView`:\n\n*   We use a `Scaffold` for the basic app layout.\n*   We use a `Stack` to place the background *behind* the main content (the time and buttons).\n*   A `Column` organizes the time display (`TimerText`) and the buttons (`Actions`) one below the other, centered on the screen.\n*   `TimerText` and `Actions` are separate widgets that handle displaying the time and the buttons, respectively. We'll look at these in more detail in the next chapters: [Actions (Widget)](02_actions__widget__.md) and [TimerText (Widget)](03_timertext__widget__.md).\n\nThe `TimerView` doesn't do any counting or logic itself. It just shows information it gets and tells the \"brain\" ([TimerBloc](05_timerbloc_.md)) when a button is tapped.\n\n### How TimerPage and TimerView Work Together (High Level)\n\nImagine our timer:\n\n1.  When the app starts, the `TimerPage` is built.\n2.  The `TimerPage` creates the `TimerBloc` (the brain) and provides it to the rest of the app.\n3.  The `TimerPage` then shows the `TimerView`.\n4.  The `TimerView` displays the initial time using the [TimerText](03_timertext__widget__.md) widget.\n5.  The `TimerView` shows the initial buttons using the [Actions (Widget)](02_actions__widget__.md) widget.\n6.  When you tap a button in the [Actions (Widget)](02_actions__widget__.md) widget (part of the `TimerView`), it sends a message to the [TimerBloc](05_timerbloc_.md) (the brain).\n7.  The [TimerBloc](05_timerbloc_.md) updates the time.\n8.  The `TimerView` notices the time has changed (because it's watching the [TimerBloc](05_timerbloc_.md)) and updates the [TimerText](03_timertext__widget_.md) to show the new time.\n9.  The [TimerBloc](05_bloc_.md) might also tell the `TimerView` that the timer is now running (or paused), so the `TimerView` updates the [Actions (Widget)](02_actions__widget_.md) to show the correct buttons (Pause instead of Start).\n\nIt's like the `TimerView` is the face and hands of a clock, and the [TimerBloc](05_timerbloc_.md) is the gears and motor inside. The face shows the time, and the buttons on the outside let you interact, but the internal mechanism ([TimerBloc](05_timerbloc_.md)) is what actually keeps track of the time.\n\n### Conclusion\n\nIn this chapter, we learned about `TimerPage` and `TimerView`, the foundational visual parts of our timer application. `TimerPage` sets up the \"brain\" ([TimerBloc](05_timerbloc_.md)), and `TimerView` is the layout that displays the time and the control buttons. They work together, with `TimerView` showing information from the [TimerBloc](05_timerbloc_.md) and telling the [TimerBloc](05_timerbloc_.md) when a user taps a button.\n\nNext, we'll look closer at the [Actions (Widget)](02_actions__widget__.md) widget, which is responsible for displaying the buttons you use to control the timer.\n\n[Next Chapter: Actions (Widget)](02_actions__widget__.md)\n---\n# Chapter 2: Actions (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we set up the basic screen structure for our timer app. We saw that the `TimerView` contains a special widget called `Actions`. Today, we're going to really dig into what that `Actions` widget does and why it's so important for controlling our timer.\n\nRemember the physical timer analogy? If the `TimerView` is the face of the timer with the display and buttons, the `Actions` widget is specifically the **buttons** themselves. But not just any buttons \u2013 it's the part that makes sure you see the *right* buttons at the *right* time.\n\n### Showing the Right Buttons\n\nThink about our timer. When it's just starting (like when you first take it out of the box), you'd expect to see a \"Start\" button. Once you press start, you'd probably see \"Pause\" and \"Reset\" instead. If you pause it, you might see \"Play\" (to resume) and \"Reset\". And when the timer finishes, maybe just \"Reset\" to start again.\n\nThe `Actions` widget's main job is to figure out which group of buttons to show based on what the timer is currently doing (its \"state\"). Is it counting down? Is it paused? Is it finished?\n\nThis is where our \"brain,\" the [TimerBloc](05_timerbloc_.md), comes in handy. The `Actions` widget doesn't decide the state itself; it *listens* to the [TimerBloc](05_timerbloc_.md)'s state and displays the buttons that match that state.\n\n### How `Actions` Works\n\nLet's look at the heart of the `Actions` widget. It uses something called `BlocBuilder`.\n\n```dart\n// Inside the Actions widget's build method\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>( // 1. Watch the TimerBloc state\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // 2. Only rebuild when the state type changes\n    builder: (context, state) { // 3. Build the buttons based on the current state\n      return Row( // Arrange buttons side-by-side\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly, // Space them out\n        children: [\n          ...switch (state) { // 4. Choose which buttons to show based on state\n            TimerInitial() => [\n              // Buttons for the initial state\n            ],\n            TimerRunInProgress() => [\n              // Buttons for when the timer is running\n            ],\n            // ... other states\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nLet's break this down:\n\n1.  `BlocBuilder<TimerBloc, TimerState>`: This tells Flutter that this widget wants to \"watch\" our `TimerBloc` and that the state it cares about is a `TimerState` (we'll learn more about [TimerState](06_timerstate_.md) later, but for now, think of it as a variable holding the timer's current condition).\n2.  `buildWhen`: This is a cool optimization. We only want to change the set of buttons when the *type* of timer state changes (like going from \"running\" to \"paused\"), not every single time the duration ticks down.\n3.  `builder`: This is the part that actually builds the visual widget. It gets the current `context` (information about where this widget is in the app) and the current `state` from the `TimerBloc`.\n4.  `...switch (state)`: This block is where the magic happens! It looks at the `state` and uses a `switch` statement (like asking \"What case are we in?\") to decide which list of buttons to create.\n\nLet's see what buttons are shown for each state:\n\n#### `TimerInitial` State (Just starting out)\n\n```dart\nswitch (state) {\n  TimerInitial() => [\n    FloatingActionButton( // A nice circular button\n      child: const Icon(Icons.play_arrow), // A triangle icon (play)\n      onPressed: () => context // What happens when pressed\n          .read<TimerBloc>() // Get the TimerBloc\n          .add(TimerStarted(duration: state.duration)), // Tell it to start\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the state is `TimerInitial`, we only show *one* button: a play button. When this button is pressed, we `read` the `TimerBloc` and `add` a `TimerStarted` [TimerEvent](04_timerevent_.md). This is how `Actions` tells the [TimerBloc](05_timerbloc_.md) that the user wants to start the timer.\n\n#### `TimerRunInProgress` State (Timer is counting down)\n\n```dart\nswitch (state) {\n  // ... TimerInitial ...\n  TimerRunInProgress() => [\n    FloatingActionButton(\n      child: const Icon(Icons.pause), // Pause icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerPaused()); // Tell it to pause\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nIf the state is `TimerRunInProgress` (meaning the timer is actively counting down), we show two buttons: Pause and Reset. Tapping Pause sends a `TimerPaused` event, and tapping Reset sends a `TimerReset` event to the [TimerBloc](05_timerbloc_.md).\n\n#### `TimerRunPause` State (Timer is paused)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress ...\n  TimerRunPause() => [\n    FloatingActionButton(\n      child: const Icon(Icons.play_arrow), // Play icon (to resume)\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerResumed()); // Tell it to resume\n      },\n    ),\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ],\n  // ... other states\n}\n```\n\nWhen the timer is in the `TimerRunPause` state, we also show two buttons, but this time it's Play (to resume) and Reset. Pressing Play sends a `TimerResumed` event, and Reset sends a `TimerReset` event.\n\n#### `TimerRunComplete` State (Timer reached 0)\n\n```dart\nswitch (state) {\n  // ... TimerInitial, TimerRunInProgress, TimerRunPause ...\n  TimerRunComplete() => [\n    FloatingActionButton(\n      child: const Icon(Icons.replay), // Replay icon\n      onPressed: () {\n        context.read<TimerBloc>().add(const TimerReset()); // Tell it to reset\n      },\n    ),\n  ]\n}\n```\n\nFinally, if the state is `TimerRunComplete` (the timer has finished), we only show the Reset button. Tapping it sends a `TimerReset` event to get the timer ready for another go.\n\n### The Flow: State Changes -> Button Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `Actions` widget to update its buttons:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerBloc as TimerBloc (Brain)\n\n    User->Actions: Taps \"Start\" button\n    Actions->TimerBloc: Send TimerStarted Event\n    TimerBloc->TimerBloc: Changes State to TimerRunInProgress\n    TimerBloc-->Actions: Notifies of new state (TimerRunInProgress)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Pause\" and \"Reset\" buttons\n    User->Actions: Taps \"Pause\" button\n    Actions->TimerBloc: Send TimerPaused Event\n    TimerBloc->TimerBloc: Changes State to TimerRunPause\n    TimerBloc-->Actions: Notifies of new state (TimerRunPause)\n    Actions->Actions: Rebuilds widget\n    Actions-->User: Shows \"Play\" and \"Reset\" buttons\n```\n\nThis diagram illustrates the core concept: the `Actions` widget *reacts* to changes in the [TimerBloc](05_timerbloc_.md)'s state. It doesn't hold the state itself; it just looks at the state provided by the [TimerBloc](05_timerbloc_.md) and draws the corresponding buttons. When a button is pressed, it doesn't change the state directly; instead, it sends a message (an event) back to the [TimerBloc](05_timerbloc_.md), telling it what the user wants to do.\n\nYou can see the full code for the `Actions` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `Actions` widget is a great example of how we separate concerns in our app. It's only responsible for the *visual* presentation of the control buttons and sending user *actions* (button taps) to the brain ([TimerBloc](05_timerbloc_.md)). It doesn't handle the logic of counting down or managing the timer state itself. This makes our code cleaner and easier to understand.\n\nIn the next chapter, we'll explore the `TimerText` widget, which is responsible for displaying the time itself.\n\n[Next Chapter: TimerText (Widget)](03_timertext__widget__.md)\n---\n# Chapter 3: TimerText (Widget)\n\nWelcome back! In [Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), we saw the overall screen structure. In [Chapter 2: Actions (Widget)](02_actions__widget__.md), we learned how the buttons on our timer app decide what to show and how they tell the \"brain\" ([TimerBloc](05_timerbloc_.md)) what to do.\n\nNow, let's look at the part of the screen that's arguably the most important for a timer: the display that shows the time counting down! This is handled by our `TimerText` widget.\n\n### Seeing the Time: The Job of TimerText\n\nImagine looking at a digital clock. You don't see raw numbers like `180` (seconds). You see a friendly format like \"03:00\". The `TimerText` widget does exactly this: it takes the total number of seconds from our timer's \"brain\" ([TimerBloc](05_timerbloc_.md)) and turns it into a nice \"minutes:seconds\" string that's easy for us to read.\n\nIts main job is simply to *display* the current duration of the timer. It doesn't manage the duration itself; it just shows whatever number the [TimerBloc](05_timerbloc_.md) tells it to display.\n\n### How TimerText Gets the Time\n\nJust like the `Actions` widget, the `TimerText` widget needs to know what's happening with the timer's state. It specifically cares about the `duration` property within the [TimerState](06_timerstate_.md).\n\nTo get this information and *react* when it changes, the `TimerText` widget also uses a powerful tool called `BlocConsumer` or `BlocSelector`/`context.select`. In this case, we'll use `context.select` which is a neat way to just listen to a very specific part of the state.\n\nHere's the simplified code for the `TimerText` widget:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/timer/bloc/timer_bloc.dart'; // We need the TimerBloc definition\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // 1. Get the duration from the TimerBloc state\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n    // 2. Convert seconds into minutes and seconds format\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n\n    // 3. Display the formatted time\n    return Text(\n      '$minutesStr:$secondsStr',\n      // Add styling for big text\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge /* maybe .copyWith(...) */,\n    );\n  }\n}\n```\n\nLet's break it down:\n\n1.  `final duration = context.select((TimerBloc bloc) => bloc.state.duration);`: This is the key line! `context.select` lets this widget \"listen\" specifically to the `duration` variable inside the current state of the `TimerBloc`. Whenever the `duration` changes in the [TimerBloc](05_timerbloc_.md)'s state, this widget will rebuild and update the displayed time.\n2.  Formatting the Time: The code then takes the `duration` (which is in seconds) and performs some simple math to figure out the minutes and remaining seconds.\n    *   `duration / 60)$: This divides the total seconds by 60 to get the total minutes (including fractions).\n    *   `% 60)$: The modulo operator (`%`) gives us the remainder after dividing by 60. This gives us the remaining seconds.\n    *   `.floor()`: Rounds down to the nearest whole number for the minutes.\n    *   `.toString()`: Converts the numbers to text.\n    *   `.padLeft(2, '0')`: This is important! It makes sure the numbers like `5` become `05` so the format is consistent (like \"03:05\" instead of \"3:5\").\n3.  `return Text('$minutesStr:$secondsStr', ...);`: Finally, a standard Flutter `Text` widget is used to show the formatted string, applying a large text style to make it prominent on the screen.\n\nSo, the `TimerText` widget is like the display screen of our timer. It passively watches the timer's brain ([TimerBloc](05_timerbloc_.md)) and updates itself every time the brain says the time has changed.\n\n### The Flow: State Changes -> Text Changes\n\nHere's a simple diagram showing how state changes in the [TimerBloc](05_timerbloc_.md) cause the `TimerText` widget to update the time display:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (for the tick)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions)\n    TimerBloc-->Ticker: Start ticking\n    loop Every second\n        Ticker-->TimerBloc: Tick! Duration -= 1 second\n        TimerBloc->TimerBloc: Changes State (duration updates)\n        TimerBloc-->TimerText: Notifies of new state (with updated duration)\n        TimerText->TimerText: Rebuilds widget\n        TimerText-->User: Shows updated time on screen\n    end\n```\n\nThis diagram shows that the `TimerText` widget doesn't cause any changes itself. It just listens to the [TimerBloc](05_timerbloc_.md) and updates its display whenever the `duration` value within the [TimerBloc](05_timerbloc_.md)'s state changes. This happens frequently when the timer is running.\n\nYou can see the full, very short code for the `TimerText` widget in the provided `lib/timer/view/timer_page.dart` file.\n\n### Conclusion\n\nThe `TimerText` widget is a simple but crucial part of our timer app's user interface. Its sole responsibility is to display the time that it receives from the [TimerBloc](05_timerbloc_.md) in a user-friendly \"minutes:seconds\" format. By using `context.select`, it efficiently listens only for changes in the duration without needing to know anything else about the timer's internal workings.\n\nWe've now covered the main visual components of our timer: the overall screen (`TimerPage`/`TimerView`), the control buttons (`Actions`), and the time display (`TimerText`). But how does the timer actually *count* downwards and manage its state? That's where the core logic comes in, driven by Timer Events, States, and the Bloc itself.\n\nIn the next chapter, we'll introduce the concept of [TimerEvent](04_timerevent_.md), which are the messages our UI sends to the [TimerBloc](05_timerbloc_.md) to tell it what to do.\n\n[Next Chapter: TimerEvent](04_timerevent_.md)\n---\n# Chapter 4: TimerEvent\n\nWelcome back, future Flutter developer! In the last few chapters, we looked at what our timer app looks like ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons you press ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and where the time is shown ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)).\n\nBut how do the buttons (`Actions`) actually *tell* the timer to do something, like start counting, pause, or reset? They can't directly change the timer's internal working because that logic lives in the \"brain,\" the [TimerBloc](05_timerbloc_.md).\n\nThis is where `TimerEvent` comes in!\n\n### What is a TimerEvent? Sending Commands to the Brain\n\nThink of the [TimerBloc](05_timerbloc_.md) as a military commander who needs instructions. You, the user, are giving these instructions by tapping buttons on the screen. A `TimerEvent` is like sending a specific **command** to the commander ([TimerBloc](05_timerbloc_.md)).\n\nWhen you tap the \"Start\" button, the `Actions` widget doesn't just say \"Start!\". It sends a structured message, a `TimerStarted` event, to the [TimerBloc](05_timerbloc_.md). When you tap \"Pause\", it sends a `TimerPaused` event, and so on.\n\nThe [TimerBloc](05_timerbloc_.md) is constantly listening for these `TimerEvent` commands. When it receives one, it processes the command and updates the timer's state (like changing from \"paused\" to \"running\").\n\n### The Different Commands (TimerEvents)\n\nIn our timer app, we have a few main commands you can send. Each command is represented by a different type of `TimerEvent`:\n\n*   `TimerStarted`: \"Commander! Start counting down the timer!\" This event usually includes how long the timer should start with.\n*   `TimerPaused`: \"Commander! Stop counting for now, but remember the current time!\"\n*   `TimerResumed`: \"Commander! Okay, you can continue counting down from where you left off!\"\n*   `TimerReset`: \"Commander! Forget everything and set the timer back to its initial time!\"\n*   `_TimerTicked`: This is a special *internal* event. It's like the second hand on a clock ticking. The brain ([TimerBloc](05_timerbloc_.md)) sends this event to *itself* every second to remind itself to decrease the duration. You, the user, don't send this one!\n\nThese events are defined in a file called `timer_event.dart`.\n\n```dart\n// Inside lib/timer/bloc/timer_event.dart\n\npart of 'timer_bloc.dart'; // This connects it to the TimerBloc file\n\nsealed class TimerEvent {\n  const TimerEvent(); // All timer events share this base\n}\n\nfinal class TimerStarted extends TimerEvent {\n  const TimerStarted({required this.duration}); // Tells the bloc the starting duration\n  final int duration;\n}\n\nfinal class TimerPaused extends TimerEvent {\n  const TimerPaused(); // No extra info needed\n}\n\nfinal class TimerResumed extends TimerEvent {\n  const TimerResumed(); // No extra info needed\n}\n\nclass TimerReset extends TimerEvent {\n  const TimerReset(); // No extra info needed\n}\n\nclass _TimerTicked extends TimerEvent { // Notice the underscore - it's private!\n  const _TimerTicked({required this.duration}); // Tells the bloc the new duration\n  final int duration;\n}\n```\n\nLet's look at this simple code:\n\n*   `sealed class TimerEvent`: This is the base for all our commands. Think of it as the category \"Timer Commands\". `sealed` means all the *specific* commands must be defined in the same file.\n*   `final class ... extends TimerEvent`: Each specific command (`TimerStarted`, `TimerPaused`, etc.) is defined as a `class` that \"extends\" `TimerEvent`. This means they *are* a type of `TimerEvent`.\n*   `TimerStarted` needs a `duration` because when you start a timer, you need to know how long it should run.\n*   `_TimerTicked` also needs a `duration` because it reports the new time every second. The underscore `_` at the beginning means this event is only used *inside* the `timer_bloc.dart` file and is not sent from the UI.\n\n### Sending Events from Actions (Widget)\n\nNow let's see how the `Actions` widget uses these events. Remember from [Chapter 2: Actions (Widget)](02_actions__widget_.md) that when you tap a button, the `onPressed` function runs:\n\n```dart\n// Simplified snippet from Actions widget\n// ...\nonPressed: () {\n  // This line gets the TimerBloc instance\n  context.read<TimerBloc>()\n      // This line ADDS the event to the bloc!\n      .add(const TimerPaused()); // Or TimerStarted, TimerResumed, TimerReset\n},\n// ...\n```\n\nThis is the crucial connection! `context.read<TimerBloc>()` finds the [TimerBloc](05_timerbloc_.md) that was provided higher up in the widget tree ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)). Then, `.add(...)` sends the specific `TimerEvent` command to that [TimerBloc](05_bloc_.md).\n\nIt's like pointing at the commander and saying, \"Commander! Execute the 'Pause Timer' command!\"\n\n### How the TimerBloc Responds to Events\n\nThe [TimerBloc](05_timerbloc_.md) has special instructions for what to do when it receives each type of `TimerEvent`.\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart constructor\nTimerBloc(...) : ... {\n  on<TimerStarted>(_onStarted); // When TimerStarted arrives, call _onStarted method\n  on<TimerPaused>(_onPaused);   // When TimerPaused arrives, call _onPaused method\n  on<TimerResumed>(_onResumed); // When TimerResumed arrives, call _onResumed method\n  on<TimerReset>(_onReset);     // When TimerReset arrives, call _onReset method\n  on<_TimerTicked>(_onTicked);   // When _TimerTicked arrives, call _onTicked method\n}\n```\n\nThe `on<EventType>(methodName)` lines tell the [TimerBloc](05_timerbloc_.md): \"Whenever you receive a `EventType` event, run the code inside the `methodName` function.\" These methods (`_onStarted`, `_onPaused`, etc.) are where the actual timer logic happens (we'll explore this more in [Chapter 5: TimerBloc](05_timerbloc_.md)).\n\nWhen a `TimerEvent` is received, the corresponding method is called. Inside that method, the [TimerBloc](05_timerbloc_.md) will perform the necessary actions (like starting a tick timer, pausing it) and crucially, **emit** a new [TimerState](06_timerstate_.md) to describe the timer's *new* condition.\n\n### The Flow: User -> Event -> Bloc -> State -> UI\n\nHere's a simplified picture of how a user action (like tapping \"Start\") flows through our system using a `TimerEvent`:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions Widget\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant TimerText as TimerText Widget\n\n    User->Actions: Taps \"Start\" Button\n    Actions->TimerEvent: Creates TimerStarted Event\n    Actions->TimerBloc: Adds TimerStarted Event\n    TimerBloc->TimerBloc: Processes TimerStarted Event (e.g., starts counting)\n    TimerBloc->TimerState: Creates New TimerState (e.g., TimerRunInProgress)\n    TimerBloc-->TimerBloc: Emits New TimerState\n    TimerBloc-->Actions: Notifies of New State (Actions may rebuild)\n    TimerBloc-->TimerText: Notifies of New State (TimerText rebuilds if duration changed)\n    TimerText-->User: Shows updated time (\"02:59\")\n```\n\nIn this flow:\n\n1.  You tap a button in the `Actions` widget.\n2.  The `Actions` widget creates the correct `TimerEvent` (the command).\n3.  The `Actions` widget sends (adds) this event to the `TimerBloc`.\n4.  The `TimerBloc` receives and processes the event according to its rules (the `on` handlers).\n5.  Based on the event, the `TimerBloc` decides what the new condition of the timer should be and creates a new `TimerState`.\n6.  The `TimerBloc` broadcasts (\"emits\") this new `TimerState`.\n7.  Widgets like `Actions` and `TimerText` are listening to the `TimerBloc`. When they hear about a new state, they update themselves accordingly (e.g., `Actions` shows different buttons, `TimerText` shows the new duration).\n\n### Conclusion\n\n`TimerEvent`s are the way our user interface (specifically the `Actions` widget) communicates with the core logic \"brain,\" the [TimerBloc](05_timerbloc_.md). They represent the *intent* of the user \u2013 what they want the timer to *do*. By sending these clear, structured commands, we keep the UI simple (it just sends messages) and the logic centralized in the [TimerBloc](05_timerbloc_.md), which knows how to act upon these commands.\n\nWe now understand how the UI sends commands. Next, we'll dive deep into the [TimerBloc](05_timerbloc_.md) itself to see how it receives these events and uses them to manage the timer's duration and state.\n\n[Next Chapter: TimerBloc](05_timerbloc_.md)\n---\n# Chapter 5: TimerBloc\n\nAlright, welcome back! In our previous chapters, we built the look and feel of our timer: the main screen ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), the buttons ([Chapter 2: Actions (Widget)](02_actions__widget_.md)), and the time display ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)). We also learned about [TimerEvent](04_timerevent_.md)s ([Chapter 4: TimerEvent](04_timerevent_.md)), which are the \"commands\" our buttons send to the timer.\n\nNow, it's time to meet the **brain** of our timer app: the `TimerBloc`. This is where all the important decisions are made and where the timer actually counts down.\n\n### What is the TimerBloc? The Brain of the Timer\n\nImagine the `TimerBloc` is the central control room for our timer. It holds all the important information:\n\n*   How much time is currently left?\n*   Is the timer running, paused, or finished?\n\nAnd it knows how to react to the commands ([TimerEvent](04_timerevent_.md)s) sent its way:\n\n*   When it gets a \"Start\" command, it starts counting down.\n*   When it gets a \"Pause\" command, it stops counting.\n*   When it gets a \"Reset\" command, it sets the time back to the beginning.\n*   When it gets a \"_TimerTicked\" event (its internal reminder), it subtracts one second from the time.\n\nThe `TimerBloc` works with a special helper called a [Ticker](07_ticker_.md) to actually count the seconds. We'll learn more about the [Ticker](07_ticker_.md) in a later chapter, but for now, think of it as the stopwatch that the `TimerBloc` tells to start and stop.\n\nThe `TimerBloc` is built using a powerful pattern called **Bloc** (Business Logic Component), which helps separate the user interface (what you see) from the business logic (how things work).\n\n### TimerBloc's Main Responsibilities\n\nThe `TimerBloc` has two main jobs:\n\n1.  **Manage the State:** It keeps track of the timer's current condition ([TimerState](06_timerstate_.md)). Is it just starting (`TimerInitial`)? Is it counting down (`TimerRunInProgress`)? Is it paused (`TimerRunPause`)? Has it finished (`TimerRunComplete`)? It holds the current `duration` (time left) as part of this state.\n2.  **Process Events:** It listens for [TimerEvent](04_timerevent_.md)s (the commands from the UI or from itself) and updates the state accordingly.\n\n### How TimerBloc Works: Receiving Events and Emitting States\n\nHere's the basic cycle of the `TimerBloc`:\n\n1.  The `TimerBloc` starts with an initial state, usually `TimerInitial` with a default duration (like 60 seconds).\n2.  It waits for an event.\n3.  Something happens that sends an event (like the user tapping a button, or the [Ticker](07_ticker_.md) \"ticking\").\n4.  The `TimerBloc` receives the event.\n5.  Based on the type of event and its current state, the `TimerBloc` decides what the new state should be.\n6.  The `TimerBloc` *emits* (sends out) this new state.\n7.  Widgets that are listening to the `TimerBloc` (like `TimerText` and `Actions`) receive the new state and update themselves to show the latest information.\n8.  Go back to step 2 and wait for the next event.\n\nLet's look at the core structure of the `TimerBloc` code:\n\n```dart\n// Inside lib/timer/bloc/timer_bloc.dart\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  // Constructor: this is where the bloc is created\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) { // Start with the initial state\n    // These are the handlers for each event type\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker; // Holds a reference to the Ticker helper\n  static const int _duration = 60; // The initial timer duration\n\n  StreamSubscription<int>? _tickerSubscription; // Manages the ticking\n\n  @override\n  Future<void> close() {\n    // Clean up the ticker when the bloc is closed\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  // Methods that handle specific events (explained below)\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) { ... }\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) { ... }\n  void _onResumed(TimerResumed event, Emitter<TimerState> emit) { ... }\n  void _onReset(TimerReset event, Emitter<TimerState> emit) { ... }\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) { ... }\n}\n```\n\nIn this code:\n\n*   `class TimerBloc extends Bloc<TimerEvent, TimerState>`: This declares our `TimerBloc`. It inherits powerful features from the `Bloc` class. The `<TimerEvent, TimerState>` tells the Bloc that it will receive `TimerEvent`s and manage `TimerState`s.\n*   `super(const TimerInitial(_duration))`: When the `TimerBloc` is created, this line tells it to start with the `TimerInitial` state, setting the initial duration to `_duration` (60 seconds).\n*   `on<EventType>(_onMethod)`: These lines are the event handlers. They connect each `TimerEvent` type (like `TimerStarted`) to a specific method (`_onStarted`) that contains the logic for handling that event. The `Emitter<TimerState> emit` parameter in the handler methods is crucial \u2013 it's used to **emit** new states.\n*   `_ticker`: This stores the [Ticker](07_ticker_.md) object, which helps us count down the seconds.\n*   `_tickerSubscription`: When the timer is running, the `Ticker` sends out a signal every second. This subscription is like the connection cable that receives those signals. We need to manage it to start and stop the ticking.\n*   `close()`: This method is called when the `TimerBloc` is no longer needed (like when the screen is closed). It's important to clean up the `_tickerSubscription` to prevent memory leaks.\n\n### Handling Specific Events (The Logic)\n\nNow let's briefly look at what happens inside the event handler methods (the `_on...` functions). Remember, their job is to take an event and emit a new state. The `emit` function is how the bloc tells the world its state has changed.\n\n#### 1. Handling `TimerStarted` (`_onStarted`)\n\nWhen the `TimerBloc` receives a `TimerStarted` event:\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  emit(TimerRunInProgress(event.duration)); // 1. Change state to Running\n  _tickerSubscription?.cancel();           // 2. Stop any previous ticking\n  _tickerSubscription = _ticker           // 3. Start a new ticker subscription\n      .tick(ticks: event.duration)\n      .listen((duration) => add(_TimerTicked(duration: duration))); // 4. For each tick, add a _TimerTicked event\n}\n```\n\n1.  `emit(TimerRunInProgress(event.duration))`: It immediately changes the state to `TimerRunInProgress`, setting the current duration to the one provided by the `TimerStarted` event.\n2.  `_tickerSubscription?.cancel()`: It stops any existing tick timer (in case you hit Start twice).\n3.  `_ticker.tick(ticks: event.duration)`: It tells the [Ticker](07_ticker_.md) to start ticking down from the specified `duration`.\n4.  `.listen(...) => add(_TimerTicked(duration: duration))`: This is important! For every \"tick\" the [Ticker](07_ticker_.md) sends, the `TimerBloc` receives the updated `duration` and internally sends (adds) a `_TimerTicked` event to *itself*.\n\n#### 2. Handling `_TimerTicked` (`_onTicked`)\n\nThis is the event that makes the timer count down. It's sent by the [Ticker](07_ticker_.md) (via the subscription).\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n  emit(\n    event.duration > 0\n        ? TimerRunInProgress(event.duration) // 1. If time left, stay Running\n        : const TimerRunComplete(),        // 2. If time is 0, change to Complete\n  );\n}\n```\n\n1.  `event.duration > 0 ? TimerRunInProgress(event.duration)`: If the new duration received from the [Ticker](07_ticker_.md) is greater than 0, the state is updated to `TimerRunInProgress` with the new duration. This causes the `TimerText` widget to update.\n2.  `: const TimerRunComplete()`: If the duration reaches 0, the state is changed to `TimerRunComplete`.\n\n#### 3. Handling `TimerPaused` (`_onPaused`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n  if (state is TimerRunInProgress) { // 1. Only pause if it's currently running\n    _tickerSubscription?.pause();   // 2. Tell the ticker to pause\n    emit(TimerRunPause(state.duration)); // 3. Change state to Paused\n  }\n}\n```\n\n1.  It first checks if the current state is `TimerRunInProgress`. You can only pause a running timer!\n2.  `_tickerSubscription?.pause()`: It tells the [Ticker](07_ticker_.md) to pause its counting.\n3.  `emit(TimerRunPause(state.duration))`: It changes the state to `TimerRunPause`, remembering the duration at which it was paused.\n\n#### 4. Handling `TimerResumed` (`_onResumed`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n  if (state is TimerRunPause) { // 1. Only resume if it's currently paused\n    _tickerSubscription?.resume(); // 2. Tell the ticker to resume\n    emit(TimerRunInProgress(state.duration)); // 3. Change state back to Running\n  }\n}\n```\n\n1.  It checks if the current state is `TimerRunPause`. You can only resume a paused timer!\n2.  `_tickerSubscription?.resume()`: It tells the [Ticker](07_ticker_.md) to continue counting.\n3.  `emit(TimerRunInProgress(state.duration))`: It changes the state back to `TimerRunInProgress`.\n\n#### 5. Handling `TimerReset` (`_onReset`)\n\n```dart\n// Inside TimerBloc (lib/timer/bloc/timer_bloc.dart)\nvoid _onReset(TimerReset event, Emitter<TimerState> emit) {\n  _tickerSubscription?.cancel(); // 1. Stop the ticker completely\n  emit(const TimerInitial(_duration)); // 2. Change state back to initial\n}\n```\n\n1.  `_tickerSubscription?.cancel()`: This stops the [Ticker](07_ticker_.md) from counting, no matter what it was doing (running or paused).\n2.  `emit(const TimerInitial(_duration))`: It sets the state back to `TimerInitial` with the original duration.\n\n### The Flow: Events In, States Out\n\nHere's a diagram showing how the `TimerBloc` acts as the central hub, receiving events and emitting states that affect the UI:\n\n```mermaid\nsequenceDiagram\n    participant UI as UI Widgets (Actions, TimerText)\n    participant TimerEvent as TimerEvent (Command)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant Ticker as Ticker (Counts Seconds)\n\n    UI->TimerEvent: User Action (e.g., Tap Start) creates Event\n    TimerEvent->TimerBloc: Event is added to the Bloc\n    TimerBloc->TimerBloc: Bloc processes Event based on its type (on methods)\n    opt TimerStarted / TimerResumed\n        TimerBloc->Ticker: Tell Ticker to start/resume\n        loop Every Second (while running)\n            Ticker-->TimerBloc: Send _TimerTicked Event to Bloc\n            TimerBloc->TimerBloc: Bloc processes _TimerTicked Event\n            TimerBloc->TimerState: Creates new TimerState (updated duration)\n            TimerBloc-->TimerBloc: Emits new TimerState\n        end\n    end\n    opt TimerPaused\n        TimerBloc->Ticker: Tell Ticker to pause\n        TimerBloc->TimerState: Creates new TimerState (Pause)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n        opt TimerReset\n        TimerBloc->Ticker: Tell Ticker to cancel\n        TimerBloc->TimerState: Creates new TimerState (Initial)\n        TimerBloc-->TimerBloc: Emits new TimerState\n    end\n\n    TimerBloc-->UI: New TimerState is received by listeners (BlocBuilder, select)\n    UI->UI: UI updates its display (buttons, time text) based on the new state\n```\n\nThis diagram shows that the `TimerBloc` sits in the middle, reacting to events and producing states. The [Ticker](07_ticker_.md) is a dependency that helps the `TimerBloc` execute the \"start\" and \"tick\" logic.\n\n### Conclusion\n\nThe `TimerBloc` is the core logic handler for our timer application. It receives `TimerEvent` commands, uses a [Ticker](07_ticker_.md) to manage the countdown, and updates its internal `TimerState` which it then emits for the UI to react to. By separating this logic into the `TimerBloc`, our UI widgets remain simple and focused on just displaying information and sending events. This makes our app organized and easier to manage.\n\nWe've seen how the `TimerBloc` *manages* the state by changing it. In the next chapter, we'll take a closer look at what the `TimerState` itself is and the different conditions it can represent.\n\n[Next Chapter: TimerState](06_timerstate_.md)\n---\n# Chapter 6: TimerState\n\nWelcome back! In the last chapter, [Chapter 5: TimerBloc](05_timerbloc_.md), we learned about the brain of our timer application, the `TimerBloc`. We saw how it receives commands ([TimerEvent](04_timerevent_.md)s) and uses a [Ticker](07_ticker_.md) to count down.\n\nToday, we'll focus on something the `TimerBloc` *manages*: the `TimerState`. Think of the `TimerState` as the **status message** of our timer. It tells us, and importantly, it tells our UI widgets ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md), [Chapter 2: Actions (Widget)](02_actions__widget_.md), [Chapter 3: TimerText (Widget)](03_timertext__widget_.md)), exactly what the timer is doing right now.\n\n### What is TimerState? The Timer's Current Status\n\nImagine your phone when you're using a timer app. You see the time counting down, and the buttons change. The app knows whether it's \"Running\", \"Paused\", or if it has \"Finished\". This current condition is the timer's `State`.\n\nThe `TimerState` in our app serves this exact purpose. It's a piece of data that describes:\n\n1.  **What is the timer currently doing?** (Is it waiting, running, paused, or finished?)\n2.  **What is the current duration (time left)?**\n\nEvery time something important happens with the timer (like starting, pausing, or a second ticking by), the `TimerBloc` calculates the *new* status and creates a new `TimerState` to represent it. It then \"emits\" this new state so that interested parts of the app (like the widgets) can react.\n\n### The Different Statuses (TimerStates)\n\nOur timer can be in four main situations, and each is represented by a different type of `TimerState`. These are defined in the `timer_state.dart` file:\n\n```dart\n// Inside lib/timer/bloc/timer_state.dart\n\npart of 'timer_bloc.dart'; // Connects it to the TimerBloc file\n\nsealed class TimerState extends Equatable { // Base for all statuses\n  const TimerState(this.duration); // All states know the current duration\n  final int duration; // The time left in seconds\n\n  @override\n  List<Object> get props => [duration]; // Helps Bloc know when the state *really* changed\n}\n\nfinal class TimerInitial extends TimerState { // 1. Waiting to start\n  const TimerInitial(super.duration);\n  // ... formatting for printing the state ...\n}\n\nfinal class TimerRunPause extends TimerState { // 2. Temporarily stopped\n  const TimerRunPause(super.duration);\n    // ... formatting ...\n}\n\nfinal class TimerRunInProgress extends TimerState { // 3. Actively counting down\n  const TimerRunInProgress(super.duration);\n    // ... formatting ...\n}\n\nfinal class TimerRunComplete extends TimerState { // 4. Reached zero\n  const TimerRunComplete() : super(0); // Duration is 0 when complete\n    // ... formatting ...\n}\n```\n\nLet's break down these statuses:\n\n1.  **`TimerInitial`**: This is the very first state when the timer starts. It's like taking a fresh timer out of the box. It knows the *starting* duration, but it's not counting down yet.\n2.  **`TimerRunPause`**: The timer was counting down but is now temporarily stopped. It remembers how much time was left when it was paused.\n3.  **`TimerRunInProgress`**: The timer is actively counting down, second by second. This state holds the current duration remaining.\n4.  **`TimerRunComplete`**: The timer has successfully reached zero seconds!\n\nNotice that *all* these states inherit from a base `TimerState` class and *all* of them have a `duration` property. This is important because both our `TimerText` ([Chapter 3: TimerText (Widget)](03_timertext__widget_.md)) and `Actions` ([Chapter 2: Actions (Widget)](02_actions__widget_.md)) widgets need access to the current duration and the state type.\n\n*   `sealed class TimerState`: Like `TimerEvent`, this means all the distinct state types are defined in this one file.\n*   `const TimerState(this.duration)`: This constructor in the base class ensures that every state *must* have a duration associated with it.\n*   `final class ... extends TimerState`: Each specific state is a class inheriting from `TimerState`.\n*   `TimerRunComplete() : super(0)`: The `TimerRunComplete` state always sets its duration to 0, since the countdown is finished.\n\n### How Widgets Use TimerState\n\nOur UI widgets don't *change* the `TimerState`; they *listen* to the `TimerBloc` and read the current `TimerState` to know what to show.\n\n#### TimerText and TimerState\n\nThe `TimerText` widget only cares about one thing from the state: the `duration`.\n\n```dart\n// Inside TimerText widget (lib/timer/view/timer_page.dart)\n@override\nWidget build(BuildContext context) {\n  // This line reads the 'duration' property from the current TimerBloc state\n  final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n\n  // ... rest of the code formats and displays the duration ...\n  return Text('$minutesStr:$secondsStr', ...);\n}\n```\n\nAs we saw in [Chapter 3: TimerText (Widget)](03_timertext__widget_.md), `context.select` is used to specifically listen for changes to `bloc.state.duration`. Whenever the `TimerBloc` emits a new state *and* that new state's `duration` is different, the `TimerText` widget rebuilds itself to show the updated time. It doesn't need to know *which type* of state it is (Initial, InProgress, etc.), just the duration.\n\n#### Actions (Widget) and TimerState\n\nThe `Actions` widget, on the other hand, cares about *both* the type of state *and* sometimes the duration (for the initial \"Start\" button).\n\n```dart\n// Inside Actions widget (lib/timer/view/timer_page.dart)\n@override\nWidget build(BuildContext context) {\n  return BlocBuilder<TimerBloc, TimerState>(\n    buildWhen: (prev, state) => prev.runtimeType != state.runtimeType, // Rebuild mainly when state TYPE changes\n    builder: (context, state) {\n      return Row(\n        children: [\n          ...switch (state) { // The 'switch' checks the state's TYPE\n            TimerInitial() => [\n              // Show Start button\n              FloatingActionButton(\n                onPressed: () => context\n                    .read<TimerBloc>()\n                    .add(TimerStarted(duration: state.duration)), // Uses initial duration\n                child: const Icon(Icons.play_arrow),\n              ),\n            ],\n            TimerRunInProgress() => [\n              // Show Pause and Reset buttons\n              // ...\n            ],\n            TimerRunPause() => [\n              // Show Play and Reset buttons\n              // ...\n            ],\n            TimerRunComplete() => [\n              // Show Reset button\n              // ...\n            ]\n          },\n        ],\n      );\n    },\n  );\n}\n```\n\nAs discussed in [Chapter 2: Actions (Widget)](02_actions__widget_.md), the `BlocBuilder` provides the current `state` object. The `switch (state)` statement looks at the specific *type* of `TimerState` (e.g., `TimerInitial`, `TimerRunInProgress`) and then displays the corresponding buttons. When in the `TimerInitial` state, it accesses `state.duration` to know the starting value to send in the `TimerStarted` event.\n\nThis is a powerful concept: the UI widgets are \"reactive\". They simply update themselves whenever the *state* of the underlying logic (`TimerBloc`) changes. They don't need to contain complex logic about *when* to change buttons; the `TimerBloc` updates the state, and the `Actions` widget automatically displays the correct buttons for that state.\n\n### How the TimerBloc Changes TimerState\n\nThe `TimerBloc` is the *only* part of our app that is allowed to create and \"emit\" new `TimerState` objects. This happens inside the event handler methods we saw in [Chapter 5: TimerBloc](05_timerbloc_.md). Each handler (`_onStarted`, `_onTicked`, etc.) uses the `emit` function to broadcast the new status.\n\n```dart\n// Inside TimerBloc's _onStarted method (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  // ... before emitting ...\n  emit(TimerRunInProgress(event.duration)); // <-- Creating and emitting a new TimerRunInProgress state\n  // ... after emitting ...\n}\n\n// Inside TimerBloc's _onTicked method (lib/timer/bloc/timer_bloc.dart)\nvoid _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n  emit(\n    // Creating and emitting either TimerRunInProgress or TimerRunComplete\n    event.duration > 0\n        ? TimerRunInProgress(event.duration)\n        : const TimerRunComplete(),\n  );\n}\n\n// Inside TimerBloc's _onPaused method (lib/timer/bloc/timer_bloc.dart)\nvoid _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n  if (state is TimerRunInProgress) {\n    // ... before emitting ...\n    emit(TimerRunPause(state.duration)); // <-- Creating and emitting a new TimerRunPause state\n  }\n}\n\n// And so on for _onResumed and _onReset...\n```\n\nThe `TimerBloc`'s responsibility is to calculate the *next* appropriate state after processing an event and then emit that new state.\n\n### The Flow: Bloc Changes State -> UI Reacts to State\n\nHere's a sequence showing how the `TimerBloc` changing the `TimerState` impacts the UI:\n\n```mermaid\nsequenceDiagram\n    participant Ticker as Ticker (Counts Seconds)\n    participant TimerBloc as TimerBloc (Brain)\n    participant TimerState as TimerState (New Condition)\n    participant Actions as Actions Widget\n    participant TimerText as TimerText Widget\n    participant User\n\n    User->TimerBloc: Starts timer (via Actions & TimerStarted event)\n    TimerBloc->Ticker: Start Ticking\n    loop Every Second (while running)\n        Ticker-->TimerBloc: Send _TimerTicked Event\n        TimerBloc->TimerBloc: Processes _TimerTicked (duration - 1)\n        alt If duration > 0\n            TimerBloc->TimerState: Creates new TimerRunInProgress state (updated duration)\n        else If duration == 0\n             TimerBloc->TimerState: Creates new TimerRunComplete state (duration 0)\n         end\n        TimerBloc-->TimerBloc: Emits New TimerState\n        TimerBloc-->Actions: Notifies Actions of New State\n        Actions->Actions: Actions checks state type, remains TimerRunInProgress\n        TimerBloc-->TimerText: Notifies TimerText of New State\n        TimerText->TimerText: TimerText checks state duration\n        alt If state duration changed\n            TimerText->TimerText: Rebuilds with new duration\n            TimerText-->User: Shows updated time\n        end\n        opt If TimerRunComplete\n             TimerBloc-->Actions: Notifies Actions of New State\n             Actions->Actions: Actions checks state type, sees TimerRunComplete\n             Actions->Actions: Rebuilds to show only Reset button\n             Actions-->User: Buttons change\n         end\n    end\n```\n\nThis shows that the `TimerState` emitted by the `TimerBloc` is the trigger for the UI to update. The `Actions` widget reacts primarily to the *type* of state, while the `TimerText` widget reacts primarily to the `duration` within the state.\n\n### Conclusion\n\n`TimerState` represents the different life stages or conditions of our timer (Initial, Running, Paused, Complete). It holds not just the status but also the crucial piece of information: the current duration. The `TimerBloc` is responsible for managing and emitting these states, while our UI widgets listen to the `TimerBloc` and automatically update their appearance and behavior based on the current `TimerState`. This separation of concerns, powered by Bloc, makes our timer app's logic and UI easy to reason about.\n\nWe've now seen how the internal state is represented. In the next chapter, we'll look at the final piece of the puzzle: the [Ticker](07_ticker_.md), which is the simple component that actually performs the second-by-second countdown.\n\n[Next Chapter: Ticker](07_ticker_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: lib/ticker.dart ---\nclass Ticker {\n  const Ticker();\n  Stream<int> tick({required int ticks}) {\n    return Stream.periodic(const Duration(seconds: 1), (x) => ticks - x - 1)\n        .take(ticks);\n  }\n}\n\n\n--- File: lib/timer/view/timer_page.dart ---\nimport 'package:flutter/material.dart';\nimport 'package:flutter_bloc/flutter_bloc.dart';\nimport 'package:flutter_timer/ticker.dart';\nimport 'package:flutter_timer/timer/timer.dart';\n\nclass TimerPage extends StatelessWidget {\n  const TimerPage({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocProvider(\n      create: (_) => TimerBloc(ticker: const Ticker()),\n      child: const TimerView(),\n    );\n  }\n}\n\nclass TimerView extends StatelessWidget {\n  const TimerView({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return const Scaffold(\n      body: Stack(\n        children: [\n          Background(),\n          Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: <Widget>[\n              Padding(\n                padding: EdgeInsets.symmetric(vertical: 100),\n                child: Center(child: TimerText()),\n              ),\n              Actions(),\n            ],\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass TimerText extends StatelessWidget {\n  const TimerText({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final duration = context.select((TimerBloc bloc) => bloc.state.duration);\n    final minutesStr =\n        ((duration / 60) % 60).floor().toString().padLeft(2, '0');\n    final secondsStr = (duration % 60).toString().padLeft(2, '0');\n    return Text(\n      '$minutesStr:$secondsStr',\n      style: Theme.of(context)\n          .textTheme\n          .displayLarge\n          ?.copyWith(fontWeight: FontWeight.w500),\n    );\n  }\n}\n\nclass Actions extends StatelessWidget {\n  const Actions({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return BlocBuilder<TimerBloc, TimerState>(\n      buildWhen: (prev, state) => prev.runtimeType != state.runtimeType,\n      builder: (context, state) {\n        return Row(\n          mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n          children: [\n            ...switch (state) {\n              TimerInitial() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () => context\n                        .read<TimerBloc>()\n                        .add(TimerStarted(duration: state.duration)),\n                  ),\n                ],\n              TimerRunInProgress() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.pause),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerPaused());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunPause() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.play_arrow),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerResumed());\n                    },\n                  ),\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ],\n              TimerRunComplete() => [\n                  FloatingActionButton(\n                    child: const Icon(Icons.replay),\n                    onPressed: () {\n                      context.read<TimerBloc>().add(const TimerReset());\n                    },\n                  ),\n                ]\n            },\n          ],\n        );\n      },\n    );\n  }\n}\n\nclass Background extends StatelessWidget {\n  const Background({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox.expand(\n      child: DecoratedBox(\n        decoration: BoxDecoration(\n          gradient: LinearGradient(\n            begin: Alignment.topCenter,\n            end: Alignment.bottomCenter,\n            colors: [\n              Colors.blue.shade50,\n              Colors.blue.shade500,\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n\n--- File: lib/timer/bloc/timer_bloc.dart ---\nimport 'dart:async';\n\nimport 'package:bloc/bloc.dart';\nimport 'package:equatable/equatable.dart';\nimport 'package:flutter_timer/ticker.dart';\n\npart 'timer_event.dart';\npart 'timer_state.dart';\n\nclass TimerBloc extends Bloc<TimerEvent, TimerState> {\n  TimerBloc({required Ticker ticker})\n      : _ticker = ticker,\n        super(const TimerInitial(_duration)) {\n    on<TimerStarted>(_onStarted);\n    on<TimerPaused>(_onPaused);\n    on<TimerResumed>(_onResumed);\n    on<TimerReset>(_onReset);\n    on<_TimerTicked>(_onTicked);\n  }\n\n  final Ticker _ticker;\n  static const int _duration = 60;\n\n  StreamSubscription<int>? _tickerSubscription;\n\n  @override\n  Future<void> close() {\n    _tickerSubscription?.cancel();\n    return super.close();\n  }\n\n  void _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n    emit(TimerRunInProgress(event.duration));\n    _tickerSubscription?.cancel();\n    _tickerSubscription = _ticker\n        .tick(ticks: event.duration)\n        .listen((duration) => add(_TimerTicked(duration: duration)));\n  }\n\n  void _onPaused(TimerPaused event, Emitter<TimerState> emit) {\n    if (state is TimerRunInProgress) {\n      _tickerSubscription?.pause();\n      emit(TimerRunPause(state.duration));\n    }\n  }\n\n  void _onResumed(TimerResumed resume, Emitter<TimerState> emit) {\n    if (state is TimerRunPause) {\n      _tickerSubscription?.resume();\n      emit(TimerRunInProgress(state.duration));\n    }\n  }\n\n  void _onReset(TimerReset event, Emitter<TimerState> emit) {\n    _tickerSubscription?.cancel();\n    emit(const TimerInitial(_duration));\n  }\n\n  void _onTicked(_TimerTicked event, Emitter<TimerState> emit) {\n    emit(\n      event.duration > 0\n          ? TimerRunInProgress(event.duration)\n          : const TimerRunComplete(),\n    );\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7: Ticker\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7: Ticker\n\nWelcome back! We've reached the final piece of our timer puzzle. In the previous chapters, we built the user interface ([Chapter 1: TimerPage/TimerView](01_timerpage_timerview_.md)), added buttons that send commands ([Chapter 2: Actions (Widget)](02_actions__widget_.md) and [Chapter 4: TimerEvent](04_timerevent_.md)), and created the brain that manages the timer's status ([Chapter 5: TimerBloc](05_timerbloc_.md) and [Chapter 6: TimerState](06_timerstate_.md)).\n\nBut there's one last question: How does the `TimerBloc` actually know when a second has passed so it can count down? It needs a way to receive a signal, like a clock ticking, every second. This is where the `Ticker` comes in!\n\n### What is a Ticker? The Simple Clock\n\nImagine a old-school mechanical timer or even an old clock with a loud \"tick-tock\" sound. The `Ticker` in our app is very similar. It's a simple component whose only job is to **count down** and let whoever is listening know when each second has passed.\n\nIt doesn't know about buttons, states, or durations in the complex way the [TimerBloc](05_timerbloc_.md) does. You just tell the `Ticker` to start counting from a specific number, and it will \"tick\" for you every second until it reaches zero.\n\nThe `TimerBloc` is the one that tells the `Ticker` when to start and stop ticking. When the `Ticker` ticks, it sends a message back to the `TimerBloc`, which then updates the timer's state and duration.\n\n### How the Ticker Works\n\nThe `Ticker` provides a special kind of data stream called a `Stream`. Think of a `Stream` like a conveyor belt that carries items (in this case, numbers representing the remaining seconds) over time. The `Ticker` puts a new number on the conveyor belt every second.\n\nHere's what the `Ticker` code looks like:\n\n```dart\n// Inside lib/ticker.dart\n\nclass Ticker {\n  const Ticker(); // It doesn't need any special setup\n\n  // This method starts the ticking\n  Stream<int> tick({required int ticks}) {\n    // Creates a stream that sends a value every second\n    return Stream.periodic(const Duration(seconds: 1), (x) => ticks - x - 1)\n        // Only take 'ticks' number of values\n        .take(ticks);\n  }\n}\n```\n\nLet's break down the `tick` method:\n\n*   `Stream<int> tick({required int ticks})`: This method is called `tick`. It takes one input: `ticks`, which is the starting number of seconds to count down from. It returns a `Stream` which will give us `int` (whole number) values.\n*   `Stream.periodic(const Duration(seconds: 1), ...)`: This is powerful! It creates a `Stream` that automatically sends a new value *periodically* (over and over again). We tell it `const Duration(seconds: 1)`, which means \"send a value every 1 second\".\n*   `(x) => ticks - x - 1`: This is how the value sent each second is calculated.\n    *   `x` is a counter that starts at 0 for the first tick, then 1 for the second, 2 for the third, and so on.\n    *   `ticks - x - 1`: Let's say you start with `ticks: 10`.\n        *   After 1 second (`x` is 0): `10 - 0 - 1` = 9. (The first tick reports 9 seconds left).\n        *   After 2 seconds (`x` is 1): `10 - 1 - 1` = 8. (The second tick reports 8 seconds left).\n        *   ...and so on. This formula correctly gives us the *remaining* seconds each time.\n*   `.take(ticks)`: This tells the `Stream` to stop after it has sent `ticks` number of values. So, if you start with `ticks: 10`, it will send 10 values (9, 8, 7, ... 0) and then stop automatically.\n\nSo, when the `TimerBloc` calls `_ticker.tick(ticks: 60)`, the `Ticker` starts its internal clock and sends the numbers 59, 58, 57, ... all the way down to 0, once every second.\n\n### How the TimerBloc Uses the Ticker\n\nThe `TimerBloc` needs to **listen** to the `Stream` provided by the `Ticker`. When the `Ticker` sends a new number, the `TimerBloc` needs to receive it and do something with it.\n\nRemember this part of the `_onStarted` method in the `TimerBloc`?\n\n```dart\n// Inside TimerBloc's _onStarted method (lib/timer/bloc/timer_bloc.dart)\nvoid _onStarted(TimerStarted event, Emitter<TimerState> emit) {\n  emit(TimerRunInProgress(event.duration));\n  _tickerSubscription?.cancel(); // Cancel previous listener\n  _tickerSubscription = _ticker // Get the Ticker\n      .tick(ticks: event.duration) // Start the tick stream\n      .listen( // START LISTENING TO THE STREAM\n          (duration) => add(_TimerTicked(duration: duration)) // When a new duration arrives from the Ticker, send a _TimerTicked event to ourselves\n      );\n}\n```\n\nWhen the `TimerBloc` starts the timer (receives a `TimerStarted` event), it does two important things with the `Ticker`:\n\n1.  `_ticker.tick(ticks: event.duration)`: It tells the `_ticker` instance to start its countdown Stream, starting from the `duration` specified in the event.\n2.  `.listen(...)`: This is where the `TimerBloc` connects to the `Ticker`'s Stream. It's like plugging into the conveyor belt.\n3.  `(duration) => add(_TimerTicked(duration: duration))`: This is what happens *every time* the `Ticker` sends a new number (a new `duration`) on its Stream. The `TimerBloc` takes that new `duration` and immediately sends a `_TimerTicked` event (`add(...)`) to itself!\n\nSo, the `Ticker` doesn't directly update the state. It's a simple helper that provides the countdown numbers. The `TimerBloc` listens to these numbers and uses them to trigger its own internal `_TimerTicked` event, which then leads to the state being updated.\n\n### The Flow: Ticker to Bloc to State\n\nHere's how the `Ticker` fits into the overall flow:\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Actions as Actions W\n    participant TimerEvent as TimerEvent\n    participant TimerBloc as TimerBloc B\n    participant Ticker as Ticker\n    participant _TimerTicked as _TimerTicked E\n    participant TimerState as TimerState\n    participant TimerText as TimerText W\n\n    User->Actions: Tap Start Button\n    Actions->TimerEvent: Create TimerStarted Event\n    Actions->TimerBloc: Add TimerStarted Event\n    TimerBloc->TimerBloc: Process TimerStarted\n    TimerBloc->Ticker: Call tick(ticks: duration)\n    Ticker-->Ticker: Start internal countdown\n    loop Every Second\n        Ticker-->TimerBloc: Stream sends new duration\n        TimerBloc->_TimerTicked: Create _TimerTicked Event with new duration\n        TimerBloc->TimerBloc: Add _TimerTicked Event to itself\n        TimerBloc->TimerBloc: Process _TimerTicked Event (duration - 1)\n        alt If duration > 0\n            TimerBloc->TimerState: Create TimerRunInProgress state\n        else If duration == 0\n            TimerBloc->TimerState: Create TimerRunComplete state\n        end\n        TimerBloc-->TimerBloc: Emit New TimerState\n        TimerBloc-->TimerText: Notify TimerText of New State\n        TimerText->TimerText: Rebuilds with updated duration\n        TimerText-->User: Shows updated time\n    end\n```\n\nIn this diagram:\n\n1.  The user starts the timer via the UI (`Actions`).\n2.  This sends a `TimerStarted` event to the `TimerBloc`.\n3.  The `TimerBloc` receives the event and tells the `Ticker` to start ticking.\n4.  The `Ticker` counts down internally and sends a new number on its Stream *every second*.\n5.  The `TimerBloc` is *listening* to that Stream. When it receives a number, it creates and adds a `_TimerTicked` event to itself.\n6.  The `TimerBloc` processes the `_TimerTicked` event, decreases the duration in its state, and emits a new `TimerState`.\n7.  The `TimerText` widget sees the new `TimerState` (with the updated duration) and updates the display.\n\nThe `Ticker` is a very focused tool \u2013 it just provides the stream of numbers. The `TimerBloc` uses this stream as its timing mechanism to drive the state changes.\n\n### Conclusion\n\nThe `Ticker` is a simple but essential piece that provides the timing for our timer. It acts like a basic countdown clock, sending a new number every second via a `Stream`. The `TimerBloc` listens to this `Stream` and uses the incoming numbers (`duration`) to trigger internal events (`_TimerTicked`) which then lead to the `TimerBloc` updating and emitting new `TimerState`s. This layered approach, with the `Ticker` providing low-level timing, the `TimerBloc` managing logic and state, and the UI reacting to the state, is a core principle of building structured applications like this.\n\nWe have now explored all the main concepts in our `flutter_timer` project! You've learned how the different parts (Pages, Widgets, Events, States, Bloc, and Ticker) work together to create a functional and well-organized timer application.\n\nThis concludes the tutorial for the `flutter_timer` project. Great job completing it!"}