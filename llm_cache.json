{"\nFor the project `flutter`:\n\nCodebase Context:\n--- File Index 0: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\n\n\nAnalyze the codebase context.\nIdentify the top 5-10 core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n- 0 # packages/flutter/lib/src/widgets/routes.dart\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization\n  description: |\n    Another core concept, similar to a blueprint for objects.\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to 10 abstractions\n```": "```yaml\n- name: |\n    Route\n  description: |\n    Imagine a stack of playing cards, where each card represents a screen or page in your app. A `Route` is like a single card in this stack. It represents a distinct destination or screen that can be displayed by a navigator (`Navigator`). When you navigate to a new screen, a new `Route` is pushed onto the stack. When you go back, the current `Route` is popped off.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    OverlayRoute\n  description: |\n    Building on the playing card analogy, an `OverlayRoute` is like a special transparent card placed on top of the others. Instead of replacing the previous card, it lays a new layer on top, allowing you to see through it (or parts of it). This is used for things like dialogs or pop-up menus that don't take up the whole screen but still block interaction with what's underneath.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    TransitionRoute\n  description: |\n    A `TransitionRoute` adds visual flair when you swap those playing cards. It's like having animation effects when you add or remove a card from the stack. This abstraction handles how screens slide, fade, or otherwise transition into and out of view, making the navigation feel smoother and more engaging. It manages the animations for both the incoming and outgoing screens.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    ModalRoute\n  description: |\n    A `ModalRoute` is a specific type of `TransitionRoute` that creates a \"modal\" experience, like putting a semi-transparent sheet over your playing cards. This sheet, called a \"modal barrier,\" prevents you from interacting with the cards underneath. It's commonly used for dialogs, bottom sheets, and full-screen content that needs to block interaction with the previous screen.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    LocalHistoryRoute\n  description: |\n    A `LocalHistoryRoute` allows a single playing card (screen) to have its own mini-stack of interactions. Imagine being able to flip through a few different views *within* a single card before going back to the previous major card. This is useful for things like searching within a screen, where pressing back might hide the search results before returning to the previous full screen.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    PopEntry\n  description: |\n    A `PopEntry` is like a little sticker you can put on a playing card (`ModalRoute`). Each sticker can have two purposes: either prevent the card from being removed from the stack (blocking the \"pop\") or react when the card *is* removed. This is used by widgets like `PopScope` to control whether the user can truly leave a screen (e.g., if they have unsaved changes).\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    RouteObserver\n  description: |\n    Imagine a watchful person who keeps track of which playing cards are being added or removed from the stack. A `RouteObserver` does this for your app's navigation. You can register other parts of your app (like widgets that are \"RouteAware\") with the observer, and it will tell them when their corresponding screen is about to appear, disappear, or become the top card.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    RouteAware\n  description: |\n    A `RouteAware` is like a playing card that wants to know what's happening around it. When you register a `RouteAware` object with a `RouteObserver`, it gets notifications. These notifications tell the `RouteAware` object when its screen is becoming visible, is hidden by another screen, or is being removed from the navigation stack. This helps widgets react to navigation changes.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    PopupRoute\n  description: |\n    A `PopupRoute` is a specialized type of `ModalRoute` that's specifically designed for creating pop-up elements like dialogs. Think of it as a pre-configured transparent playing card that's ready to be placed on top of your stack to display a small, focused piece of content like an alert or a confirmation box.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n- name: |\n    PredictiveBackRoute\n  description: |\n    This abstraction is about adding a modern touch to how users go back. It's like making the back gesture on your playing card stack feel more interactive and visual. A `PredictiveBackRoute` handles the animations and logic for predictive back gestures, allowing the user to preview the previous screen as they swipe before fully committing to going back.\n  file_indices:\n    - 0 # packages/flutter/lib/src/widgets/routes.dart\n```", "\nBased on the following abstractions and relevant code snippets from the project `flutter`:\n\nList of Abstraction Indices and Names:\n0 # Route\n\n1 # OverlayRoute\n\n2 # TransitionRoute\n\n3 # ModalRoute\n\n4 # LocalHistoryRoute\n\n5 # PopEntry\n\n6 # RouteObserver\n\n7 # RouteAware\n\n8 # PopupRoute\n\n9 # PredictiveBackRoute\n\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\\n- Index 0: Route\n (Relevant file indices: [0])\\n  Description: Imagine a stack of playing cards, where each card represents a screen or page in your app. A `Route` is like a single card in this stack. It represents a distinct destination or screen that can be displayed by a navigator (`Navigator`). When you navigate to a new screen, a new `Route` is pushed onto the stack. When you go back, the current `Route` is popped off.\n\\n- Index 1: OverlayRoute\n (Relevant file indices: [0])\\n  Description: Building on the playing card analogy, an `OverlayRoute` is like a special transparent card placed on top of the others. Instead of replacing the previous card, it lays a new layer on top, allowing you to see through it (or parts of it). This is used for things like dialogs or pop-up menus that don't take up the whole screen but still block interaction with what's underneath.\n\\n- Index 2: TransitionRoute\n (Relevant file indices: [0])\\n  Description: A `TransitionRoute` adds visual flair when you swap those playing cards. It's like having animation effects when you add or remove a card from the stack. This abstraction handles how screens slide, fade, or otherwise transition into and out of view, making the navigation feel smoother and more engaging. It manages the animations for both the incoming and outgoing screens.\n\\n- Index 3: ModalRoute\n (Relevant file indices: [0])\\n  Description: A `ModalRoute` is a specific type of `TransitionRoute` that creates a \"modal\" experience, like putting a semi-transparent sheet over your playing cards. This sheet, called a \"modal barrier,\" prevents you from interacting with the cards underneath. It's commonly used for dialogs, bottom sheets, and full-screen content that needs to block interaction with the previous screen.\n\\n- Index 4: LocalHistoryRoute\n (Relevant file indices: [0])\\n  Description: A `LocalHistoryRoute` allows a single playing card (screen) to have its own mini-stack of interactions. Imagine being able to flip through a few different views *within* a single card before going back to the previous major card. This is useful for things like searching within a screen, where pressing back might hide the search results before returning to the previous full screen.\n\\n- Index 5: PopEntry\n (Relevant file indices: [0])\\n  Description: A `PopEntry` is like a little sticker you can put on a playing card (`ModalRoute`). Each sticker can have two purposes: either prevent the card from being removed from the stack (blocking the \"pop\") or react when the card *is* removed. This is used by widgets like `PopScope` to control whether the user can truly leave a screen (e.g., if they have unsaved changes).\n\\n- Index 6: RouteObserver\n (Relevant file indices: [0])\\n  Description: Imagine a watchful person who keeps track of which playing cards are being added or removed from the stack. A `RouteObserver` does this for your app's navigation. You can register other parts of your app (like widgets that are \"RouteAware\") with the observer, and it will tell them when their corresponding screen is about to appear, disappear, or become the top card.\n\\n- Index 7: RouteAware\n (Relevant file indices: [0])\\n  Description: A `RouteAware` is like a playing card that wants to know what's happening around it. When you register a `RouteAware` object with a `RouteObserver`, it gets notifications. These notifications tell the `RouteAware` object when its screen is becoming visible, is hidden by another screen, or is being removed from the navigation stack. This helps widgets react to navigation changes.\n\\n- Index 8: PopupRoute\n (Relevant file indices: [0])\\n  Description: A `PopupRoute` is a specialized type of `ModalRoute` that's specifically designed for creating pop-up elements like dialogs. Think of it as a pre-configured transparent playing card that's ready to be placed on top of your stack to display a small, focused piece of content like an alert or a confirmation box.\n\\n- Index 9: PredictiveBackRoute\n (Relevant file indices: [0])\\n  Description: This abstraction is about adding a modern touch to how users go back. It's like making the back gesture on your playing card stack feel more interactive and visual. A `PredictiveBackRoute` handles the animations and logic for predictive back gestures, allowing the user to preview the previous screen as they swipe before fully committing to going back.\n\\n\\nRelevant File Snippets (Referenced by Index and Path):\\n--- File: 0 # packages/flutter/lib/src/widgets/routes.dart ---\\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project.\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\"\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\"\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  This Flutter code defines how different **screens** (called *Routes*) are managed within an app using a **Navigator**.\n  It covers basic screen transitions, overlays for things like **dialogs**, handling back navigation, and notifying parts of the app\n  when their corresponding screen becomes visible or invisible using **observers** and **aware** objects.\nrelationships:\n  - from_abstraction: 1 # OverlayRoute\n    to_abstraction: 0 # Route\n    label: \"Is a type of\"\n  - from_abstraction: 2 # TransitionRoute\n    to_abstraction: 1 # OverlayRoute\n    label: \"Is a type of\"\n  - from_abstraction: 3 # ModalRoute\n    to_abstraction: 2 # TransitionRoute\n    label: \"Is a type of\"\n  - from_abstraction: 3 # ModalRoute\n    to_abstraction: 4 # LocalHistoryRoute\n    label: \"Mixes in\"\n  - from_abstraction: 3 # ModalRoute\n    to_abstraction: 5 # PopEntry\n    label: \"Registers\"\n  - from_abstraction: 8 # PopupRoute\n    to_abstraction: 3 # ModalRoute\n    label: \"Is a type of\"\n  - from_abstraction: 6 # RouteObserver\n    to_abstraction: 7 # RouteAware\n    label: \"Notifies subscribers\"\n  - from_abstraction: 6 # RouteObserver\n    to_abstraction: 0 # Route\n    label: \"Observes changes of\"\n  - from_abstraction: 2 # TransitionRoute\n    to_abstraction: 9 # PredictiveBackRoute\n    label: \"Implements\"\n```", "\nGiven the following project abstractions and their relationships for the project ```` flutter ````:\n\nAbstractions (Index # Name):\n- 0 # Route\n\n- 1 # OverlayRoute\n\n- 2 # TransitionRoute\n\n- 3 # ModalRoute\n\n- 4 # LocalHistoryRoute\n\n- 5 # PopEntry\n\n- 6 # RouteObserver\n\n- 7 # RouteAware\n\n- 8 # PopupRoute\n\n- 9 # PredictiveBackRoute\n\n\nContext about relationships and project summary:\nProject Summary:\nThis Flutter code defines how different **screens** (called *Routes*) are managed within an app using a **Navigator**.\nIt covers basic screen transitions, overlays for things like **dialogs**, handling back navigation, and notifying parts of the app\nwhen their corresponding screen becomes visible or invisible using **observers** and **aware** objects.\n\n\nRelationships (Indices refer to abstractions above):\n- From 1 (OverlayRoute\n) to 0 (Route\n): Is a type of\n- From 2 (TransitionRoute\n) to 1 (OverlayRoute\n): Is a type of\n- From 3 (ModalRoute\n) to 2 (TransitionRoute\n): Is a type of\n- From 3 (ModalRoute\n) to 4 (LocalHistoryRoute\n): Mixes in\n- From 3 (ModalRoute\n) to 5 (PopEntry\n): Registers\n- From 8 (PopupRoute\n) to 3 (ModalRoute\n): Is a type of\n- From 6 (RouteObserver\n) to 7 (RouteAware\n): Notifies subscribers\n- From 6 (RouteObserver\n) to 0 (Route\n): Observes changes of\n- From 2 (TransitionRoute\n) to 9 (PredictiveBackRoute\n): Implements\n\n\nIf you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 0 # Route\n- 2 # TransitionRoute\n- 1 # OverlayRoute\n- 3 # ModalRoute\n- 8 # PopupRoute\n- 9 # PredictiveBackRoute\n- 4 # LocalHistoryRoute\n- 5 # PopEntry\n- 7 # RouteAware\n- 6 # RouteObserver\n```", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Route\n\". This is Chapter 1.\n\nConcept Details:\n- Name: Route\n\n- Description:\nImagine a stack of playing cards, where each card represents a screen or page in your app. A `Route` is like a single card in this stack. It represents a distinct destination or screen that can be displayed by a navigator (`Navigator`). When you navigate to a new screen, a new `Route` is pushed onto the stack. When you go back, the current `Route` is popped off.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: Route\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"TransitionRoute\n\". This is Chapter 2.\n\nConcept Details:\n- Name: TransitionRoute\n\n- Description:\nA `TransitionRoute` adds visual flair when you swap those playing cards. It's like having animation effects when you add or remove a card from the stack. This abstraction handles how screens slide, fade, or otherwise transition into and out of view, making the navigation feel smoother and more engaging. It manages the animations for both the incoming and outgoing screens.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2: TransitionRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"OverlayRoute\n\". This is Chapter 3.\n\nConcept Details:\n- Name: OverlayRoute\n\n- Description:\nBuilding on the playing card analogy, an `OverlayRoute` is like a special transparent card placed on top of the others. Instead of replacing the previous card, it lays a new layer on top, allowing you to see through it (or parts of it). This is used for things like dialogs or pop-up menus that don't take up the whole screen but still block interaction with what's underneath.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3: OverlayRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"ModalRoute\n\". This is Chapter 4.\n\nConcept Details:\n- Name: ModalRoute\n\n- Description:\nA `ModalRoute` is a specific type of `TransitionRoute` that creates a \"modal\" experience, like putting a semi-transparent sheet over your playing cards. This sheet, called a \"modal barrier,\" prevents you from interacting with the cards underneath. It's commonly used for dialogs, bottom sheets, and full-screen content that needs to block interaction with the previous screen.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4: ModalRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"PopupRoute\n\". This is Chapter 5.\n\nConcept Details:\n- Name: PopupRoute\n\n- Description:\nA `PopupRoute` is a specialized type of `ModalRoute` that's specifically designed for creating pop-up elements like dialogs. Think of it as a pre-configured transparent playing card that's ready to be placed on top of your stack to display a small, focused piece of content like an alert or a confirmation box.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 5: PopupRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"PredictiveBackRoute\n\". This is Chapter 6.\n\nConcept Details:\n- Name: PredictiveBackRoute\n\n- Description:\nThis abstraction is about adding a modern touch to how users go back. It's like making the back gesture on your playing card stack feel more interactive and visual. A `PredictiveBackRoute` handles the animations and logic for predictive back gestures, allowing the user to preview the previous screen as they swipe before fully committing to going back.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n---\n# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 6: PredictiveBackRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 6: PredictiveBackRoute\n\nWelcome back! In our previous chapters, we've explored how Flutter uses [Route](01_route_.md)s like a stack of playing cards to manage screens, how [TransitionRoute](02_transitionroute_.md) adds animations to make screen changes smooth, and how [OverlayRoute](03_overlayroute_.md) and [ModalRoute](04_modalroute_.md) let us place content on top of existing screens, sometimes with a dimming barrier.\n\nToday, we\u2019re going to look at a concept called `PredictiveBackRoute`. This is a slightly more advanced topic, specifically related to how users interact with the \"back\" action on platforms like Android, where you can sometimes swipe from the edge of the screen to preview the previous screen *before* fully completing the back gesture.\n\n### What is a PredictiveBackRoute?\n\nImagine you're looking at a detailed picture in a gallery app on your phone. You know you want to go back to the list of pictures. On some operating systems (like recent Android versions), you can start a swipe gesture from the left or right edge of the screen. As you swipe, the current screen starts to shrink and move away, and you can see the previous screen (the list of pictures) peeking from behind! If you complete the swipe, you go back. If you let go halfway, the current screen snaps back into place.\n\nThis interactive, visual \"pull-to-go-back\" experience is what **Predictive Back** is all about. It gives the user a clearer idea of where they're going before they commit to the back action.\n\n`PredictiveBackRoute` is an abstraction in Flutter that helps routes participate in this predictive back gesture. It's like giving your animated playing cards a special edge that responds to a \"pulling\" motion, showing what's underneath before you actually lift the card off the stack.\n\nYou won't often create a `PredictiveBackRoute` directly because it's an `interface` (a contract for what a class *should* do). Instead, other route types like `TransitionRoute` (which includes `ModalRoute` like `MaterialPageRoute`) *implement* this interface, adding the necessary logic to respond to these predictive back gestures.\n\n### Why Use PredictiveBackRoute?\n\nImplementing predictive back requires coordination between the operating system's gesture detection and the route's animation. The OS tells the app that a back gesture is starting, how far along it is, if it's canceled, or if it's committed. The route needs to respond by animating its appearance accordingly.\n\nThe `PredictiveBackRoute` interface defines the standard methods that routes need to provide to handle these events. By having routes implement this interface, the Flutter framework (specifically, the [Navigator](03_overlayroute_.md) or underlying low-level gesture handlers) knows how to communicate with the route during a predictive back gesture.\n\nThis makes integrating with native predictive back much cleaner. The route, by implementing `PredictiveBackRoute`, declares that it *knows how* to handle such gestures, and the framework uses the defined methods to control its animation during the gesture.\n\n### Key Concepts of PredictiveBackRoute\n\nSince `PredictiveBackRoute` is an interface, its main \"concepts\" are the methods it requires implementing classes to have:\n\n*   **`handleStartBackGesture({double progress})`:** Called when a predictive back gesture *begins*. The `progress` tells the route how much the user has already swiped (0.0 is the start, 1.0 is fully back).\n*   **`handleUpdateBackGestureProgress({required double progress})`:** Called repeatedly as the user *drags* the swipe gesture. The `progress` updates continuously from near 0.0 up to 1.0. This is where the route should update its transition animation based on the user's finger movement.\n*   **`handleCancelBackGesture()`:** Called if the user *releases* the gesture *before* reaching the commit threshold (usually before reaching the edge). The route should animate back to its fully visible state.\n*   **`handleCommitBackGesture()`:** Called if the user *completes* the gesture (swipes all the way or past a certain point). The route should finish its exit animation and be popped from the navigator.\n*   **`popGestureEnabled`:** A getter that indicates whether the route *can* currently be dismissed by a pop gesture (like predictive back). This helps the framework decide if it should even start sending gesture events to this route.\n\nRoutes that implement `PredictiveBackRoute` use these methods to control their existing animation controllers (like the one inherited from [TransitionRoute](02_transitionroute_.md)).\n\n### How PredictiveBackRoute Works (Simplified)\n\nLet's trace what happens conceptually when a user performs a predictive back gesture on a screen represented by a route that implements `PredictiveBackRoute` (like a `MaterialPageRoute`).\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant FlutterEngine as Flutter Engine\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (PredictiveBackRoute)\n\n    User->>OS: Starts swipe from edge\n    OS->>FlutterEngine: Notifies gesture started\n    FlutterEngine->>Navigator: Notifies back gesture started (PredictiveBackEvent)\n    Navigator->>CurrentRoute: Calls handleStartBackGesture({progress: 0.0})\n    CurrentRoute-->>Navigator: Route starts responding to gesture\n\n    loop User swipes further\n        User->>OS: Drags finger\n        OS->>FlutterEngine: Notifies progress update (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes progress to Navigator\n        Navigator->>CurrentRoute: Calls handleUpdateBackGestureProgress({progress: ...})\n        CurrentRoute-->>Navigator: Route updates animation based on progress\n    end\n\n    alt User lets go (cancel)\n        User->>OS: Stops swiping before threshold\n        OS->>FlutterEngine: Notifies gesture canceled (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes cancel to Navigator\n        Navigator->>CurrentRoute: Calls handleCancelBackGesture()\n        CurrentRoute-->>Navigator: Route animates back to full visibility\n        Navigator-->>User: Screen returns to original state\n    else User swipes fully (commit)\n        User->>OS: Completes swipe\n        OS->>FlutterEngine: Notifies gesture completed (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes commit to Navigator\n        Navigator->>CurrentRoute: Calls handleCommitBackGesture()\n        CurrentRoute-->>Navigator: Route starts exit animation\n        Navigator->>Navigator: Pops CurrentRoute from stack\n        Navigator-->>User: Transition finishes, previous screen is shown\n    end\n```\n\nNotice how the operating system detects the gesture, passes information through the Flutter engine to the [Navigator](03_overlayroute_.md), and the [Navigator](03_overlayroute_.md) then uses the `PredictiveBackRoute` methods to tell the specific route how to animate.\n\n### Looking at the Code\n\nLet's look at the `PredictiveBackRoute` interface definition (it's part of the `TransitionRoute` code snippet you have, near the end). Remember, an interface just lists methods that a class *must* provide.\n\n```dart\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n```\n\nThis code snippet confirms the methods we discussed: `isCurrent` (useful to check if this is the route the user is trying to back from), `popGestureEnabled` (to check if the gesture is allowed), and the four `handle...BackGesture` methods for the different phases of the gesture.\n\nNow, let's look at how `TransitionRoute` (which `ModalRoute` extends) implements these methods. This logic is also in the provided snippet.\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other code ...\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress; // Set animation value to initial progress\n    navigator?.didStartUserGesture(); // Notify navigator a gesture started\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress; // Update animation value based on drag progress\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true); // Animate forward (back to original state)\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false); // Animate backward (complete pop)\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // Calculate animation duration based on current progress\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0, // Animate to fully forward (visible)\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop(); // Trigger the pop\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // If still animating, finish the pop animation\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0, // Animate back to fully dismissed\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    // Notify navigator the gesture stopped after delay if needed\n    if (_controller?.isAnimating ?? false) {\n       // ... animation status listener logic ...\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // ... more code ...\n\n  @override\n  bool get popGestureEnabled {\n    // ... checks if a pop gesture is currently allowed ...\n    // Checks things like: is this the first route? Is there a WillPopScope blocking?\n    // Is another gesture or animation already happening?\n    return true; // Simplified example - actual logic depends on many factors\n  }\n\n  // End PredictiveBackRoute.\n\n  // ... rest of TransitionRoute code ...\n}\n```\n\nIn this code (simplified):\n\n*   When the gesture starts (`handleStartBackGesture`), the route's internal animation controller (`_controller`) is set to the initial progress, and the [Navigator](03_overlayroute_.md) is notified a gesture is active.\n*   When the gesture updates (`handleUpdateBackGestureProgress`), the animation controller's value is directly set to the current gesture `progress`. This makes the transition animation track the user's finger!\n*   When the gesture ends (either `handleCancelBackGesture` or `handleCommitBackGesture`), the `_handleDragEnd` method is called.\n*   `_handleDragEnd` decides whether to animate the route back to fully visible (`animateForward: true`) or fully dismissed (`animateForward: false`).\n*   If completing the pop, it calls `navigator?.pop()`, which triggers the standard route popping process, and then finishes any remaining animation smoothly.\n*   `popGestureEnabled` contains logic to determine if this route is a candidate for a back gesture.\n\nThis implementation in `TransitionRoute` provides the generic plumbing for predictive back. Specific route types, like `MaterialPageRoute`, might use the `animation` value provided by the `_controller` (which is now being manipulated by the gesture handlers) within their `buildTransitions` method to create the actual visual effect of the previous screen peeking out or the current screen sliding away.\n\n### Example (Conceptual)\n\nYou don't typically *use* `PredictiveBackRoute` directly. You benefit from it when using routes that *implement* it.\n\nFor example, `MaterialPageRoute` implements `PredictiveBackRoute` (because it extends `ModalRoute` which extends `TransitionRoute`). When you use `Navigator.push(context, MaterialPageRoute(...))`, the resulting route automatically participates in Android's predictive back gesture because `MaterialPageRoute` provides the gesture handling logic inherited from `TransitionRoute`. You don't write any predictive back code yourself!\n\n```dart\n// You don't implement PredictiveBackRoute yourself for standard routes.\n// MaterialPageRoute already does this for you.\n\nNavigator.push(\n  context,\n  MaterialPageRoute(\n    builder: (context) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Detail Page')),\n        body: const Center(child: Text('Swipe from the edge to see predictive back!')),\n      );\n    },\n  ),\n);\n\n// Because MaterialPageRoute is (indirectly) a PredictiveBackRoute,\n// when a predictive back gesture starts on an Android device:\n// The framework calls handleStartBackGesture on the MaterialPageRoute instance.\n// As the user swipes, handleUpdateBackGestureProgress is called repeatedly.\n// The MaterialPageRoute's buildTransitions method (using the manipulated animation)\n// draws the predictive back effect (e.g., the page sliding away).\n// If the user cancels, handleCancelBackGesture is called.\n// If the user commits, handleCommitBackGesture is called, triggering a pop.\n```\n\nThis is the power of abstraction: you get complex behavior like predictive back \"for free\" when using standard routes that implement the necessary interfaces and base classes.\n\n### Conclusion\n\nIn this chapter, we briefly explored `PredictiveBackRoute`, an interface that enables routes to participate in platform-specific interactive back gestures like Android's predictive back. We learned that it defines methods for handling the start, update, cancel, and commit phases of the gesture, and that base classes like `TransitionRoute` implement this interface to provide the core logic for controlling the route's animation based on user input. By using routes that implement `PredictiveBackRoute` (like `MaterialPageRoute`), you automatically get support for these modern navigation features on supporting platforms.\n\nIn the next chapter, we'll look at [LocalHistoryRoute](07_localhistoryroute_.md), a mixin that allows routes to handle some \"back\" actions internally without actually popping the route from the navigator stack.\n\n[Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"LocalHistoryRoute\n\". This is Chapter 7.\n\nConcept Details:\n- Name: LocalHistoryRoute\n\n- Description:\nA `LocalHistoryRoute` allows a single playing card (screen) to have its own mini-stack of interactions. Imagine being able to flip through a few different views *within* a single card before going back to the previous major card. This is useful for things like searching within a screen, where pressing back might hide the search results before returning to the previous full screen.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n---\n# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)\n---\n# Chapter 6: PredictiveBackRoute\n\nWelcome back! In our previous chapters, we've explored how Flutter uses [Route](01_route_.md)s like a stack of playing cards to manage screens, how [TransitionRoute](02_transitionroute_.md) adds animations to make screen changes smooth, and how [OverlayRoute](03_overlayroute_.md) and [ModalRoute](04_modalroute_.md) let us place content on top of existing screens, sometimes with a dimming barrier.\n\nToday, we\u2019re going to look at a concept called `PredictiveBackRoute`. This is a slightly more advanced topic, specifically related to how users interact with the \"back\" action on platforms like Android, where you can sometimes swipe from the edge of the screen to preview the previous screen *before* fully completing the back gesture.\n\n### What is a PredictiveBackRoute?\n\nImagine you're looking at a detailed picture in a gallery app on your phone. You know you want to go back to the list of pictures. On some operating systems (like recent Android versions), you can start a swipe gesture from the left or right edge of the screen. As you swipe, the current screen starts to shrink and move away, and you can see the previous screen (the list of pictures) peeking from behind! If you complete the swipe, you go back. If you let go halfway, the current screen snaps back into place.\n\nThis interactive, visual \"pull-to-go-back\" experience is what **Predictive Back** is all about. It gives the user a clearer idea of where they're going before they commit to the back action.\n\n`PredictiveBackRoute` is an abstraction in Flutter that helps routes participate in this predictive back gesture. It's like giving your animated playing cards a special edge that responds to a \"pulling\" motion, showing what's underneath before you actually lift the card off the stack.\n\nYou won't often create a `PredictiveBackRoute` directly because it's an `interface` (a contract for what a class *should* do). Instead, other route types like `TransitionRoute` (which includes `ModalRoute` like `MaterialPageRoute`) *implement* this interface, adding the necessary logic to respond to these predictive back gestures.\n\n### Why Use PredictiveBackRoute?\n\nImplementing predictive back requires coordination between the operating system's gesture detection and the route's animation. The OS tells the app that a back gesture is starting, how far along it is, if it's canceled, or if it's committed. The route needs to respond by animating its appearance accordingly.\n\nThe `PredictiveBackRoute` interface defines the standard methods that routes need to provide to handle these events. By having routes implement this interface, the Flutter framework (specifically, the [Navigator](03_overlayroute_.md) or underlying low-level gesture handlers) knows how to communicate with the route during a predictive back gesture.\n\nThis makes integrating with native predictive back much cleaner. The route, by implementing `PredictiveBackRoute`, declares that it *knows how* to handle such gestures, and the framework uses the defined methods to control its animation during the gesture.\n\n### Key Concepts of PredictiveBackRoute\n\nSince `PredictiveBackRoute` is an interface, its main \"concepts\" are the methods it requires implementing classes to have:\n\n*   **`handleStartBackGesture({double progress})`:** Called when a predictive back gesture *begins*. The `progress` tells the route how much the user has already swiped (0.0 is the start, 1.0 is fully back).\n*   **`handleUpdateBackGestureProgress({required double progress})`:** Called repeatedly as the user *drags* the swipe gesture. The `progress` updates continuously from near 0.0 up to 1.0. This is where the route should update its transition animation based on the user's finger movement.\n*   **`handleCancelBackGesture()`:** Called if the user *releases* the gesture *before* reaching the commit threshold (usually before reaching the edge). The route should animate back to its fully visible state.\n*   **`handleCommitBackGesture()`:** Called if the user *completes* the gesture (swipes all the way or past a certain point). The route should finish its exit animation and be popped from the navigator.\n*   **`popGestureEnabled`:** A getter that indicates whether the route *can* currently be dismissed by a pop gesture (like predictive back). This helps the framework decide if it should even start sending gesture events to this route.\n\nRoutes that implement `PredictiveBackRoute` use these methods to control their existing animation controllers (like the one inherited from [TransitionRoute](02_transitionroute_.md)).\n\n### How PredictiveBackRoute Works (Simplified)\n\nLet's trace what happens conceptually when a user performs a predictive back gesture on a screen represented by a route that implements `PredictiveBackRoute` (like a `MaterialPageRoute`).\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant FlutterEngine as Flutter Engine\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (PredictiveBackRoute)\n\n    User->>OS: Starts swipe from edge\n    OS->>FlutterEngine: Notifies gesture started\n    FlutterEngine->>Navigator: Notifies back gesture started (PredictiveBackEvent)\n    Navigator->>CurrentRoute: Calls handleStartBackGesture({progress: 0.0})\n    CurrentRoute-->>Navigator: Route starts responding to gesture\n\n    loop User swipes further\n        User->>OS: Drags finger\n        OS->>FlutterEngine: Notifies progress update (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes progress to Navigator\n        Navigator->>CurrentRoute: Calls handleUpdateBackGestureProgress({progress: ...})\n        CurrentRoute-->>Navigator: Route updates animation based on progress\n    end\n\n    alt User lets go (cancel)\n        User->>OS: Stops swiping before threshold\n        OS->>FlutterEngine: Notifies gesture canceled (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes cancel to Navigator\n        Navigator->>CurrentRoute: Calls handleCancelBackGesture()\n        CurrentRoute-->>Navigator: Route animates back to full visibility\n        Navigator-->>User: Screen returns to original state\n    else User swipes fully (commit)\n        User->>OS: Completes swipe\n        OS->>FlutterEngine: Notifies gesture completed (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes commit to Navigator\n        Navigator->>CurrentRoute: Calls handleCommitBackGesture()\n        CurrentRoute-->>Navigator: Route starts exit animation\n        Navigator->>Navigator: Pops CurrentRoute from stack\n        Navigator-->>User: Transition finishes, previous screen is shown\n    end\n```\n\nNotice how the operating system detects the gesture, passes information through the Flutter engine to the [Navigator](03_overlayroute_.md), and the [Navigator](03_overlayroute_.md) then uses the `PredictiveBackRoute` methods to tell the specific route how to animate.\n\n### Looking at the Code\n\nLet's look at the `PredictiveBackRoute` interface definition (it's part of the `TransitionRoute` code snippet you have, near the end). Remember, an interface just lists methods that a class *must* provide.\n\n```dart\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n```\n\nThis code snippet confirms the methods we discussed: `isCurrent` (useful to check if this is the route the user is trying to back from), `popGestureEnabled` (to check if the gesture is allowed), and the four `handle...BackGesture` methods for the different phases of the gesture.\n\nNow, let's look at how `TransitionRoute` (which `ModalRoute` extends) implements these methods. This logic is also in the provided snippet.\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other code ...\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress; // Set animation value to initial progress\n    navigator?.didStartUserGesture(); // Notify navigator a gesture started\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress; // Update animation value based on drag progress\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true); // Animate forward (back to original state)\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false); // Animate backward (complete pop)\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // Calculate animation duration based on current progress\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0, // Animate to fully forward (visible)\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop(); // Trigger the pop\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // If still animating, finish the pop animation\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0, // Animate back to fully dismissed\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    // Notify navigator the gesture stopped after delay if needed\n    if (_controller?.isAnimating ?? false) {\n       // ... animation status listener logic ...\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // ... more code ...\n\n  @override\n  bool get popGestureEnabled {\n    // ... checks if a pop gesture is currently allowed ...\n    // Checks things like: is this the first route? Is there a WillPopScope blocking?\n    // Is another gesture or animation already happening?\n    return true; // Simplified example - actual logic depends on many factors\n  }\n\n  // End PredictiveBackRoute.\n\n  // ... rest of TransitionRoute code ...\n}\n```\n\nIn this code (simplified):\n\n*   When the gesture starts (`handleStartBackGesture`), the route's internal animation controller (`_controller`) is set to the initial progress, and the [Navigator](03_overlayroute_.md) is notified a gesture is active.\n*   When the gesture updates (`handleUpdateBackGestureProgress`), the animation controller's value is directly set to the current gesture `progress`. This makes the transition animation track the user's finger!\n*   When the gesture ends (either `handleCancelBackGesture` or `handleCommitBackGesture`), the `_handleDragEnd` method is called.\n*   `_handleDragEnd` decides whether to animate the route back to fully visible (`animateForward: true`) or fully dismissed (`animateForward: false`).\n*   If completing the pop, it calls `navigator?.pop()`, which triggers the standard route popping process, and then finishes any remaining animation smoothly.\n*   `popGestureEnabled` contains logic to determine if this route is a candidate for a back gesture.\n\nThis implementation in `TransitionRoute` provides the generic plumbing for predictive back. Specific route types, like `MaterialPageRoute`, might use the `animation` value provided by the `_controller` (which is now being manipulated by the gesture handlers) within their `buildTransitions` method to create the actual visual effect of the previous screen peeking out or the current screen sliding away.\n\n### Example (Conceptual)\n\nYou don't typically *use* `PredictiveBackRoute` directly. You benefit from it when using routes that *implement* it.\n\nFor example, `MaterialPageRoute` implements `PredictiveBackRoute` (because it extends `ModalRoute` which extends `TransitionRoute`). When you use `Navigator.push(context, MaterialPageRoute(...))`, the resulting route automatically participates in Android's predictive back gesture because `MaterialPageRoute` provides the gesture handling logic inherited from `TransitionRoute`. You don't write any predictive back code yourself!\n\n```dart\n// You don't implement PredictiveBackRoute yourself for standard routes.\n// MaterialPageRoute already does this for you.\n\nNavigator.push(\n  context,\n  MaterialPageRoute(\n    builder: (context) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Detail Page')),\n        body: const Center(child: Text('Swipe from the edge to see predictive back!')),\n      );\n    },\n  ),\n);\n\n// Because MaterialPageRoute is (indirectly) a PredictiveBackRoute,\n// when a predictive back gesture starts on an Android device:\n// The framework calls handleStartBackGesture on the MaterialPageRoute instance.\n// As the user swipes, handleUpdateBackGestureProgress is called repeatedly.\n// The MaterialPageRoute's buildTransitions method (using the manipulated animation)\n// draws the predictive back effect (e.g., the page sliding away).\n// If the user cancels, handleCancelBackGesture is called.\n// If the user commits, handleCommitBackGesture is called, triggering a pop.\n```\n\nThis is the power of abstraction: you get complex behavior like predictive back \"for free\" when using standard routes that implement the necessary interfaces and base classes.\n\n### Conclusion\n\nIn this chapter, we briefly explored `PredictiveBackRoute`, an interface that enables routes to participate in platform-specific interactive back gestures like Android's predictive back. We learned that it defines methods for handling the start, update, cancel, and commit phases of the gesture, and that base classes like `TransitionRoute` implement this interface to provide the core logic for controlling the route's animation based on user input. By using routes that implement `PredictiveBackRoute` (like `MaterialPageRoute`), you automatically get support for these modern navigation features on supporting platforms.\n\nIn the next chapter, we'll look at [LocalHistoryRoute](07_localhistoryroute_.md), a mixin that allows routes to handle some \"back\" actions internally without actually popping the route from the navigator stack.\n\n[Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 7: LocalHistoryRoute\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 7: LocalHistoryRoute\n\nWelcome back, future Flutter expert! In our previous chapters, we've climbed the `Route` hierarchy, learning about animated transitions ([TransitionRoute](02_transitionroute_.md)), layered overlays ([OverlayRoute](03_overlayroute_.md)), and modal experiences ([ModalRoute](04_modalroute_.md)), even touching on predictive back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)). Our mental model has been a stack of full playing cards, where \"back\" always means peeling off the top card to reveal the one below.\n\nBut what if you're on a single screen (one card), and within that screen, you perform a few actions that feel like mini-navigations, but you don't want to fully leave that screen? Imagine a search feature within a product details page. You:\n\n1.  Are viewing product details.\n2.  Tap a search icon within that page.\n3.  A search bar appears on the *same* page, and you start typing.\n4.  As you type, search results appear, perhaps covering the main product details.\n5.  You tap a result, maybe showing a mini-preview, still within this screen.\n\nNow, what happens if you press the back button? You probably don't want to go *all the way back* to the list of products. You likely want to:\n\n1.  Hide the mini-preview.\n2.  Hide the search results.\n3.  Hide the search bar, returning to the original product details view.\n4.  *Then*, if you press back again, you go back to the product list.\n\nThis is where `LocalHistoryRoute` comes in! It allows a single [Route](01_route_.md) (or rather, a `ModalRoute` that uses the `LocalHistoryRoute` *mixin*) to manage its *own* mini-stack of pop-like behaviors without involving the main [Navigator](03_overlayroute_.md) stack.\n\n### What is a LocalHistoryRoute?\n\nA `LocalHistoryRoute` is not a separate type of route in the same way that [ModalRoute](04_modalroute_.md) is a separate type from [OverlayRoute](03_overlayroute_.md). Instead, it's a **mixin**. Think of a mixin as a set of extra powers or abilities you can *add* to an existing class. `LocalHistoryRoute` adds the ability to handle \"back\" actions *locally*, within that route itself, instead of letting the [Navigator](03_overlayroute_.md) pop the entire route off the stack.\n\nSpecifically, `ModalRoute` uses ([mixes in](04_modalroute_.md)) the `LocalHistoryRoute` capabilities. This means any `ModalRoute` (including common ones like `MaterialPageRoute`) can have its own *local history*.\n\nImagine your single screen (the playing card) can have sticky notes attached to its *front*. When you add a sticky note (like showing a search bar), you're adding an entry to the screen's \"local history.\" When you press back, instead of removing the entire card, the screen checks its sticky notes. If there's a sticky note, it removes the top sticky note (hiding the search bar) and stays on the same card. Only when all sticky notes are gone does the next back press remove the main card.\n\n### Why Use LocalHistoryRoute?\n\nUsing `LocalHistoryRoute` (by adding entries to the local history of a `ModalRoute`) is essential for implementing UI patterns where a \"back\" action within a screen should reverse a temporary state change or overlay *before* navigating away from that screen.\n\nThis provides a more intuitive and consistent user experience, especially on platforms where the hardware or OS back button is commonly used. You keep the user focused on the current screen until they've finished the sub-tasks (like search or filtering) they started within it.\n\n### Key Concepts of LocalHistoryRoute\n\n`LocalHistoryRoute` introduces a simple mechanism:\n\n*   **Local History Entry (`LocalHistoryEntry`):** This is the core concept! It's an object representing a single \"step\" in the route's local history. You add these entries when you perform an action that should be reversible by a local back press (e.g., showing an overlay, expanding a section).\n*   **`onRemove` callback:** Each `LocalHistoryEntry` has an optional `onRemove` callback. This function is called when that specific history entry is removed (when the user performs a local back action that corresponds to this entry). This is where you put the code to *undo* the action associated with this entry (e.g., hide the search results, close the search bar).\n*   **Adding Entries (`addLocalHistoryEntry`):** Routes that use the mixin (`LocalHistoryRoute`) have a method to add a new `LocalHistoryEntry` to their history stack. The most recently added entry is at the top.\n*   **Handling Pop (`didPop` & `willHandlePopInternally`):** The `LocalHistoryRoute` mixin overrides the route's `didPop` method. When the [Navigator](03_overlayroute_.md) tries to pop the route, the `LocalHistoryRoute` checks its local history. If there are entries, it *doesn't* let the [Navigator](03_overlayroute_.md) pop the main route. Instead, it removes the last `LocalHistoryEntry` and calls its `onRemove` callback. Only if the local history is empty does it allow the `Navigator` to proceed with popping the main route. The `willHandlePopInternally` getter also reflects this state; it returns `true` if there are local history entries, indicating that the route will handle the pop itself.\n\nEssentially, the `LocalHistoryRoute` mixin intercept's the `Navigator`'s `pop` command when the route has local history entries, handles it internally by removing an entry, and then tells the `Navigator` \"No, I wasn't popped, I handled it.\"\n\n### How LocalHistoryRoute Works (Conceptual)\n\nLet's trace the playing card example with a local search feature using `LocalHistoryRoute`.\n\n**Scenario 1: Adding a Local History Entry (Showing Search)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant SearchOverlay as Search Overlay Widget\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>Routeroute: Tap Search Icon\n    Routeroute->>SearchOverlay: Show Search Overlay Widget\n    Routeroute->>LocalHistoryEntry: Create Local History Entry\n    Routeroute->>Routeroute: Add Local History Entry to local history stack\n    Routeroute-->>User: Screen now shows Search Overlay\n```\n\nThe key here is that tapping the search icon doesn't push a new route. It changes the UI *within* the current route and adds a marker (`LocalHistoryEntry`) to the route's internal history list.\n\n**Scenario 2: Pressing Back (Local Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It's NOT empty)\n    Routeroute->>LocalHistoryEntry: Remove top Local History Entry\n    Routeroute->>LocalHistoryEntry: Call onRemove() callback (...which hides the Search Overlay)\n    Routeroute-->>Navigator: Returns 'false' (claiming it was NOT popped)\n    Navigator-->>User: Navigator stays on the same route; User sees Product Details again.\n```\n\nWhen back is pressed, the `Navigator` asks the route to pop. But the route, thanks to the mixin, sees a `LocalHistoryEntry` and *doesn't* let the `Navigator` pop it. Instead, it handles the \"pop\" locally by removing the entry and triggering its `onRemove` callback, which reverses the local UI change.\n\n**Scenario 3: Pressing Back Again (Full Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route (Product List)\n\n    User->>OS: Press Back Button (Local history is now EMPTY)\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It IS empty)\n    Routeroute-->>Navigator: Returns 'true' (allowing Navigator to pop)\n    Navigator->>Routeroute: Disposes Route (conceptually after animation)\n    Navigator->>Navigator: Pops Routeroute from stack\n    Navigator-->>User: User now sees Product List\n```\n\nWith the local history empty, when back is pressed again, the route's `didPop` sees the empty list and *does* return `true`, indicating that it allowed itself to be popped. The `Navigator` then proceeds with removing the route from its stack.\n\n### Looking at the Code\n\nLet's examine the relevant parts of the `LocalHistoryRoute` mixin definition.\n\n```dart\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  void addLocalHistoryEntry(LocalHistoryEntry entry) { /* ... adds to _localHistory ... */ }\n\n  /// Remove a local history entry from this route.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) { /* ... removes from _localHistory and calls onRemove */ }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop; // Indicate that this route will handle the pop internally.\n    }\n    return super.popDisposition; // Let the base class decide (usually allows Navigator pop).\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      // ... cleanup and call entry._notifyRemoved() which calls onRemove ...\n      return false; // IMPORTANT: Return false to tell Navigator it was NOT popped\n    }\n    return super.didPop(result); // Local history empty, let the base class handle the pop.\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty; // True if local history exists.\n  }\n}\n```\n\nKey things to note:\n\n*   `mixin LocalHistoryRoute<T> on Route<T>`: This confirms it's a mixin that can only be applied to classes that are (or inherit from) `Route<T>`.\n*   `_localHistory`: A private list that stores the `LocalHistoryEntry` objects. It acts as the local history stack.\n*   `addLocalHistoryEntry(LocalHistoryEntry entry)`: Adds an entry to the `_localHistory` list.\n*   `removeLocalHistoryEntry(LocalHistoryEntry entry)`: Removes a specific entry (you might call this if a local state change is reversed by something other than a back button).\n*   `popDisposition`: Overridden to return `RoutePopDisposition.pop` if `willHandlePopInternally` is true, signaling that the route will handle the pop itself.\n*   `didPop(T? result)`: This is the crucial override. It checks if `_localHistory` is empty. If not, it removes the last entry, calls its `onRemove` callback, and returns `false`. Returning `false` signifies to the [Navigator](03_overlayroute_.md) that this route *was not* removed from the stack. If `_localHistory` *is* empty, it calls `super.didPop`, letting the base `Route` (and thus the [Navigator](03_overlayroute_.md)) handle the pop.\n*   `willHandlePopInternally`: This getter returns `true` if there are any local history entries, informing potentially other parts of the framework (like an `AppBar` which might decide to show a back button or not) that the route has internal pop handling.\n\nNow let's look at the `LocalHistoryEntry` itself:\n\n```dart\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n```\n\nHere:\n\n*   `LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true})`: The constructor takes an optional `onRemove` callback.\n*   `onRemove`: The function that gets called when this specific entry is popped from the local history.\n*   `impliesAppBarDismissal`: A flag that affects whether an `AppBar` automatically shows a back button. If a route has local history entries where this is true, the `AppBar` might show a back button, even if the route isn't truly `canPop` from the `Navigator`'s perspective.\n\n### Example: Implementing Local History for Search\n\nLet's build a conceptual example showing how you'd use `LocalHistoryRoute` (via a `ModalRoute` subclass like `MaterialPageRoute`) to implement the local search functionality we discussed.\n\nWe'll create a simple screen that shows content, and tapping a button adds a \"search bar\" overlay and a local history entry. Tapping back will hide the search bar.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// This widget represents our screen that we push as a route.\nclass ProductDetailsScreen extends StatefulWidget {\n  const ProductDetailsScreen({super.key});\n\n  @override\n  State<ProductDetailsScreen> createState() => _ProductDetailsScreenState();\n}\n\nclass _ProductDetailsScreenState extends State<ProductDetailsScreen> {\n  // State to control the visibility of the \"search bar\" overlay.\n  bool _showSearchBar = false;\n\n  // The LocalHistoryEntry we'll manage. We need to keep a reference\n  // so we can potentially remove it explicitly if needed (though pop handles it).\n  LocalHistoryEntry? _searchHistoryEntry;\n\n  // Function to show the search bar and add a local history entry.\n  void _activateSearch() {\n    // If the search bar is already shown, do nothing.\n    if (_showSearchBar) {\n      return;\n    }\n    setState(() {\n      _showSearchBar = true;\n    });\n\n    // Get the current ModalRoute for this screen.\n    // MaterialPageRoute is a ModalRoute, so this works.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    // Create a new LocalHistoryEntry.\n    _searchHistoryEntry = LocalHistoryEntry(\n      // When this entry is removed (via local pop), this function is called.\n      onRemove: () {\n        // Hide the search bar.\n        setState(() {\n          _showSearchBar = false;\n        });\n        // Clear our reference to the entry.\n        _searchHistoryEntry = null;\n      },\n      // Setting this to true means the AppBar might show a back button\n      // while the search bar is visible.\n      impliesAppBarDismissal: true,\n    );\n\n    // Add the entry to the current route's local history.\n    modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!);\n\n    print('Search activated, LocalHistoryEntry added.');\n  }\n\n  // Function to explicitly close the search bar (e.g., tapping an 'x' button).\n  void _deactivateSearch() {\n     if (!_showSearchBar || _searchHistoryEntry == null) {\n       return;\n     }\n     // Removing the entry manually also calls its onRemove callback\n     // which will hide the search bar.\n     _searchHistoryEntry!.remove();\n     print('Search deactivated, LocalHistoryEntry removed manually.');\n   }\n\n\n  @override\n  Widget build(BuildContext context) {\n    // Getting the ModalRoute here makes the widget rebuild if the route's\n    // properties related to ModalRoute.of change (like canPop, isCurrent).\n    // This is often how widgets react to route changes.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Product Details'),\n        // AppBar automatically uses ModalRoute.of(context).willHandlePopInternally\n        // (or popDisposition indirectly) and impliesAppBarDismissal\n        // to decide whether to show a back button.\n      ),\n      body: Stack( // Use a Stack to layer the search bar on top\n        children: [\n          // Main product details content\n          Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Text('Product Details Go Here'),\n                const SizedBox(height: 20),\n                ElevatedButton(\n                  onPressed: _activateSearch, // Button to trigger local navigation\n                  child: const Text('Show Search (Local)'),\n                ),\n                 // Example of a widget that might disappear on local pop\n                if (_showSearchBar)\n                 Padding(\n                    padding: const EdgeInsets.only(top: 20.0),\n                    child: Text('Search Results Placeholder...'),\n                 ),\n              ],\n            ),\n          ),\n\n          // The \"search bar\" overlay, conditionally visible\n          if (_showSearchBar)\n            Positioned( // Position on top\n              top: 0,\n              left: 0,\n              right: 0,\n              child: Container(\n                color: Colors.white,\n                 padding: const EdgeInsets.symmetric(horizontal: 8.0),\n                 child: Row(\n                    children: [\n                       Expanded(\n                          child: TextField(\n                             decoration: InputDecoration(hintText: 'Search...'),\n                             autofocus: true,\n                          ),\n                       ),\n                       IconButton(\n                           icon: Icon(Icons.close),\n                           onPressed: _deactivateSearch, // Explicit close button\n                       ),\n                    ],\n                 ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const ProductDetailsScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have a `ProductDetailsScreen` StatefulWidget.\n2.  We use a boolean `_showSearchBar` to control the visibility of our pseudo-search overlay.\n3.  When the \"Show Search\" button is pressed (`_activateSearch`):\n    *   We set `_showSearchBar` to `true`, making the search UI visible.\n    *   We get the current `ModalRoute.of(context)`. Since `MaterialPageRoute` is a `ModalRoute`, this gives us the route object for this screen.\n    *   We create a `LocalHistoryEntry`. Its `onRemove` callback sets `_showSearchBar` back to `false`.\n    *   We call `modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!)` to add the entry to the route's local history list.\n4.  Now, if you press the device's back button:\n    *   The `Navigator` receives the pop request.\n    *   It calls `didPop` on our `MaterialPageRoute`.\n    *   The `MaterialPageRoute` (thanks to the `LocalHistoryRoute` mixin) sees that its local history (`_localHistory`) is not empty.\n    *   It removes the `_searchHistoryEntry` from its `_localHistory`.\n    *   It calls the `onRemove` callback of that `_searchHistoryEntry`.\n    *   The `onRemove` callback fires, setting `_showSearchBar = false`, which hides the search UI.\n    *   The `didPop` method returns `false` to the `Navigator`.\n    *   The `Navigator` does *not* pop the `ProductDetailsScreen`.\n5.  If you press back again:\n    *   The `Navigator` calls `didPop` again.\n    *   The route's local history is now empty.\n    *   `didPop` calls `super.didPop`, which allows the standard route popping mechanism to happen.\n    *   The `ProductDetailsScreen` is popped, and you return to the previous full screen.\n\nThe `impliesAppBarDismissal: true` on the `LocalHistoryEntry` hints to the `AppBar` that it should show a back button. When the local history is empty, the base route's `willHandlePopInternally` becomes false, and the `AppBar` correctly reflects that the next back press will pop the whole route.\n\n### Conclusion\n\nIn this chapter, we explored `LocalHistoryRoute`, not a direct route class, but a powerful mixin used by `ModalRoute` to enable routes to manage their own internal history of pop-like behaviors. We learned how `LocalHistoryEntry` with its `onRemove` callback serves as the mechanism for capturing reversible state changes within a single screen, and how the mixin intercepts the `Navigator`'s pop requests to handle them locally when history entries exist. Understanding `LocalHistoryRoute` is crucial for building intuitive navigation flows where a back press within a screen should undo a temporary UI change before exiting the screen entirely.\n\nIn the next chapter, we will discuss [PopEntry](08_popentry_.md), a more modern way to declaratively manage pop behavior within a route's widget subtree.\n\n[Chapter 8: PopEntry](08_popentry_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"PopEntry\n\". This is Chapter 8.\n\nConcept Details:\n- Name: PopEntry\n\n- Description:\nA `PopEntry` is like a little sticker you can put on a playing card (`ModalRoute`). Each sticker can have two purposes: either prevent the card from being removed from the stack (blocking the \"pop\") or react when the card *is* removed. This is used by widgets like `PopScope` to control whether the user can truly leave a screen (e.g., if they have unsaved changes).\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n---\n# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)\n---\n# Chapter 6: PredictiveBackRoute\n\nWelcome back! In our previous chapters, we've explored how Flutter uses [Route](01_route_.md)s like a stack of playing cards to manage screens, how [TransitionRoute](02_transitionroute_.md) adds animations to make screen changes smooth, and how [OverlayRoute](03_overlayroute_.md) and [ModalRoute](04_modalroute_.md) let us place content on top of existing screens, sometimes with a dimming barrier.\n\nToday, we\u2019re going to look at a concept called `PredictiveBackRoute`. This is a slightly more advanced topic, specifically related to how users interact with the \"back\" action on platforms like Android, where you can sometimes swipe from the edge of the screen to preview the previous screen *before* fully completing the back gesture.\n\n### What is a PredictiveBackRoute?\n\nImagine you're looking at a detailed picture in a gallery app on your phone. You know you want to go back to the list of pictures. On some operating systems (like recent Android versions), you can start a swipe gesture from the left or right edge of the screen. As you swipe, the current screen starts to shrink and move away, and you can see the previous screen (the list of pictures) peeking from behind! If you complete the swipe, you go back. If you let go halfway, the current screen snaps back into place.\n\nThis interactive, visual \"pull-to-go-back\" experience is what **Predictive Back** is all about. It gives the user a clearer idea of where they're going before they commit to the back action.\n\n`PredictiveBackRoute` is an abstraction in Flutter that helps routes participate in this predictive back gesture. It's like giving your animated playing cards a special edge that responds to a \"pulling\" motion, showing what's underneath before you actually lift the card off the stack.\n\nYou won't often create a `PredictiveBackRoute` directly because it's an `interface` (a contract for what a class *should* do). Instead, other route types like `TransitionRoute` (which includes `ModalRoute` like `MaterialPageRoute`) *implement* this interface, adding the necessary logic to respond to these predictive back gestures.\n\n### Why Use PredictiveBackRoute?\n\nImplementing predictive back requires coordination between the operating system's gesture detection and the route's animation. The OS tells the app that a back gesture is starting, how far along it is, if it's canceled, or if it's committed. The route needs to respond by animating its appearance accordingly.\n\nThe `PredictiveBackRoute` interface defines the standard methods that routes need to provide to handle these events. By having routes implement this interface, the Flutter framework (specifically, the [Navigator](03_overlayroute_.md) or underlying low-level gesture handlers) knows how to communicate with the route during a predictive back gesture.\n\nThis makes integrating with native predictive back much cleaner. The route, by implementing `PredictiveBackRoute`, declares that it *knows how* to handle such gestures, and the framework uses the defined methods to control its animation during the gesture.\n\n### Key Concepts of PredictiveBackRoute\n\nSince `PredictiveBackRoute` is an interface, its main \"concepts\" are the methods it requires implementing classes to have:\n\n*   **`handleStartBackGesture({double progress})`:** Called when a predictive back gesture *begins*. The `progress` tells the route how much the user has already swiped (0.0 is the start, 1.0 is fully back).\n*   **`handleUpdateBackGestureProgress({required double progress})`:** Called repeatedly as the user *drags* the swipe gesture. The `progress` updates continuously from near 0.0 up to 1.0. This is where the route should update its transition animation based on the user's finger movement.\n*   **`handleCancelBackGesture()`:** Called if the user *releases* the gesture *before* reaching the commit threshold (usually before reaching the edge). The route should animate back to its fully visible state.\n*   **`handleCommitBackGesture()`:** Called if the user *completes* the gesture (swipes all the way or past a certain point). The route should finish its exit animation and be popped from the navigator.\n*   **`popGestureEnabled`:** A getter that indicates whether the route *can* currently be dismissed by a pop gesture (like predictive back). This helps the framework decide if it should even start sending gesture events to this route.\n\nRoutes that implement `PredictiveBackRoute` use these methods to control their existing animation controllers (like the one inherited from [TransitionRoute](02_transitionroute_.md)).\n\n### How PredictiveBackRoute Works (Simplified)\n\nLet's trace what happens conceptually when a user performs a predictive back gesture on a screen represented by a route that implements `PredictiveBackRoute` (like a `MaterialPageRoute`).\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant FlutterEngine as Flutter Engine\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (PredictiveBackRoute)\n\n    User->>OS: Starts swipe from edge\n    OS->>FlutterEngine: Notifies gesture started\n    FlutterEngine->>Navigator: Notifies back gesture started (PredictiveBackEvent)\n    Navigator->>CurrentRoute: Calls handleStartBackGesture({progress: 0.0})\n    CurrentRoute-->>Navigator: Route starts responding to gesture\n\n    loop User swipes further\n        User->>OS: Drags finger\n        OS->>FlutterEngine: Notifies progress update (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes progress to Navigator\n        Navigator->>CurrentRoute: Calls handleUpdateBackGestureProgress({progress: ...})\n        CurrentRoute-->>Navigator: Route updates animation based on progress\n    end\n\n    alt User lets go (cancel)\n        User->>OS: Stops swiping before threshold\n        OS->>FlutterEngine: Notifies gesture canceled (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes cancel to Navigator\n        Navigator->>CurrentRoute: Calls handleCancelBackGesture()\n        CurrentRoute-->>Navigator: Route animates back to full visibility\n        Navigator-->>User: Screen returns to original state\n    else User swipes fully (commit)\n        User->>OS: Completes swipe\n        OS->>FlutterEngine: Notifies gesture completed (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes commit to Navigator\n        Navigator->>CurrentRoute: Calls handleCommitBackGesture()\n        CurrentRoute-->>Navigator: Route starts exit animation\n        Navigator->>Navigator: Pops CurrentRoute from stack\n        Navigator-->>User: Transition finishes, previous screen is shown\n    end\n```\n\nNotice how the operating system detects the gesture, passes information through the Flutter engine to the [Navigator](03_overlayroute_.md), and the [Navigator](03_overlayroute_.md) then uses the `PredictiveBackRoute` methods to tell the specific route how to animate.\n\n### Looking at the Code\n\nLet's look at the `PredictiveBackRoute` interface definition (it's part of the `TransitionRoute` code snippet you have, near the end). Remember, an interface just lists methods that a class *must* provide.\n\n```dart\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n```\n\nThis code snippet confirms the methods we discussed: `isCurrent` (useful to check if this is the route the user is trying to back from), `popGestureEnabled` (to check if the gesture is allowed), and the four `handle...BackGesture` methods for the different phases of the gesture.\n\nNow, let's look at how `TransitionRoute` (which `ModalRoute` extends) implements these methods. This logic is also in the provided snippet.\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other code ...\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress; // Set animation value to initial progress\n    navigator?.didStartUserGesture(); // Notify navigator a gesture started\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress; // Update animation value based on drag progress\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true); // Animate forward (back to original state)\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false); // Animate backward (complete pop)\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // Calculate animation duration based on current progress\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0, // Animate to fully forward (visible)\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop(); // Trigger the pop\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // If still animating, finish the pop animation\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0, // Animate back to fully dismissed\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    // Notify navigator the gesture stopped after delay if needed\n    if (_controller?.isAnimating ?? false) {\n       // ... animation status listener logic ...\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // ... more code ...\n\n  @override\n  bool get popGestureEnabled {\n    // ... checks if a pop gesture is currently allowed ...\n    // Checks things like: is this the first route? Is there a WillPopScope blocking?\n    // Is another gesture or animation already happening?\n    return true; // Simplified example - actual logic depends on many factors\n  }\n\n  // End PredictiveBackRoute.\n\n  // ... rest of TransitionRoute code ...\n}\n```\n\nIn this code (simplified):\n\n*   When the gesture starts (`handleStartBackGesture`), the route's internal animation controller (`_controller`) is set to the initial progress, and the [Navigator](03_overlayroute_.md) is notified a gesture is active.\n*   When the gesture updates (`handleUpdateBackGestureProgress`), the animation controller's value is directly set to the current gesture `progress`. This makes the transition animation track the user's finger!\n*   When the gesture ends (either `handleCancelBackGesture` or `handleCommitBackGesture`), the `_handleDragEnd` method is called.\n*   `_handleDragEnd` decides whether to animate the route back to fully visible (`animateForward: true`) or fully dismissed (`animateForward: false`).\n*   If completing the pop, it calls `navigator?.pop()`, which triggers the standard route popping process, and then finishes any remaining animation smoothly.\n*   `popGestureEnabled` contains logic to determine if this route is a candidate for a back gesture.\n\nThis implementation in `TransitionRoute` provides the generic plumbing for predictive back. Specific route types, like `MaterialPageRoute`, might use the `animation` value provided by the `_controller` (which is now being manipulated by the gesture handlers) within their `buildTransitions` method to create the actual visual effect of the previous screen peeking out or the current screen sliding away.\n\n### Example (Conceptual)\n\nYou don't typically *use* `PredictiveBackRoute` directly. You benefit from it when using routes that *implement* it.\n\nFor example, `MaterialPageRoute` implements `PredictiveBackRoute` (because it extends `ModalRoute` which extends `TransitionRoute`). When you use `Navigator.push(context, MaterialPageRoute(...))`, the resulting route automatically participates in Android's predictive back gesture because `MaterialPageRoute` provides the gesture handling logic inherited from `TransitionRoute`. You don't write any predictive back code yourself!\n\n```dart\n// You don't implement PredictiveBackRoute yourself for standard routes.\n// MaterialPageRoute already does this for you.\n\nNavigator.push(\n  context,\n  MaterialPageRoute(\n    builder: (context) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Detail Page')),\n        body: const Center(child: Text('Swipe from the edge to see predictive back!')),\n      );\n    },\n  ),\n);\n\n// Because MaterialPageRoute is (indirectly) a PredictiveBackRoute,\n// when a predictive back gesture starts on an Android device:\n// The framework calls handleStartBackGesture on the MaterialPageRoute instance.\n// As the user swipes, handleUpdateBackGestureProgress is called repeatedly.\n// The MaterialPageRoute's buildTransitions method (using the manipulated animation)\n// draws the predictive back effect (e.g., the page sliding away).\n// If the user cancels, handleCancelBackGesture is called.\n// If the user commits, handleCommitBackGesture is called, triggering a pop.\n```\n\nThis is the power of abstraction: you get complex behavior like predictive back \"for free\" when using standard routes that implement the necessary interfaces and base classes.\n\n### Conclusion\n\nIn this chapter, we briefly explored `PredictiveBackRoute`, an interface that enables routes to participate in platform-specific interactive back gestures like Android's predictive back. We learned that it defines methods for handling the start, update, cancel, and commit phases of the gesture, and that base classes like `TransitionRoute` implement this interface to provide the core logic for controlling the route's animation based on user input. By using routes that implement `PredictiveBackRoute` (like `MaterialPageRoute`), you automatically get support for these modern navigation features on supporting platforms.\n\nIn the next chapter, we'll look at [LocalHistoryRoute](07_localhistoryroute_.md), a mixin that allows routes to handle some \"back\" actions internally without actually popping the route from the navigator stack.\n\n[Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md)\n---\n# Chapter 7: LocalHistoryRoute\n\nWelcome back, future Flutter expert! In our previous chapters, we've climbed the `Route` hierarchy, learning about animated transitions ([TransitionRoute](02_transitionroute_.md)), layered overlays ([OverlayRoute](03_overlayroute_.md)), and modal experiences ([ModalRoute](04_modalroute_.md)), even touching on predictive back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)). Our mental model has been a stack of full playing cards, where \"back\" always means peeling off the top card to reveal the one below.\n\nBut what if you're on a single screen (one card), and within that screen, you perform a few actions that feel like mini-navigations, but you don't want to fully leave that screen? Imagine a search feature within a product details page. You:\n\n1.  Are viewing product details.\n2.  Tap a search icon within that page.\n3.  A search bar appears on the *same* page, and you start typing.\n4.  As you type, search results appear, perhaps covering the main product details.\n5.  You tap a result, maybe showing a mini-preview, still within this screen.\n\nNow, what happens if you press the back button? You probably don't want to go *all the way back* to the list of products. You likely want to:\n\n1.  Hide the mini-preview.\n2.  Hide the search results.\n3.  Hide the search bar, returning to the original product details view.\n4.  *Then*, if you press back again, you go back to the product list.\n\nThis is where `LocalHistoryRoute` comes in! It allows a single [Route](01_route_.md) (or rather, a `ModalRoute` that uses the `LocalHistoryRoute` *mixin*) to manage its *own* mini-stack of pop-like behaviors without involving the main [Navigator](03_overlayroute_.md) stack.\n\n### What is a LocalHistoryRoute?\n\nA `LocalHistoryRoute` is not a separate type of route in the same way that [ModalRoute](04_modalroute_.md) is a separate type from [OverlayRoute](03_overlayroute_.md). Instead, it's a **mixin**. Think of a mixin as a set of extra powers or abilities you can *add* to an existing class. `LocalHistoryRoute` adds the ability to handle \"back\" actions *locally*, within that route itself, instead of letting the [Navigator](03_overlayroute_.md) pop the entire route off the stack.\n\nSpecifically, `ModalRoute` uses ([mixes in](04_modalroute_.md)) the `LocalHistoryRoute` capabilities. This means any `ModalRoute` (including common ones like `MaterialPageRoute`) can have its own *local history*.\n\nImagine your single screen (the playing card) can have sticky notes attached to its *front*. When you add a sticky note (like showing a search bar), you're adding an entry to the screen's \"local history.\" When you press back, instead of removing the entire card, the screen checks its sticky notes. If there's a sticky note, it removes the top sticky note (hiding the search bar) and stays on the same card. Only when all sticky notes are gone does the next back press remove the main card.\n\n### Why Use LocalHistoryRoute?\n\nUsing `LocalHistoryRoute` (by adding entries to the local history of a `ModalRoute`) is essential for implementing UI patterns where a \"back\" action within a screen should reverse a temporary state change or overlay *before* navigating away from that screen.\n\nThis provides a more intuitive and consistent user experience, especially on platforms where the hardware or OS back button is commonly used. You keep the user focused on the current screen until they've finished the sub-tasks (like search or filtering) they started within it.\n\n### Key Concepts of LocalHistoryRoute\n\n`LocalHistoryRoute` introduces a simple mechanism:\n\n*   **Local History Entry (`LocalHistoryEntry`):** This is the core concept! It's an object representing a single \"step\" in the route's local history. You add these entries when you perform an action that should be reversible by a local back press (e.g., showing an overlay, expanding a section).\n*   **`onRemove` callback:** Each `LocalHistoryEntry` has an optional `onRemove` callback. This function is called when that specific history entry is removed (when the user performs a local back action that corresponds to this entry). This is where you put the code to *undo* the action associated with this entry (e.g., hide the search results, close the search bar).\n*   **Adding Entries (`addLocalHistoryEntry`):** Routes that use the mixin (`LocalHistoryRoute`) have a method to add a new `LocalHistoryEntry` to their history stack. The most recently added entry is at the top.\n*   **Handling Pop (`didPop` & `willHandlePopInternally`):** The `LocalHistoryRoute` mixin overrides the route's `didPop` method. When the [Navigator](03_overlayroute_.md) tries to pop the route, the `LocalHistoryRoute` checks its local history. If there are entries, it *doesn't* let the [Navigator](03_overlayroute_.md) pop the main route. Instead, it removes the last `LocalHistoryEntry` and calls its `onRemove` callback. Only if the local history is empty does it allow the `Navigator` to proceed with popping the main route. The `willHandlePopInternally` getter also reflects this state; it returns `true` if there are local history entries, indicating that the route will handle the pop itself.\n\nEssentially, the `LocalHistoryRoute` mixin intercept's the `Navigator`'s `pop` command when the route has local history entries, handles it internally by removing an entry, and then tells the `Navigator` \"No, I wasn't popped, I handled it.\"\n\n### How LocalHistoryRoute Works (Conceptual)\n\nLet's trace the playing card example with a local search feature using `LocalHistoryRoute`.\n\n**Scenario 1: Adding a Local History Entry (Showing Search)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant SearchOverlay as Search Overlay Widget\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>Routeroute: Tap Search Icon\n    Routeroute->>SearchOverlay: Show Search Overlay Widget\n    Routeroute->>LocalHistoryEntry: Create Local History Entry\n    Routeroute->>Routeroute: Add Local History Entry to local history stack\n    Routeroute-->>User: Screen now shows Search Overlay\n```\n\nThe key here is that tapping the search icon doesn't push a new route. It changes the UI *within* the current route and adds a marker (`LocalHistoryEntry`) to the route's internal history list.\n\n**Scenario 2: Pressing Back (Local Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It's NOT empty)\n    Routeroute->>LocalHistoryEntry: Remove top Local History Entry\n    Routeroute->>LocalHistoryEntry: Call onRemove() callback (...which hides the Search Overlay)\n    Routeroute-->>Navigator: Returns 'false' (claiming it was NOT popped)\n    Navigator-->>User: Navigator stays on the same route; User sees Product Details again.\n```\n\nWhen back is pressed, the `Navigator` asks the route to pop. But the route, thanks to the mixin, sees a `LocalHistoryEntry` and *doesn't* let the `Navigator` pop it. Instead, it handles the \"pop\" locally by removing the entry and triggering its `onRemove` callback, which reverses the local UI change.\n\n**Scenario 3: Pressing Back Again (Full Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route (Product List)\n\n    User->>OS: Press Back Button (Local history is now EMPTY)\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It IS empty)\n    Routeroute-->>Navigator: Returns 'true' (allowing Navigator to pop)\n    Navigator->>Routeroute: Disposes Route (conceptually after animation)\n    Navigator->>Navigator: Pops Routeroute from stack\n    Navigator-->>User: User now sees Product List\n```\n\nWith the local history empty, when back is pressed again, the route's `didPop` sees the empty list and *does* return `true`, indicating that it allowed itself to be popped. The `Navigator` then proceeds with removing the route from its stack.\n\n### Looking at the Code\n\nLet's examine the relevant parts of the `LocalHistoryRoute` mixin definition.\n\n```dart\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  void addLocalHistoryEntry(LocalHistoryEntry entry) { /* ... adds to _localHistory ... */ }\n\n  /// Remove a local history entry from this route.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) { /* ... removes from _localHistory and calls onRemove */ }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop; // Indicate that this route will handle the pop internally.\n    }\n    return super.popDisposition; // Let the base class decide (usually allows Navigator pop).\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      // ... cleanup and call entry._notifyRemoved() which calls onRemove ...\n      return false; // IMPORTANT: Return false to tell Navigator it was NOT popped\n    }\n    return super.didPop(result); // Local history empty, let the base class handle the pop.\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty; // True if local history exists.\n  }\n}\n```\n\nKey things to note:\n\n*   `mixin LocalHistoryRoute<T> on Route<T>`: This confirms it's a mixin that can only be applied to classes that are (or inherit from) `Route<T>`.\n*   `_localHistory`: A private list that stores the `LocalHistoryEntry` objects. It acts as the local history stack.\n*   `addLocalHistoryEntry(LocalHistoryEntry entry)`: Adds an entry to the `_localHistory` list.\n*   `removeLocalHistoryEntry(LocalHistoryEntry entry)`: Removes a specific entry (you might call this if a local state change is reversed by something other than a back button).\n*   `popDisposition`: Overridden to return `RoutePopDisposition.pop` if `willHandlePopInternally` is true, signaling that the route will handle the pop itself.\n*   `didPop(T? result)`: This is the crucial override. It checks if `_localHistory` is empty. If not, it removes the last entry, calls its `onRemove` callback, and returns `false`. Returning `false` signifies to the [Navigator](03_overlayroute_.md) that this route *was not* removed from the stack. If `_localHistory` *is* empty, it calls `super.didPop`, letting the base `Route` (and thus the [Navigator](03_overlayroute_.md)) handle the pop.\n*   `willHandlePopInternally`: This getter returns `true` if there are any local history entries, informing potentially other parts of the framework (like an `AppBar` which might decide to show a back button or not) that the route has internal pop handling.\n\nNow let's look at the `LocalHistoryEntry` itself:\n\n```dart\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n```\n\nHere:\n\n*   `LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true})`: The constructor takes an optional `onRemove` callback.\n*   `onRemove`: The function that gets called when this specific entry is popped from the local history.\n*   `impliesAppBarDismissal`: A flag that affects whether an `AppBar` automatically shows a back button. If a route has local history entries where this is true, the `AppBar` might show a back button, even if the route isn't truly `canPop` from the `Navigator`'s perspective.\n\n### Example: Implementing Local History for Search\n\nLet's build a conceptual example showing how you'd use `LocalHistoryRoute` (via a `ModalRoute` subclass like `MaterialPageRoute`) to implement the local search functionality we discussed.\n\nWe'll create a simple screen that shows content, and tapping a button adds a \"search bar\" overlay and a local history entry. Tapping back will hide the search bar.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// This widget represents our screen that we push as a route.\nclass ProductDetailsScreen extends StatefulWidget {\n  const ProductDetailsScreen({super.key});\n\n  @override\n  State<ProductDetailsScreen> createState() => _ProductDetailsScreenState();\n}\n\nclass _ProductDetailsScreenState extends State<ProductDetailsScreen> {\n  // State to control the visibility of the \"search bar\" overlay.\n  bool _showSearchBar = false;\n\n  // The LocalHistoryEntry we'll manage. We need to keep a reference\n  // so we can potentially remove it explicitly if needed (though pop handles it).\n  LocalHistoryEntry? _searchHistoryEntry;\n\n  // Function to show the search bar and add a local history entry.\n  void _activateSearch() {\n    // If the search bar is already shown, do nothing.\n    if (_showSearchBar) {\n      return;\n    }\n    setState(() {\n      _showSearchBar = true;\n    });\n\n    // Get the current ModalRoute for this screen.\n    // MaterialPageRoute is a ModalRoute, so this works.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    // Create a new LocalHistoryEntry.\n    _searchHistoryEntry = LocalHistoryEntry(\n      // When this entry is removed (via local pop), this function is called.\n      onRemove: () {\n        // Hide the search bar.\n        setState(() {\n          _showSearchBar = false;\n        });\n        // Clear our reference to the entry.\n        _searchHistoryEntry = null;\n      },\n      // Setting this to true means the AppBar might show a back button\n      // while the search bar is visible.\n      impliesAppBarDismissal: true,\n    );\n\n    // Add the entry to the current route's local history.\n    modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!);\n\n    print('Search activated, LocalHistoryEntry added.');\n  }\n\n  // Function to explicitly close the search bar (e.g., tapping an 'x' button).\n  void _deactivateSearch() {\n     if (!_showSearchBar || _searchHistoryEntry == null) {\n       return;\n     }\n     // Removing the entry manually also calls its onRemove callback\n     // which will hide the search bar.\n     _searchHistoryEntry!.remove();\n     print('Search deactivated, LocalHistoryEntry removed manually.');\n   }\n\n\n  @override\n  Widget build(BuildContext context) {\n    // Getting the ModalRoute here makes the widget rebuild if the route's\n    // properties related to ModalRoute.of change (like canPop, isCurrent).\n    // This is often how widgets react to route changes.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Product Details'),\n        // AppBar automatically uses ModalRoute.of(context).willHandlePopInternally\n        // (or popDisposition indirectly) and impliesAppBarDismissal\n        // to decide whether to show a back button.\n      ),\n      body: Stack( // Use a Stack to layer the search bar on top\n        children: [\n          // Main product details content\n          Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Text('Product Details Go Here'),\n                const SizedBox(height: 20),\n                ElevatedButton(\n                  onPressed: _activateSearch, // Button to trigger local navigation\n                  child: const Text('Show Search (Local)'),\n                ),\n                 // Example of a widget that might disappear on local pop\n                if (_showSearchBar)\n                 Padding(\n                    padding: const EdgeInsets.only(top: 20.0),\n                    child: Text('Search Results Placeholder...'),\n                 ),\n              ],\n            ),\n          ),\n\n          // The \"search bar\" overlay, conditionally visible\n          if (_showSearchBar)\n            Positioned( // Position on top\n              top: 0,\n              left: 0,\n              right: 0,\n              child: Container(\n                color: Colors.white,\n                 padding: const EdgeInsets.symmetric(horizontal: 8.0),\n                 child: Row(\n                    children: [\n                       Expanded(\n                          child: TextField(\n                             decoration: InputDecoration(hintText: 'Search...'),\n                             autofocus: true,\n                          ),\n                       ),\n                       IconButton(\n                           icon: Icon(Icons.close),\n                           onPressed: _deactivateSearch, // Explicit close button\n                       ),\n                    ],\n                 ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const ProductDetailsScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have a `ProductDetailsScreen` StatefulWidget.\n2.  We use a boolean `_showSearchBar` to control the visibility of our pseudo-search overlay.\n3.  When the \"Show Search\" button is pressed (`_activateSearch`):\n    *   We set `_showSearchBar` to `true`, making the search UI visible.\n    *   We get the current `ModalRoute.of(context)`. Since `MaterialPageRoute` is a `ModalRoute`, this gives us the route object for this screen.\n    *   We create a `LocalHistoryEntry`. Its `onRemove` callback sets `_showSearchBar` back to `false`.\n    *   We call `modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!)` to add the entry to the route's local history list.\n4.  Now, if you press the device's back button:\n    *   The `Navigator` receives the pop request.\n    *   It calls `didPop` on our `MaterialPageRoute`.\n    *   The `MaterialPageRoute` (thanks to the `LocalHistoryRoute` mixin) sees that its local history (`_localHistory`) is not empty.\n    *   It removes the `_searchHistoryEntry` from its `_localHistory`.\n    *   It calls the `onRemove` callback of that `_searchHistoryEntry`.\n    *   The `onRemove` callback fires, setting `_showSearchBar = false`, which hides the search UI.\n    *   The `didPop` method returns `false` to the `Navigator`.\n    *   The `Navigator` does *not* pop the `ProductDetailsScreen`.\n5.  If you press back again:\n    *   The `Navigator` calls `didPop` again.\n    *   The route's local history is now empty.\n    *   `didPop` calls `super.didPop`, which allows the standard route popping mechanism to happen.\n    *   The `ProductDetailsScreen` is popped, and you return to the previous full screen.\n\nThe `impliesAppBarDismissal: true` on the `LocalHistoryEntry` hints to the `AppBar` that it should show a back button. When the local history is empty, the base route's `willHandlePopInternally` becomes false, and the `AppBar` correctly reflects that the next back press will pop the whole route.\n\n### Conclusion\n\nIn this chapter, we explored `LocalHistoryRoute`, not a direct route class, but a powerful mixin used by `ModalRoute` to enable routes to manage their own internal history of pop-like behaviors. We learned how `LocalHistoryEntry` with its `onRemove` callback serves as the mechanism for capturing reversible state changes within a single screen, and how the mixin intercepts the `Navigator`'s pop requests to handle them locally when history entries exist. Understanding `LocalHistoryRoute` is crucial for building intuitive navigation flows where a back press within a screen should undo a temporary UI change before exiting the screen entirely.\n\nIn the next chapter, we will discuss [PopEntry](08_popentry_.md), a more modern way to declaratively manage pop behavior within a route's widget subtree.\n\n[Chapter 8: PopEntry](08_popentry_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 8: PopEntry\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 8: PopEntry\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md), we learned how a single route could manage its own \"mini-history\" using `LocalHistoryEntry` to handle back presses internally, perfect for showing/hiding overlays or sections within a screen without leaving it.\n\nNow, let's introduce `PopEntry`. This is a newer and often more declarative way to manage if a route can be popped and to react when it *is* popped. Think of it as putting special \"stickers\" onto a playing card ([ModalRoute](04_modalroute_.md)) that can either stick the card to the stack (preventing the pop) or react when the card finally gets removed.\n\n### What is a PopEntry?\n\nA `PopEntry` is a simple object that you can associate with a [ModalRoute](04_modalroute_.md). It holds two key pieces of information:\n\n1.  **Can Pop:** Whether this specific entry thinks the route can currently be popped.\n2.  **On Pop Invoked:** A function (`onPopInvokedWithResult`) to call when the route is popped (or a pop is attempted and blocked).\n\nImagine your [ModalRoute](04_modalroute_.md) (the playing card) can have multiple stickers (`PopEntry`s) stuck to it by different parts of your screen's UI (like different widgets). Before the card can be removed (popped), *every* sticker must agree that it's okay to remove the card. If even one sticker says \"No, don't pop yet!\" then the card stays. If all stickers say \"Yes, go ahead!\", the card can be popped. When the card *is* removed, *every* sticker gets notified.\n\nThis is the mechanism used by the modern `PopScope` widget. When you use `PopScope` inside a route, it often works by creating a `PopEntry` and registering it with the [ModalRoute](04_modalroute_.md) that contains it.\n\nCommon use cases for `PopEntry` (often via `PopScope`):\n\n*   **Blocking pops with unsaved data:** If the user is editing a form, you can create a `PopEntry` that says the route *cannot* be popped while there are unsaved changes.\n*   **Showing a confirmation dialog:** When a pop is attempted but blocked (because a `PopEntry` said no), you can use the `onPopInvokedWithResult` callback of that `PopEntry` to show a \"Discard changes?\" dialog.\n*   **Reacting to a pop:** Even if you don't block the pop, a `PopEntry`'s `onPopInvokedWithResult` can be used to perform cleanup or other actions just before or after the route is popped.\n\n### Why Use PopEntry?\n\n`PopEntry` provides a more structured and explicit way to manage pop behavior compared to the older `WillPopCallback`s (though those are still supported for compatibility and specific advanced cases).\n\n*   **Declarative:** Widgets like `PopScope` make it easy to declare pop behavior right where the relevant UI lives, creating a `PopEntry` under the hood.\n*   **Multiple handlers:** Several `PopEntry` instances can be registered with a single route, each controlling its own `canPop` status and reacting to pop attempts independently. The route's overall `canPop` becomes the logical AND of all registered `PopEntry`s.\n*   **Rich callback:** The `onPopInvokedWithResult` callback provides information about whether the pop *actually* happened (`didPop` boolean) and the `result` the route was popped with, allowing for more nuanced reactions.\n\n### Key Concepts of PopEntry\n\n*   **`canPopNotifier`:** This is a `ValueListenable<bool>`. When its value is `true`, this `PopEntry` contributes to the route being potentially pop-able. When it's `false`, this entry signals \"do not pop.\" The route listens to this notifier and updates its own `canPop` status accordingly.\n*   **`onPopInvokedWithResult(bool didPop, T? result)`:** This callback is triggered whenever a pop is attempted on the route, regardless of whether it was successfully popped or blocked.\n    *   `didPop`: `true` if the route *was* actually popped and removed from the navigator stack; `false` if the pop was blocked (e.g., by a `PopEntry` or [LocalHistoryRoute](07_localhistoryroute_.md)).\n    *   `result`: The value the route was popped with (if `didPop` is true).\n*   **Registering/Unregistering:** A `PopEntry` must be registered with its containing [ModalRoute](04_modalroute_.md) using `modalRoute.registerPopEntry()` and unregistered using `modalRoute.unregisterPopEntry()` when it's no longer needed (typically handled automatically by widgets like `PopScope`).\n\n### How PopEntry Works (Conceptual)\n\nLet's see how a Route with a several PopEntries (stickers) behaves when a pop is attempted.\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (ModalRoute)\n    participant PopEntry1 as PopEntry 1 (Form)\n    participant PopEntry2 as PopEntry 2 (Editing)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>CurrentRoute: Check popDisposition\n    CurrentRoute->>PopEntry1: Check canPopNotifier.value (e.g., is Form clean?)\n    CurrentRoute->>PopEntry2: Check canPopNotifier.value (e.g., is Editing complete?)\n\n    alt Both PopEntry1 and PopEntry2 can pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.pop\n        Navigator->>CurrentRoute: Call didPop(...)\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: true, ...)\n        Navigator->>Navigator: Pops CurrentRoute\n        Navigator-->>User: Previous screen visible\n    else At least one PopEntry cannot pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.doNotPop\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: false, ...)\n        User-->>App: Route remains on screen\n        Note right of User: Might show dialog in callback\n    end\n```\n\n1.  The user initiates a back action.\n2.  The OS notifies the [Navigator](03_overlayroute_.md).\n3.  The [Navigator](03_overlayroute_.md) consults the current route's `popDisposition`.\n4.  The route's `popDisposition` (specifically, the `ModalRoute` implementation using the `LocalHistoryRoute` mixin logic, which also checks registered `PopEntry`s) iterates through its registered `PopEntry` instances and reads their `canPopNotifier.value`.\n5.  If *all* `PopEntry`s return `true` (and there's no [LocalHistoryRoute](07_localhistoryroute_.md) blocking it), the `popDisposition` signals that the route *can* be popped. The [Navigator](03_overlayroute_.md) proceeds with popping the route. After or during the animation, the route's `onPopInvokedWithResult` method is called with `didPop: true`. This cascades to calling `onPopInvokedWithResult` on all registered `PopEntry`s with `didPop: true`.\n6.  If *any* `PopEntry` returns `false`, the `popDisposition` signals `RoutePopDisposition.doNotPop`. The [Navigator](03_overlayroute_.md) *does not* pop the route off the stack. The route's `onPopInvokedWithResult` method is called with `didPop: false`, which cascades to all registered `PopEntry`s calling their `onPopInvokedWithResult` with `didPop: false`. This is where a `PopEntry` might trigger a confirmation dialog.\n\n### Looking at the Code\n\nLet's look at the `PopEntry` definition itself.\n\n```dart\nabstract class PopEntry<T> {\n  // ... deprecated onPopInvoked ...\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  // ... toString ...\n}\n```\nThis abstract class defines the two key parts: the getter for `canPopNotifier` and the abstract method `onPopInvokedWithResult` that subclasses must implement.\n\nNow, let's look at how `ModalRoute` uses `PopEntry` (from the provided snippet):\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  // ... other properties and methods ...\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{}; // Stores registered entries\n\n  // ... willPop (deprecated) ...\n\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      if (!popEntry.canPopNotifier.value) { // Check each entry's canPopNotifier\n        return RoutePopDisposition.doNotPop; // If any is false, block the pop\n      }\n    }\n\n    return super.popDisposition; // If all can pop, let the base (LocalHistoryRoute) decide\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      popEntry.onPopInvokedWithResult(didPop, result); // Call callback on each entry\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry); // Add to the set of entries\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification); // Listen for canPop changes\n    _maybeDispatchNavigationNotification(); // Trigger notification after adding\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry); // Remove from the set\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification); // Stop listening\n    _maybeDispatchNavigationNotification(); // Trigger notification after removing\n  }\n\n  // ... more code ...\n}\n```\nHere, we see:\n*   `_popEntries`: A `Set` within `ModalRoute` to keep track of all the `PopEntry` instances that have been registered with this route.\n*   `popDisposition`: This overridden getter now explicitly loops through `_popEntries`. If *any* `PopEntry`'s `canPopNotifier.value` is `false`, it immediately returns `RoutePopDisposition.doNotPop`, effectively blocking the pop. If the loop completes (all `canPopNotifier.value`s were true), it then asks `super.popDisposition` (which handles the `LocalHistoryRoute` logic) whether the pop should happen or be handled locally.\n*   `onPopInvokedWithResult`: This overridden method simply iterates through the registered `_popEntries` and calls `onPopInvokedWithResult` on each one, passing the same `didPop` and `result` arguments.\n*   `registerPopEntry` and `unregisterPopEntry`: These methods manage adding/removing entries from the `_popEntries` set. They also add/remove a listener to the `PopEntry`'s `canPopNotifier` so that the route can react when a `PopEntry`'s `canPop` status changes (`_maybeDispatchNavigationNotification` is called to potentially notify listeners like the `AppBar`).\n\n### Example: Using PopScope (Which Uses PopEntry)\n\nYou overwhelmingly interact with `PopEntry` through the `PopScope` widget. `PopScope` is a simple widget that wraps another widget and automatically creates, registers, and unregisters a `PopEntry` with the nearest [ModalRoute](04_modalroute_.md).\n\nHere's how you'd use `PopScope` to prevent navigating away from a screen with unsaved changes without a confirmation:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass EditItemScreen extends StatefulWidget {\n  const EditItemScreen({super.key});\n\n  @override\n  State<EditItemScreen> createState() => _EditItemScreenState();\n}\n\nclass _EditItemScreenState extends State<EditItemScreen> {\n  // State to track if there are unsaved changes\n  bool _hasUnsavedChanges = false;\n\n  // ValueNotifier for PopScope's canPop property\n  // PopScope will automatically wrap this in a PopEntry's canPopNotifier\n  final ValueNotifier<bool> _canPop = ValueNotifier<bool>(true); // Start as pop-able\n\n  @override\n  void dispose() {\n    _canPop.dispose(); // Clean up the notifier\n    super.dispose();\n  }\n\n  void _onTextFieldChanged(String text) {\n    // If the text changes, there are unsaved changes\n    final bool hasChanges = text.isNotEmpty; // Simplified check\n    if (_hasUnsavedChanges != hasChanges) {\n      setState(() {\n        _hasUnsavedChanges = hasChanges;\n        // Update the ValueNotifier based on changes\n        _canPop.value = !_hasUnsavedChanges; // Can pop IF there are NO unsaved changes\n      });\n    }\n  }\n\n  // This callback is called when a pop is invoked, regardless of whether it succeeds.\n  void _onPopInvoked(bool didPop) {\n    print('onPopInvoked called: didPop = $didPop');\n    if (didPop) {\n      // Route was successfully popped - maybe do cleanup here\n       print('Route was popped.');\n    } else {\n      // Pop was blocked (because _canPop.value was false) - show a dialog\n      print('Pop was blocked. Showing confirmation dialog...');\n      _showDiscardChangesDialog();\n    }\n  }\n\n  // Show a dialog asking the user if they want to discard changes\n  Future<void> _showDiscardChangesDialog() async {\n    final bool? discard = await showDialog<bool>(\n      context: context,\n      builder: (BuildContext dialogContext) {\n        return AlertDialog(\n          title: const Text('Discard Changes?'),\n          content: const Text('You have unsaved changes. Do you want to discard them?'),\n          actions: <Widget>[\n            TextButton(\n              child: const Text('Cancel'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(false); // Don't discard\n              },\n            ),\n            TextButton(\n              child: const Text('Discard'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(true); // Discard changes\n              },\n            ),\n          ],\n        );\n      },\n    );\n\n    if (discard == true) {\n      // User chose to discard changes - allow the pop now\n      // This must be done AFTER the dialog is dismissed\n       Navigator.of(context).pop();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Wrap the entire screen content in PopScope\n    return PopScope(\n      canPop: _canPop.value, // Control pop-ability using your state\n      onPopInvoked: _onPopInvoked, // Handle pop attempts\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Edit Item'),\n          // AppBar's back button respects the route's popDisposition,\n          // which is influenced by PopScope's canPop.\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              TextField(\n                decoration: const InputDecoration(labelText: 'Item Name'),\n                onChanged: _onTextFieldChanged, // Listen for changes\n              ),\n              const SizedBox(height: 20),\n              Text(\n                _hasUnsavedChanges ? 'You have unsaved changes.' : 'No unsaved changes.',\n                style: TextStyle(color: _hasUnsavedChanges ? Colors.red : Colors.green),\n              ),\n              // Save button (example, not fully implemented pop logic here)\n               // ElevatedButton(\n               //   onPressed: _hasUnsavedChanges ? () {\n               //      // Save logic... then maybe Navigator.of(context).pop(true);\n               //      // After saving, _hasUnsavedChanges would become false,\n               //      // making canPop true again for future back presses.\n               //   } : null,\n               //   child: const Text('Save'),\n               // ),\n            ],\n          ),\n        ),\n      ),\n     );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const EditItemScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have an `EditItemScreen` that uses a boolean `_hasUnsavedChanges` and a `ValueNotifier<bool> _canPop` to manage its state.\n2.  The `_onTextFieldChanged` method updates `_hasUnsavedChanges` and, crucially, updates `_canPop.value`. When there are unsaved changes, `_canPop.value` becomes `false`.\n3.  The entire `Scaffold` is wrapped in a `PopScope`.\n4.  `PopScope`'s `canPop` property is bound to `_canPop.value`. When `_canPop.value` is false, `PopScope` configures the underlying `PopEntry`'s notifier to be false, telling the route \"Don't pop yet!\".\n5.  `PopScope`'s `onPopInvoked` property is set to our `_onPopInvoked` method.\n6.  When the user presses the back button while `_hasUnsavedChanges` is true:\n    *   The [Navigator](03_overlayroute_.md) initiates a pop.\n    *   The route checks its `popDisposition`.\n    *   The `PopScope`'s underlying `PopEntry` contributes `false` to the check.\n    *   The route's `popDisposition` returns `RoutePopDisposition.doNotPop`.\n    *   The [Navigator](03_overlayroute_.md) *does not* pop the route.\n    *   The route calls `onPopInvokedWithResult(didPop: false, result: null)` on all registered `PopEntry`s.\n    *   Our `_onPopInvoked` method is called with `didPop: false`.\n    *   Inside `_onPopInvoked`, since `didPop` is false, we show the \"Discard Changes?\" dialog.\n    *   If the user chooses \"Discard\", the dialog pops with `true`. We then *manually* call `Navigator.of(context).pop()` again. This time, because we're leaving, we'd typically save or discard changes such that `_hasUnsavedChanges` would be false, making `_canPop.value` true *before* this second pop attempt is processed, and the route *can* be popped.\n\nThis demonstrates how `PopScope` (and thus `PopEntry` underneath) provides a clean way to intercept and react to back navigation based on your screen's state.\n\n### Conclusion\n\nIn this chapter, we introduced `PopEntry`, a modern abstraction to declaratively manage a route's pop behavior and react to pop events. We learned that `PopEntry`s, often created by the `PopScope` widget, use a `canPopNotifier` to signal whether a route should currently be allowed to pop and an `onPopInvokedWithResult` callback to handle the outcome of a pop attempt. Understanding `PopEntry` illuminates how widgets like `PopScope` provide powerful control over navigation within your Flutter applications.\n\nIn the next chapter, we'll explore `RouteAware` and `RouteObserver`, which allow widgets to be notified when the route they are in changes state (e.g., when it becomes the top-most route or is covered by another route).\n\n[Chapter 9: RouteAware](09_routeaware_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteAware\n\". This is Chapter 9.\n\nConcept Details:\n- Name: RouteAware\n\n- Description:\nA `RouteAware` is like a playing card that wants to know what's happening around it. When you register a `RouteAware` object with a `RouteObserver`, it gets notifications. These notifications tell the `RouteAware` object when its screen is becoming visible, is hidden by another screen, or is being removed from the navigation stack. This helps widgets react to navigation changes.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n---\n# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)\n---\n# Chapter 6: PredictiveBackRoute\n\nWelcome back! In our previous chapters, we've explored how Flutter uses [Route](01_route_.md)s like a stack of playing cards to manage screens, how [TransitionRoute](02_transitionroute_.md) adds animations to make screen changes smooth, and how [OverlayRoute](03_overlayroute_.md) and [ModalRoute](04_modalroute_.md) let us place content on top of existing screens, sometimes with a dimming barrier.\n\nToday, we\u2019re going to look at a concept called `PredictiveBackRoute`. This is a slightly more advanced topic, specifically related to how users interact with the \"back\" action on platforms like Android, where you can sometimes swipe from the edge of the screen to preview the previous screen *before* fully completing the back gesture.\n\n### What is a PredictiveBackRoute?\n\nImagine you're looking at a detailed picture in a gallery app on your phone. You know you want to go back to the list of pictures. On some operating systems (like recent Android versions), you can start a swipe gesture from the left or right edge of the screen. As you swipe, the current screen starts to shrink and move away, and you can see the previous screen (the list of pictures) peeking from behind! If you complete the swipe, you go back. If you let go halfway, the current screen snaps back into place.\n\nThis interactive, visual \"pull-to-go-back\" experience is what **Predictive Back** is all about. It gives the user a clearer idea of where they're going before they commit to the back action.\n\n`PredictiveBackRoute` is an abstraction in Flutter that helps routes participate in this predictive back gesture. It's like giving your animated playing cards a special edge that responds to a \"pulling\" motion, showing what's underneath before you actually lift the card off the stack.\n\nYou won't often create a `PredictiveBackRoute` directly because it's an `interface` (a contract for what a class *should* do). Instead, other route types like `TransitionRoute` (which includes `ModalRoute` like `MaterialPageRoute`) *implement* this interface, adding the necessary logic to respond to these predictive back gestures.\n\n### Why Use PredictiveBackRoute?\n\nImplementing predictive back requires coordination between the operating system's gesture detection and the route's animation. The OS tells the app that a back gesture is starting, how far along it is, if it's canceled, or if it's committed. The route needs to respond by animating its appearance accordingly.\n\nThe `PredictiveBackRoute` interface defines the standard methods that routes need to provide to handle these events. By having routes implement this interface, the Flutter framework (specifically, the [Navigator](03_overlayroute_.md) or underlying low-level gesture handlers) knows how to communicate with the route during a predictive back gesture.\n\nThis makes integrating with native predictive back much cleaner. The route, by implementing `PredictiveBackRoute`, declares that it *knows how* to handle such gestures, and the framework uses the defined methods to control its animation during the gesture.\n\n### Key Concepts of PredictiveBackRoute\n\nSince `PredictiveBackRoute` is an interface, its main \"concepts\" are the methods it requires implementing classes to have:\n\n*   **`handleStartBackGesture({double progress})`:** Called when a predictive back gesture *begins*. The `progress` tells the route how much the user has already swiped (0.0 is the start, 1.0 is fully back).\n*   **`handleUpdateBackGestureProgress({required double progress})`:** Called repeatedly as the user *drags* the swipe gesture. The `progress` updates continuously from near 0.0 up to 1.0. This is where the route should update its transition animation based on the user's finger movement.\n*   **`handleCancelBackGesture()`:** Called if the user *releases* the gesture *before* reaching the commit threshold (usually before reaching the edge). The route should animate back to its fully visible state.\n*   **`handleCommitBackGesture()`:** Called if the user *completes* the gesture (swipes all the way or past a certain point). The route should finish its exit animation and be popped from the navigator.\n*   **`popGestureEnabled`:** A getter that indicates whether the route *can* currently be dismissed by a pop gesture (like predictive back). This helps the framework decide if it should even start sending gesture events to this route.\n\nRoutes that implement `PredictiveBackRoute` use these methods to control their existing animation controllers (like the one inherited from [TransitionRoute](02_transitionroute_.md)).\n\n### How PredictiveBackRoute Works (Simplified)\n\nLet's trace what happens conceptually when a user performs a predictive back gesture on a screen represented by a route that implements `PredictiveBackRoute` (like a `MaterialPageRoute`).\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant FlutterEngine as Flutter Engine\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (PredictiveBackRoute)\n\n    User->>OS: Starts swipe from edge\n    OS->>FlutterEngine: Notifies gesture started\n    FlutterEngine->>Navigator: Notifies back gesture started (PredictiveBackEvent)\n    Navigator->>CurrentRoute: Calls handleStartBackGesture({progress: 0.0})\n    CurrentRoute-->>Navigator: Route starts responding to gesture\n\n    loop User swipes further\n        User->>OS: Drags finger\n        OS->>FlutterEngine: Notifies progress update (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes progress to Navigator\n        Navigator->>CurrentRoute: Calls handleUpdateBackGestureProgress({progress: ...})\n        CurrentRoute-->>Navigator: Route updates animation based on progress\n    end\n\n    alt User lets go (cancel)\n        User->>OS: Stops swiping before threshold\n        OS->>FlutterEngine: Notifies gesture canceled (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes cancel to Navigator\n        Navigator->>CurrentRoute: Calls handleCancelBackGesture()\n        CurrentRoute-->>Navigator: Route animates back to full visibility\n        Navigator-->>User: Screen returns to original state\n    else User swipes fully (commit)\n        User->>OS: Completes swipe\n        OS->>FlutterEngine: Notifies gesture completed (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes commit to Navigator\n        Navigator->>CurrentRoute: Calls handleCommitBackGesture()\n        CurrentRoute-->>Navigator: Route starts exit animation\n        Navigator->>Navigator: Pops CurrentRoute from stack\n        Navigator-->>User: Transition finishes, previous screen is shown\n    end\n```\n\nNotice how the operating system detects the gesture, passes information through the Flutter engine to the [Navigator](03_overlayroute_.md), and the [Navigator](03_overlayroute_.md) then uses the `PredictiveBackRoute` methods to tell the specific route how to animate.\n\n### Looking at the Code\n\nLet's look at the `PredictiveBackRoute` interface definition (it's part of the `TransitionRoute` code snippet you have, near the end). Remember, an interface just lists methods that a class *must* provide.\n\n```dart\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n```\n\nThis code snippet confirms the methods we discussed: `isCurrent` (useful to check if this is the route the user is trying to back from), `popGestureEnabled` (to check if the gesture is allowed), and the four `handle...BackGesture` methods for the different phases of the gesture.\n\nNow, let's look at how `TransitionRoute` (which `ModalRoute` extends) implements these methods. This logic is also in the provided snippet.\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other code ...\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress; // Set animation value to initial progress\n    navigator?.didStartUserGesture(); // Notify navigator a gesture started\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress; // Update animation value based on drag progress\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true); // Animate forward (back to original state)\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false); // Animate backward (complete pop)\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // Calculate animation duration based on current progress\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0, // Animate to fully forward (visible)\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop(); // Trigger the pop\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // If still animating, finish the pop animation\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0, // Animate back to fully dismissed\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    // Notify navigator the gesture stopped after delay if needed\n    if (_controller?.isAnimating ?? false) {\n       // ... animation status listener logic ...\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // ... more code ...\n\n  @override\n  bool get popGestureEnabled {\n    // ... checks if a pop gesture is currently allowed ...\n    // Checks things like: is this the first route? Is there a WillPopScope blocking?\n    // Is another gesture or animation already happening?\n    return true; // Simplified example - actual logic depends on many factors\n  }\n\n  // End PredictiveBackRoute.\n\n  // ... rest of TransitionRoute code ...\n}\n```\n\nIn this code (simplified):\n\n*   When the gesture starts (`handleStartBackGesture`), the route's internal animation controller (`_controller`) is set to the initial progress, and the [Navigator](03_overlayroute_.md) is notified a gesture is active.\n*   When the gesture updates (`handleUpdateBackGestureProgress`), the animation controller's value is directly set to the current gesture `progress`. This makes the transition animation track the user's finger!\n*   When the gesture ends (either `handleCancelBackGesture` or `handleCommitBackGesture`), the `_handleDragEnd` method is called.\n*   `_handleDragEnd` decides whether to animate the route back to fully visible (`animateForward: true`) or fully dismissed (`animateForward: false`).\n*   If completing the pop, it calls `navigator?.pop()`, which triggers the standard route popping process, and then finishes any remaining animation smoothly.\n*   `popGestureEnabled` contains logic to determine if this route is a candidate for a back gesture.\n\nThis implementation in `TransitionRoute` provides the generic plumbing for predictive back. Specific route types, like `MaterialPageRoute`, might use the `animation` value provided by the `_controller` (which is now being manipulated by the gesture handlers) within their `buildTransitions` method to create the actual visual effect of the previous screen peeking out or the current screen sliding away.\n\n### Example (Conceptual)\n\nYou don't typically *use* `PredictiveBackRoute` directly. You benefit from it when using routes that *implement* it.\n\nFor example, `MaterialPageRoute` implements `PredictiveBackRoute` (because it extends `ModalRoute` which extends `TransitionRoute`). When you use `Navigator.push(context, MaterialPageRoute(...))`, the resulting route automatically participates in Android's predictive back gesture because `MaterialPageRoute` provides the gesture handling logic inherited from `TransitionRoute`. You don't write any predictive back code yourself!\n\n```dart\n// You don't implement PredictiveBackRoute yourself for standard routes.\n// MaterialPageRoute already does this for you.\n\nNavigator.push(\n  context,\n  MaterialPageRoute(\n    builder: (context) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Detail Page')),\n        body: const Center(child: Text('Swipe from the edge to see predictive back!')),\n      );\n    },\n  ),\n);\n\n// Because MaterialPageRoute is (indirectly) a PredictiveBackRoute,\n// when a predictive back gesture starts on an Android device:\n// The framework calls handleStartBackGesture on the MaterialPageRoute instance.\n// As the user swipes, handleUpdateBackGestureProgress is called repeatedly.\n// The MaterialPageRoute's buildTransitions method (using the manipulated animation)\n// draws the predictive back effect (e.g., the page sliding away).\n// If the user cancels, handleCancelBackGesture is called.\n// If the user commits, handleCommitBackGesture is called, triggering a pop.\n```\n\nThis is the power of abstraction: you get complex behavior like predictive back \"for free\" when using standard routes that implement the necessary interfaces and base classes.\n\n### Conclusion\n\nIn this chapter, we briefly explored `PredictiveBackRoute`, an interface that enables routes to participate in platform-specific interactive back gestures like Android's predictive back. We learned that it defines methods for handling the start, update, cancel, and commit phases of the gesture, and that base classes like `TransitionRoute` implement this interface to provide the core logic for controlling the route's animation based on user input. By using routes that implement `PredictiveBackRoute` (like `MaterialPageRoute`), you automatically get support for these modern navigation features on supporting platforms.\n\nIn the next chapter, we'll look at [LocalHistoryRoute](07_localhistoryroute_.md), a mixin that allows routes to handle some \"back\" actions internally without actually popping the route from the navigator stack.\n\n[Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md)\n---\n# Chapter 7: LocalHistoryRoute\n\nWelcome back, future Flutter expert! In our previous chapters, we've climbed the `Route` hierarchy, learning about animated transitions ([TransitionRoute](02_transitionroute_.md)), layered overlays ([OverlayRoute](03_overlayroute_.md)), and modal experiences ([ModalRoute](04_modalroute_.md)), even touching on predictive back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)). Our mental model has been a stack of full playing cards, where \"back\" always means peeling off the top card to reveal the one below.\n\nBut what if you're on a single screen (one card), and within that screen, you perform a few actions that feel like mini-navigations, but you don't want to fully leave that screen? Imagine a search feature within a product details page. You:\n\n1.  Are viewing product details.\n2.  Tap a search icon within that page.\n3.  A search bar appears on the *same* page, and you start typing.\n4.  As you type, search results appear, perhaps covering the main product details.\n5.  You tap a result, maybe showing a mini-preview, still within this screen.\n\nNow, what happens if you press the back button? You probably don't want to go *all the way back* to the list of products. You likely want to:\n\n1.  Hide the mini-preview.\n2.  Hide the search results.\n3.  Hide the search bar, returning to the original product details view.\n4.  *Then*, if you press back again, you go back to the product list.\n\nThis is where `LocalHistoryRoute` comes in! It allows a single [Route](01_route_.md) (or rather, a `ModalRoute` that uses the `LocalHistoryRoute` *mixin*) to manage its *own* mini-stack of pop-like behaviors without involving the main [Navigator](03_overlayroute_.md) stack.\n\n### What is a LocalHistoryRoute?\n\nA `LocalHistoryRoute` is not a separate type of route in the same way that [ModalRoute](04_modalroute_.md) is a separate type from [OverlayRoute](03_overlayroute_.md). Instead, it's a **mixin**. Think of a mixin as a set of extra powers or abilities you can *add* to an existing class. `LocalHistoryRoute` adds the ability to handle \"back\" actions *locally*, within that route itself, instead of letting the [Navigator](03_overlayroute_.md) pop the entire route off the stack.\n\nSpecifically, `ModalRoute` uses ([mixes in](04_modalroute_.md)) the `LocalHistoryRoute` capabilities. This means any `ModalRoute` (including common ones like `MaterialPageRoute`) can have its own *local history*.\n\nImagine your single screen (the playing card) can have sticky notes attached to its *front*. When you add a sticky note (like showing a search bar), you're adding an entry to the screen's \"local history.\" When you press back, instead of removing the entire card, the screen checks its sticky notes. If there's a sticky note, it removes the top sticky note (hiding the search bar) and stays on the same card. Only when all sticky notes are gone does the next back press remove the main card.\n\n### Why Use LocalHistoryRoute?\n\nUsing `LocalHistoryRoute` (by adding entries to the local history of a `ModalRoute`) is essential for implementing UI patterns where a \"back\" action within a screen should reverse a temporary state change or overlay *before* navigating away from that screen.\n\nThis provides a more intuitive and consistent user experience, especially on platforms where the hardware or OS back button is commonly used. You keep the user focused on the current screen until they've finished the sub-tasks (like search or filtering) they started within it.\n\n### Key Concepts of LocalHistoryRoute\n\n`LocalHistoryRoute` introduces a simple mechanism:\n\n*   **Local History Entry (`LocalHistoryEntry`):** This is the core concept! It's an object representing a single \"step\" in the route's local history. You add these entries when you perform an action that should be reversible by a local back press (e.g., showing an overlay, expanding a section).\n*   **`onRemove` callback:** Each `LocalHistoryEntry` has an optional `onRemove` callback. This function is called when that specific history entry is removed (when the user performs a local back action that corresponds to this entry). This is where you put the code to *undo* the action associated with this entry (e.g., hide the search results, close the search bar).\n*   **Adding Entries (`addLocalHistoryEntry`):** Routes that use the mixin (`LocalHistoryRoute`) have a method to add a new `LocalHistoryEntry` to their history stack. The most recently added entry is at the top.\n*   **Handling Pop (`didPop` & `willHandlePopInternally`):** The `LocalHistoryRoute` mixin overrides the route's `didPop` method. When the [Navigator](03_overlayroute_.md) tries to pop the route, the `LocalHistoryRoute` checks its local history. If there are entries, it *doesn't* let the [Navigator](03_overlayroute_.md) pop the main route. Instead, it removes the last `LocalHistoryEntry` and calls its `onRemove` callback. Only if the local history is empty does it allow the `Navigator` to proceed with popping the main route. The `willHandlePopInternally` getter also reflects this state; it returns `true` if there are local history entries, indicating that the route will handle the pop itself.\n\nEssentially, the `LocalHistoryRoute` mixin intercept's the `Navigator`'s `pop` command when the route has local history entries, handles it internally by removing an entry, and then tells the `Navigator` \"No, I wasn't popped, I handled it.\"\n\n### How LocalHistoryRoute Works (Conceptual)\n\nLet's trace the playing card example with a local search feature using `LocalHistoryRoute`.\n\n**Scenario 1: Adding a Local History Entry (Showing Search)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant SearchOverlay as Search Overlay Widget\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>Routeroute: Tap Search Icon\n    Routeroute->>SearchOverlay: Show Search Overlay Widget\n    Routeroute->>LocalHistoryEntry: Create Local History Entry\n    Routeroute->>Routeroute: Add Local History Entry to local history stack\n    Routeroute-->>User: Screen now shows Search Overlay\n```\n\nThe key here is that tapping the search icon doesn't push a new route. It changes the UI *within* the current route and adds a marker (`LocalHistoryEntry`) to the route's internal history list.\n\n**Scenario 2: Pressing Back (Local Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It's NOT empty)\n    Routeroute->>LocalHistoryEntry: Remove top Local History Entry\n    Routeroute->>LocalHistoryEntry: Call onRemove() callback (...which hides the Search Overlay)\n    Routeroute-->>Navigator: Returns 'false' (claiming it was NOT popped)\n    Navigator-->>User: Navigator stays on the same route; User sees Product Details again.\n```\n\nWhen back is pressed, the `Navigator` asks the route to pop. But the route, thanks to the mixin, sees a `LocalHistoryEntry` and *doesn't* let the `Navigator` pop it. Instead, it handles the \"pop\" locally by removing the entry and triggering its `onRemove` callback, which reverses the local UI change.\n\n**Scenario 3: Pressing Back Again (Full Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route (Product List)\n\n    User->>OS: Press Back Button (Local history is now EMPTY)\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It IS empty)\n    Routeroute-->>Navigator: Returns 'true' (allowing Navigator to pop)\n    Navigator->>Routeroute: Disposes Route (conceptually after animation)\n    Navigator->>Navigator: Pops Routeroute from stack\n    Navigator-->>User: User now sees Product List\n```\n\nWith the local history empty, when back is pressed again, the route's `didPop` sees the empty list and *does* return `true`, indicating that it allowed itself to be popped. The `Navigator` then proceeds with removing the route from its stack.\n\n### Looking at the Code\n\nLet's examine the relevant parts of the `LocalHistoryRoute` mixin definition.\n\n```dart\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  void addLocalHistoryEntry(LocalHistoryEntry entry) { /* ... adds to _localHistory ... */ }\n\n  /// Remove a local history entry from this route.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) { /* ... removes from _localHistory and calls onRemove */ }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop; // Indicate that this route will handle the pop internally.\n    }\n    return super.popDisposition; // Let the base class decide (usually allows Navigator pop).\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      // ... cleanup and call entry._notifyRemoved() which calls onRemove ...\n      return false; // IMPORTANT: Return false to tell Navigator it was NOT popped\n    }\n    return super.didPop(result); // Local history empty, let the base class handle the pop.\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty; // True if local history exists.\n  }\n}\n```\n\nKey things to note:\n\n*   `mixin LocalHistoryRoute<T> on Route<T>`: This confirms it's a mixin that can only be applied to classes that are (or inherit from) `Route<T>`.\n*   `_localHistory`: A private list that stores the `LocalHistoryEntry` objects. It acts as the local history stack.\n*   `addLocalHistoryEntry(LocalHistoryEntry entry)`: Adds an entry to the `_localHistory` list.\n*   `removeLocalHistoryEntry(LocalHistoryEntry entry)`: Removes a specific entry (you might call this if a local state change is reversed by something other than a back button).\n*   `popDisposition`: Overridden to return `RoutePopDisposition.pop` if `willHandlePopInternally` is true, signaling that the route will handle the pop itself.\n*   `didPop(T? result)`: This is the crucial override. It checks if `_localHistory` is empty. If not, it removes the last entry, calls its `onRemove` callback, and returns `false`. Returning `false` signifies to the [Navigator](03_overlayroute_.md) that this route *was not* removed from the stack. If `_localHistory` *is* empty, it calls `super.didPop`, letting the base `Route` (and thus the [Navigator](03_overlayroute_.md)) handle the pop.\n*   `willHandlePopInternally`: This getter returns `true` if there are any local history entries, informing potentially other parts of the framework (like an `AppBar` which might decide to show a back button or not) that the route has internal pop handling.\n\nNow let's look at the `LocalHistoryEntry` itself:\n\n```dart\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n```\n\nHere:\n\n*   `LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true})`: The constructor takes an optional `onRemove` callback.\n*   `onRemove`: The function that gets called when this specific entry is popped from the local history.\n*   `impliesAppBarDismissal`: A flag that affects whether an `AppBar` automatically shows a back button. If a route has local history entries where this is true, the `AppBar` might show a back button, even if the route isn't truly `canPop` from the `Navigator`'s perspective.\n\n### Example: Implementing Local History for Search\n\nLet's build a conceptual example showing how you'd use `LocalHistoryRoute` (via a `ModalRoute` subclass like `MaterialPageRoute`) to implement the local search functionality we discussed.\n\nWe'll create a simple screen that shows content, and tapping a button adds a \"search bar\" overlay and a local history entry. Tapping back will hide the search bar.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// This widget represents our screen that we push as a route.\nclass ProductDetailsScreen extends StatefulWidget {\n  const ProductDetailsScreen({super.key});\n\n  @override\n  State<ProductDetailsScreen> createState() => _ProductDetailsScreenState();\n}\n\nclass _ProductDetailsScreenState extends State<ProductDetailsScreen> {\n  // State to control the visibility of the \"search bar\" overlay.\n  bool _showSearchBar = false;\n\n  // The LocalHistoryEntry we'll manage. We need to keep a reference\n  // so we can potentially remove it explicitly if needed (though pop handles it).\n  LocalHistoryEntry? _searchHistoryEntry;\n\n  // Function to show the search bar and add a local history entry.\n  void _activateSearch() {\n    // If the search bar is already shown, do nothing.\n    if (_showSearchBar) {\n      return;\n    }\n    setState(() {\n      _showSearchBar = true;\n    });\n\n    // Get the current ModalRoute for this screen.\n    // MaterialPageRoute is a ModalRoute, so this works.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    // Create a new LocalHistoryEntry.\n    _searchHistoryEntry = LocalHistoryEntry(\n      // When this entry is removed (via local pop), this function is called.\n      onRemove: () {\n        // Hide the search bar.\n        setState(() {\n          _showSearchBar = false;\n        });\n        // Clear our reference to the entry.\n        _searchHistoryEntry = null;\n      },\n      // Setting this to true means the AppBar might show a back button\n      // while the search bar is visible.\n      impliesAppBarDismissal: true,\n    );\n\n    // Add the entry to the current route's local history.\n    modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!);\n\n    print('Search activated, LocalHistoryEntry added.');\n  }\n\n  // Function to explicitly close the search bar (e.g., tapping an 'x' button).\n  void _deactivateSearch() {\n     if (!_showSearchBar || _searchHistoryEntry == null) {\n       return;\n     }\n     // Removing the entry manually also calls its onRemove callback\n     // which will hide the search bar.\n     _searchHistoryEntry!.remove();\n     print('Search deactivated, LocalHistoryEntry removed manually.');\n   }\n\n\n  @override\n  Widget build(BuildContext context) {\n    // Getting the ModalRoute here makes the widget rebuild if the route's\n    // properties related to ModalRoute.of change (like canPop, isCurrent).\n    // This is often how widgets react to route changes.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Product Details'),\n        // AppBar automatically uses ModalRoute.of(context).willHandlePopInternally\n        // (or popDisposition indirectly) and impliesAppBarDismissal\n        // to decide whether to show a back button.\n      ),\n      body: Stack( // Use a Stack to layer the search bar on top\n        children: [\n          // Main product details content\n          Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Text('Product Details Go Here'),\n                const SizedBox(height: 20),\n                ElevatedButton(\n                  onPressed: _activateSearch, // Button to trigger local navigation\n                  child: const Text('Show Search (Local)'),\n                ),\n                 // Example of a widget that might disappear on local pop\n                if (_showSearchBar)\n                 Padding(\n                    padding: const EdgeInsets.only(top: 20.0),\n                    child: Text('Search Results Placeholder...'),\n                 ),\n              ],\n            ),\n          ),\n\n          // The \"search bar\" overlay, conditionally visible\n          if (_showSearchBar)\n            Positioned( // Position on top\n              top: 0,\n              left: 0,\n              right: 0,\n              child: Container(\n                color: Colors.white,\n                 padding: const EdgeInsets.symmetric(horizontal: 8.0),\n                 child: Row(\n                    children: [\n                       Expanded(\n                          child: TextField(\n                             decoration: InputDecoration(hintText: 'Search...'),\n                             autofocus: true,\n                          ),\n                       ),\n                       IconButton(\n                           icon: Icon(Icons.close),\n                           onPressed: _deactivateSearch, // Explicit close button\n                       ),\n                    ],\n                 ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const ProductDetailsScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have a `ProductDetailsScreen` StatefulWidget.\n2.  We use a boolean `_showSearchBar` to control the visibility of our pseudo-search overlay.\n3.  When the \"Show Search\" button is pressed (`_activateSearch`):\n    *   We set `_showSearchBar` to `true`, making the search UI visible.\n    *   We get the current `ModalRoute.of(context)`. Since `MaterialPageRoute` is a `ModalRoute`, this gives us the route object for this screen.\n    *   We create a `LocalHistoryEntry`. Its `onRemove` callback sets `_showSearchBar` back to `false`.\n    *   We call `modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!)` to add the entry to the route's local history list.\n4.  Now, if you press the device's back button:\n    *   The `Navigator` receives the pop request.\n    *   It calls `didPop` on our `MaterialPageRoute`.\n    *   The `MaterialPageRoute` (thanks to the `LocalHistoryRoute` mixin) sees that its local history (`_localHistory`) is not empty.\n    *   It removes the `_searchHistoryEntry` from its `_localHistory`.\n    *   It calls the `onRemove` callback of that `_searchHistoryEntry`.\n    *   The `onRemove` callback fires, setting `_showSearchBar = false`, which hides the search UI.\n    *   The `didPop` method returns `false` to the `Navigator`.\n    *   The `Navigator` does *not* pop the `ProductDetailsScreen`.\n5.  If you press back again:\n    *   The `Navigator` calls `didPop` again.\n    *   The route's local history is now empty.\n    *   `didPop` calls `super.didPop`, which allows the standard route popping mechanism to happen.\n    *   The `ProductDetailsScreen` is popped, and you return to the previous full screen.\n\nThe `impliesAppBarDismissal: true` on the `LocalHistoryEntry` hints to the `AppBar` that it should show a back button. When the local history is empty, the base route's `willHandlePopInternally` becomes false, and the `AppBar` correctly reflects that the next back press will pop the whole route.\n\n### Conclusion\n\nIn this chapter, we explored `LocalHistoryRoute`, not a direct route class, but a powerful mixin used by `ModalRoute` to enable routes to manage their own internal history of pop-like behaviors. We learned how `LocalHistoryEntry` with its `onRemove` callback serves as the mechanism for capturing reversible state changes within a single screen, and how the mixin intercepts the `Navigator`'s pop requests to handle them locally when history entries exist. Understanding `LocalHistoryRoute` is crucial for building intuitive navigation flows where a back press within a screen should undo a temporary UI change before exiting the screen entirely.\n\nIn the next chapter, we will discuss [PopEntry](08_popentry_.md), a more modern way to declaratively manage pop behavior within a route's widget subtree.\n\n[Chapter 8: PopEntry](08_popentry_.md)\n---\n# Chapter 8: PopEntry\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md), we learned how a single route could manage its own \"mini-history\" using `LocalHistoryEntry` to handle back presses internally, perfect for showing/hiding overlays or sections within a screen without leaving it.\n\nNow, let's introduce `PopEntry`. This is a newer and often more declarative way to manage if a route can be popped and to react when it *is* popped. Think of it as putting special \"stickers\" onto a playing card ([ModalRoute](04_modalroute_.md)) that can either stick the card to the stack (preventing the pop) or react when the card finally gets removed.\n\n### What is a PopEntry?\n\nA `PopEntry` is a simple object that you can associate with a [ModalRoute](04_modalroute_.md). It holds two key pieces of information:\n\n1.  **Can Pop:** Whether this specific entry thinks the route can currently be popped.\n2.  **On Pop Invoked:** A function (`onPopInvokedWithResult`) to call when the route is popped (or a pop is attempted and blocked).\n\nImagine your [ModalRoute](04_modalroute_.md) (the playing card) can have multiple stickers (`PopEntry`s) stuck to it by different parts of your screen's UI (like different widgets). Before the card can be removed (popped), *every* sticker must agree that it's okay to remove the card. If even one sticker says \"No, don't pop yet!\" then the card stays. If all stickers say \"Yes, go ahead!\", the card can be popped. When the card *is* removed, *every* sticker gets notified.\n\nThis is the mechanism used by the modern `PopScope` widget. When you use `PopScope` inside a route, it often works by creating a `PopEntry` and registering it with the [ModalRoute](04_modalroute_.md) that contains it.\n\nCommon use cases for `PopEntry` (often via `PopScope`):\n\n*   **Blocking pops with unsaved data:** If the user is editing a form, you can create a `PopEntry` that says the route *cannot* be popped while there are unsaved changes.\n*   **Showing a confirmation dialog:** When a pop is attempted but blocked (because a `PopEntry` said no), you can use the `onPopInvokedWithResult` callback of that `PopEntry` to show a \"Discard changes?\" dialog.\n*   **Reacting to a pop:** Even if you don't block the pop, a `PopEntry`'s `onPopInvokedWithResult` can be used to perform cleanup or other actions just before or after the route is popped.\n\n### Why Use PopEntry?\n\n`PopEntry` provides a more structured and explicit way to manage pop behavior compared to the older `WillPopCallback`s (though those are still supported for compatibility and specific advanced cases).\n\n*   **Declarative:** Widgets like `PopScope` make it easy to declare pop behavior right where the relevant UI lives, creating a `PopEntry` under the hood.\n*   **Multiple handlers:** Several `PopEntry` instances can be registered with a single route, each controlling its own `canPop` status and reacting to pop attempts independently. The route's overall `canPop` becomes the logical AND of all registered `PopEntry`s.\n*   **Rich callback:** The `onPopInvokedWithResult` callback provides information about whether the pop *actually* happened (`didPop` boolean) and the `result` the route was popped with, allowing for more nuanced reactions.\n\n### Key Concepts of PopEntry\n\n*   **`canPopNotifier`:** This is a `ValueListenable<bool>`. When its value is `true`, this `PopEntry` contributes to the route being potentially pop-able. When it's `false`, this entry signals \"do not pop.\" The route listens to this notifier and updates its own `canPop` status accordingly.\n*   **`onPopInvokedWithResult(bool didPop, T? result)`:** This callback is triggered whenever a pop is attempted on the route, regardless of whether it was successfully popped or blocked.\n    *   `didPop`: `true` if the route *was* actually popped and removed from the navigator stack; `false` if the pop was blocked (e.g., by a `PopEntry` or [LocalHistoryRoute](07_localhistoryroute_.md)).\n    *   `result`: The value the route was popped with (if `didPop` is true).\n*   **Registering/Unregistering:** A `PopEntry` must be registered with its containing [ModalRoute](04_modalroute_.md) using `modalRoute.registerPopEntry()` and unregistered using `modalRoute.unregisterPopEntry()` when it's no longer needed (typically handled automatically by widgets like `PopScope`).\n\n### How PopEntry Works (Conceptual)\n\nLet's see how a Route with a several PopEntries (stickers) behaves when a pop is attempted.\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (ModalRoute)\n    participant PopEntry1 as PopEntry 1 (Form)\n    participant PopEntry2 as PopEntry 2 (Editing)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>CurrentRoute: Check popDisposition\n    CurrentRoute->>PopEntry1: Check canPopNotifier.value (e.g., is Form clean?)\n    CurrentRoute->>PopEntry2: Check canPopNotifier.value (e.g., is Editing complete?)\n\n    alt Both PopEntry1 and PopEntry2 can pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.pop\n        Navigator->>CurrentRoute: Call didPop(...)\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: true, ...)\n        Navigator->>Navigator: Pops CurrentRoute\n        Navigator-->>User: Previous screen visible\n    else At least one PopEntry cannot pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.doNotPop\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: false, ...)\n        User-->>App: Route remains on screen\n        Note right of User: Might show dialog in callback\n    end\n```\n\n1.  The user initiates a back action.\n2.  The OS notifies the [Navigator](03_overlayroute_.md).\n3.  The [Navigator](03_overlayroute_.md) consults the current route's `popDisposition`.\n4.  The route's `popDisposition` (specifically, the `ModalRoute` implementation using the `LocalHistoryRoute` mixin logic, which also checks registered `PopEntry`s) iterates through its registered `PopEntry` instances and reads their `canPopNotifier.value`.\n5.  If *all* `PopEntry`s return `true` (and there's no [LocalHistoryRoute](07_localhistoryroute_.md) blocking it), the `popDisposition` signals that the route *can* be popped. The [Navigator](03_overlayroute_.md) proceeds with popping the route. After or during the animation, the route's `onPopInvokedWithResult` method is called with `didPop: true`. This cascades to calling `onPopInvokedWithResult` on all registered `PopEntry`s with `didPop: true`.\n6.  If *any* `PopEntry` returns `false`, the `popDisposition` signals `RoutePopDisposition.doNotPop`. The [Navigator](03_overlayroute_.md) *does not* pop the route off the stack. The route's `onPopInvokedWithResult` method is called with `didPop: false`, which cascades to all registered `PopEntry`s calling their `onPopInvokedWithResult` with `didPop: false`. This is where a `PopEntry` might trigger a confirmation dialog.\n\n### Looking at the Code\n\nLet's look at the `PopEntry` definition itself.\n\n```dart\nabstract class PopEntry<T> {\n  // ... deprecated onPopInvoked ...\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  // ... toString ...\n}\n```\nThis abstract class defines the two key parts: the getter for `canPopNotifier` and the abstract method `onPopInvokedWithResult` that subclasses must implement.\n\nNow, let's look at how `ModalRoute` uses `PopEntry` (from the provided snippet):\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  // ... other properties and methods ...\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{}; // Stores registered entries\n\n  // ... willPop (deprecated) ...\n\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      if (!popEntry.canPopNotifier.value) { // Check each entry's canPopNotifier\n        return RoutePopDisposition.doNotPop; // If any is false, block the pop\n      }\n    }\n\n    return super.popDisposition; // If all can pop, let the base (LocalHistoryRoute) decide\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      popEntry.onPopInvokedWithResult(didPop, result); // Call callback on each entry\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry); // Add to the set of entries\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification); // Listen for canPop changes\n    _maybeDispatchNavigationNotification(); // Trigger notification after adding\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry); // Remove from the set\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification); // Stop listening\n    _maybeDispatchNavigationNotification(); // Trigger notification after removing\n  }\n\n  // ... more code ...\n}\n```\nHere, we see:\n*   `_popEntries`: A `Set` within `ModalRoute` to keep track of all the `PopEntry` instances that have been registered with this route.\n*   `popDisposition`: This overridden getter now explicitly loops through `_popEntries`. If *any* `PopEntry`'s `canPopNotifier.value` is `false`, it immediately returns `RoutePopDisposition.doNotPop`, effectively blocking the pop. If the loop completes (all `canPopNotifier.value`s were true), it then asks `super.popDisposition` (which handles the `LocalHistoryRoute` logic) whether the pop should happen or be handled locally.\n*   `onPopInvokedWithResult`: This overridden method simply iterates through the registered `_popEntries` and calls `onPopInvokedWithResult` on each one, passing the same `didPop` and `result` arguments.\n*   `registerPopEntry` and `unregisterPopEntry`: These methods manage adding/removing entries from the `_popEntries` set. They also add/remove a listener to the `PopEntry`'s `canPopNotifier` so that the route can react when a `PopEntry`'s `canPop` status changes (`_maybeDispatchNavigationNotification` is called to potentially notify listeners like the `AppBar`).\n\n### Example: Using PopScope (Which Uses PopEntry)\n\nYou overwhelmingly interact with `PopEntry` through the `PopScope` widget. `PopScope` is a simple widget that wraps another widget and automatically creates, registers, and unregisters a `PopEntry` with the nearest [ModalRoute](04_modalroute_.md).\n\nHere's how you'd use `PopScope` to prevent navigating away from a screen with unsaved changes without a confirmation:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass EditItemScreen extends StatefulWidget {\n  const EditItemScreen({super.key});\n\n  @override\n  State<EditItemScreen> createState() => _EditItemScreenState();\n}\n\nclass _EditItemScreenState extends State<EditItemScreen> {\n  // State to track if there are unsaved changes\n  bool _hasUnsavedChanges = false;\n\n  // ValueNotifier for PopScope's canPop property\n  // PopScope will automatically wrap this in a PopEntry's canPopNotifier\n  final ValueNotifier<bool> _canPop = ValueNotifier<bool>(true); // Start as pop-able\n\n  @override\n  void dispose() {\n    _canPop.dispose(); // Clean up the notifier\n    super.dispose();\n  }\n\n  void _onTextFieldChanged(String text) {\n    // If the text changes, there are unsaved changes\n    final bool hasChanges = text.isNotEmpty; // Simplified check\n    if (_hasUnsavedChanges != hasChanges) {\n      setState(() {\n        _hasUnsavedChanges = hasChanges;\n        // Update the ValueNotifier based on changes\n        _canPop.value = !_hasUnsavedChanges; // Can pop IF there are NO unsaved changes\n      });\n    }\n  }\n\n  // This callback is called when a pop is invoked, regardless of whether it succeeds.\n  void _onPopInvoked(bool didPop) {\n    print('onPopInvoked called: didPop = $didPop');\n    if (didPop) {\n      // Route was successfully popped - maybe do cleanup here\n       print('Route was popped.');\n    } else {\n      // Pop was blocked (because _canPop.value was false) - show a dialog\n      print('Pop was blocked. Showing confirmation dialog...');\n      _showDiscardChangesDialog();\n    }\n  }\n\n  // Show a dialog asking the user if they want to discard changes\n  Future<void> _showDiscardChangesDialog() async {\n    final bool? discard = await showDialog<bool>(\n      context: context,\n      builder: (BuildContext dialogContext) {\n        return AlertDialog(\n          title: const Text('Discard Changes?'),\n          content: const Text('You have unsaved changes. Do you want to discard them?'),\n          actions: <Widget>[\n            TextButton(\n              child: const Text('Cancel'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(false); // Don't discard\n              },\n            ),\n            TextButton(\n              child: const Text('Discard'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(true); // Discard changes\n              },\n            ),\n          ],\n        );\n      },\n    );\n\n    if (discard == true) {\n      // User chose to discard changes - allow the pop now\n      // This must be done AFTER the dialog is dismissed\n       Navigator.of(context).pop();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Wrap the entire screen content in PopScope\n    return PopScope(\n      canPop: _canPop.value, // Control pop-ability using your state\n      onPopInvoked: _onPopInvoked, // Handle pop attempts\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Edit Item'),\n          // AppBar's back button respects the route's popDisposition,\n          // which is influenced by PopScope's canPop.\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              TextField(\n                decoration: const InputDecoration(labelText: 'Item Name'),\n                onChanged: _onTextFieldChanged, // Listen for changes\n              ),\n              const SizedBox(height: 20),\n              Text(\n                _hasUnsavedChanges ? 'You have unsaved changes.' : 'No unsaved changes.',\n                style: TextStyle(color: _hasUnsavedChanges ? Colors.red : Colors.green),\n              ),\n              // Save button (example, not fully implemented pop logic here)\n               // ElevatedButton(\n               //   onPressed: _hasUnsavedChanges ? () {\n               //      // Save logic... then maybe Navigator.of(context).pop(true);\n               //      // After saving, _hasUnsavedChanges would become false,\n               //      // making canPop true again for future back presses.\n               //   } : null,\n               //   child: const Text('Save'),\n               // ),\n            ],\n          ),\n        ),\n      ),\n     );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const EditItemScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have an `EditItemScreen` that uses a boolean `_hasUnsavedChanges` and a `ValueNotifier<bool> _canPop` to manage its state.\n2.  The `_onTextFieldChanged` method updates `_hasUnsavedChanges` and, crucially, updates `_canPop.value`. When there are unsaved changes, `_canPop.value` becomes `false`.\n3.  The entire `Scaffold` is wrapped in a `PopScope`.\n4.  `PopScope`'s `canPop` property is bound to `_canPop.value`. When `_canPop.value` is false, `PopScope` configures the underlying `PopEntry`'s notifier to be false, telling the route \"Don't pop yet!\".\n5.  `PopScope`'s `onPopInvoked` property is set to our `_onPopInvoked` method.\n6.  When the user presses the back button while `_hasUnsavedChanges` is true:\n    *   The [Navigator](03_overlayroute_.md) initiates a pop.\n    *   The route checks its `popDisposition`.\n    *   The `PopScope`'s underlying `PopEntry` contributes `false` to the check.\n    *   The route's `popDisposition` returns `RoutePopDisposition.doNotPop`.\n    *   The [Navigator](03_overlayroute_.md) *does not* pop the route.\n    *   The route calls `onPopInvokedWithResult(didPop: false, result: null)` on all registered `PopEntry`s.\n    *   Our `_onPopInvoked` method is called with `didPop: false`.\n    *   Inside `_onPopInvoked`, since `didPop` is false, we show the \"Discard Changes?\" dialog.\n    *   If the user chooses \"Discard\", the dialog pops with `true`. We then *manually* call `Navigator.of(context).pop()` again. This time, because we're leaving, we'd typically save or discard changes such that `_hasUnsavedChanges` would be false, making `_canPop.value` true *before* this second pop attempt is processed, and the route *can* be popped.\n\nThis demonstrates how `PopScope` (and thus `PopEntry` underneath) provides a clean way to intercept and react to back navigation based on your screen's state.\n\n### Conclusion\n\nIn this chapter, we introduced `PopEntry`, a modern abstraction to declaratively manage a route's pop behavior and react to pop events. We learned that `PopEntry`s, often created by the `PopScope` widget, use a `canPopNotifier` to signal whether a route should currently be allowed to pop and an `onPopInvokedWithResult` callback to handle the outcome of a pop attempt. Understanding `PopEntry` illuminates how widgets like `PopScope` provide powerful control over navigation within your Flutter applications.\n\nIn the next chapter, we'll explore `RouteAware` and `RouteObserver`, which allow widgets to be notified when the route they are in changes state (e.g., when it becomes the top-most route or is covered by another route).\n\n[Chapter 9: RouteAware](09_routeaware_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 9: RouteAware\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 9: RouteAware\n\nWelcome back, future Flutter expert! We've been learning a lot about how Flutter stacks up screens like playing cards ([Route](01_route_.md)s), adding cool animations ([TransitionRoute](02_transitionroute_.md)), layering content on top ([OverlayRoute](03_overlayroute_.md), [ModalRoute](04_modalroute_.md), [PopupRoute](05_popuproute_.md)), handling fancy back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)), and even managing mini-histories within a single screen ([LocalHistoryRoute](07_localhistoryroute_.md), [PopEntry](08_popentry_.md)).\n\nNow, imagine you have a little widget on one of these screens, and this widget needs to know *when* its screen becomes the main focus, or when another screen covers it up, or when its screen is completely removed. For instance, maybe a video player widget on a screen needs to pause the video when another screen pops up, and resume when its screen becomes fully visible again.\n\nThat's where `RouteAware` comes in! It's a way for widgets to \"listen\" for what's happening to the route (screen) they are a part of.\n\n### What is a RouteAware?\n\nThink of a `RouteAware` as a gadget you plug into a widget. This gadget lets the widget receive special messages (notifications) whenever the screen it lives on changes its visibility state relative to the top of the navigation stack.\n\nThese messages tell the widget:\n\n*   \"Your screen is now the very top screen, the user can see and interact with only your screen.\" (`didPopNext` - implies the route *above* it was popped)\n*   \"Your screen just got pushed onto the stack and is now the top screen.\" (`didPush`)\n*   \"Your screen is no longer the top screen because a new screen was pushed on top of it.\" (`didPushNext`)\n*   \"Your screen was completely removed from the navigation stack (like hitting back when it was the first screen).\" (`didPop`)\n\nTo get these messages, your widget needs to somehow register itself with something that *knows* about route changes. This \"something\" is usually a [RouteObserver](10_routeobserver_.md) (which we'll cover in the next chapter).\n\n### Why Use RouteAware?\n\nAs mentioned in the intro, listening to route changes is useful for managing state or behavior in response to navigation. Common scenarios include:\n\n*   **Pausing/resuming animations or media playback:** Stop a video when covered, resume when visible.\n*   **Saving/loading state:** Maybe save temporary data when the screen is about to be covered.\n*   **Tracking analytics:** Log when a screen becomes fully visible.\n*   **Managing resources:** Release resources when a screen is hidden and reallocate them when it becomes active again.\n\nInstead of constantly checking the [Navigator](03_overlayroute_.md) state, a `RouteAware` widget simply defines methods that get called when specific navigation events happen to its route.\n\n### Key Concepts of RouteAware\n\n`RouteAware` is actually a **mixin**. Remember, a mixin is like adding extra abilities to a class. By mixing `RouteAware` into your `State` class for a stateful widget, you give that state object the ability to implement and respond to the specific `RouteAware` methods.\n\nThe key concept is the set of methods it adds:\n\n*   **`didPopNext()`:** Called when the route on top of this route is popped, making this route visible again.\n*   **`didPush()`:** Called when this route is pushed onto the navigator.\n*   **`didPop()`:** Called when this route is popped off the navigator.\n*   **`didPushNext()`:** Called when a new route has been pushed on top of this this route.\n\nYour widget's `State` class will mix in `RouteAware` and provide the code inside these methods to react to the events.\n\n### How RouteAware Works (Conceptual)\n\nHere's a simplified look at how a widget using `RouteAware` gets notified, involving a `RouteObserver`.\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Navigator as Navigator\n    participant RouteObserver as Route Observer\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n    participant WidgetA as Widget A (RouteAware)\n    participant WidgetB as Widget B (RouteAware)\n\n    Setup->>RouteObserver: Create Route Observer and give it to Navigator\n    WidgetA->>RouteObserver: Subscribe Widget A to Screen A Route\n    WidgetB->>RouteObserver: Subscribe Widget B to Screen B Route (currently not on stack)\n\n    User->>Navigator: Push ScreenABtn (pushes Screen B Route)\n    Navigator->>RouteObserver: Notify didPush(Screen B), previousRoute: Screen A\n    RouteObserver->>WidgetB: Calls didPush() (enters)\n    RouteObserver->>WidgetA: Calls didPushNext() (covered)\n\n    User->>Navigator: Press Back Btn (Pops Screen B Route)\n    Navigator->>RouteObserver: Notify didPop(Screen B), previousRoute: Screen A\n    RouteObserver->>WidgetB: Calls didPop() (exits)\n    RouteObserver->>WidgetA: Calls didPopNext() (becomes visible again)\n```\n\n1.  You create a `RouteObserver` and provide it to your app's `Navigator` (or `MaterialApp`/`CupertinoApp` using the `navigatorObservers` property).\n2.  Inside your `StatefulWidget`'s `State` (that mixes in `RouteAware`), in the `init` method, you use the `RouteObserver` to **subscribe** this `State` object to notifications for *its* route (`ModalRoute.of(context)`).\n3.  When navigation happens (push, pop), the `Navigator` notifies the `RouteObserver`.\n4.  The `RouteObserver` looks at which routes were involved and calls the appropriate `RouteAware` methods (`didPushNext`, `didPopNext`, `didPop`, `didPush`) on the widgets it knows are subscribed to those routes.\n5.  In the `dispose` method of your `State`, you **unsubscribe** from the `RouteObserver` to prevent memory leaks.\n\nThe key enabler here is the [RouteObserver](10_routeobserver_.md) (next chapter!), which sits in the middle, tracking navigation and calling the `RouteAware` methods on subscribed widgets.\n\n### Looking at the Code\n\nLet's look at the definition of the `RouteAware` mixin.\n\n```dart\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {} // Implies route below this one IS being popped and this is about to become active.\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {} // Implies this route IS being popped (removed).\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n```\n\nAs you can see, it's an abstract mixin with four empty methods. You provide the implementation when you mix it into your `State` class.\n\n### Example: A Widget Aware of Route Changes\n\nLet's create a simple widget that changes the text it displays based on whether its screen is the top-most route.\n\n```dart\nimport 'package:flutter/material.dart'; // For MaterialPageRoute and MaterialApp\nimport 'package:flutter/widgets.dart'; // For State, StatefulWidget\n\n// We'll need a RouteObserver. You typically create this ONCE for your app.\n// For simplicity, let's create it here. Usually, it would be higher up,\n// like in your MaterialApp or a Provider.\nfinal RouteObserver<ModalRoute<dynamic>> routeObserver = RouteObserver<ModalRoute<dynamic>>();\n\n// This is the screen that contains our RouteAware widget.\nclass TrackedScreen extends StatelessWidget {\n  const TrackedScreen({super.key, required this.screenName});\n\n  final String screenName;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('$screenName Screen')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Our RouteAware widget lives here\n            RouteAwareWidget(\n              key: ValueKey(screenName), // Give it a key to differentiate instances\n              routeObserver: routeObserver, // Pass the observer\n              screenName: screenName, // Pass screen name for context\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              // Button to push a new screen on top\n              onPressed: () {\n                Navigator.of(context).push(\n                  MaterialPageRoute(\n                    builder: (context) => TrackedScreen(screenName: '${screenName} Child'),\n                  ),\n                );\n              },\n              child: const Text('Push New Screen on Top'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Our custom widget that is aware of its route's state\nclass RouteAwareWidget extends StatefulWidget {\n  const RouteAwareWidget({\n    super.key,\n    required this.routeObserver, // Requires the RouteObserver\n    required this.screenName,\n  });\n\n  final RouteObserver<ModalRoute<dynamic>> routeObserver;\n  final String screenName;\n\n  @override\n  State<RouteAwareWidget> createState() => _RouteAwareWidgetState();\n}\n\n// Mixin RouteAware into the State class\nclass _RouteAwareWidgetState extends State<RouteAwareWidget> with RouteAware {\n\n  String _status = 'Initializing...';\n\n  // Get the route this widget is in\n  ModalRoute<dynamic>? get _route => ModalRoute.of(context);\n\n  @override\n  void initState() {\n    super.initState();\n    // We can't subscribe here because the ModalRoute might not be available yet\n    // or the observer isn't ready. Do it in didChangeDependencies.\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // Get the route object and subscribe to the observer\n    // Check if _route is not null and the route has changed since the last call\n    final ModalRoute<dynamic>? newRoute = _route; // Get current route\n    final ModalRoute<dynamic>? oldRoute = ModalRoute.of(context, listen: false); // Get previous route without subscribing\n\n    if (newRoute != null && newRoute != oldRoute) { // Only subscribe if route is valid and has changed\n        widget.routeObserver.subscribe(this, newRoute); // THIS is the important part!\n        // Update status based on initial state (when didChangeDependencies is first called after push)\n        _updateStatus(newRoute.isCurrent ? 'pushed (active)' : 'pushed (covered)');\n    }\n  }\n\n\n  @override\n  void dispose() {\n    // ALWAYS unsubscribe when the widget is removed from the tree\n    widget.routeObserver.unsubscribe(this); // Clean up!\n    super.dispose();\n  }\n\n  // --- RouteAware Methods Start ---\n\n  // Called when the route on top of this route is popped\n  @override\n  void didPopNext() {\n    // Route below this one became visible\n    _updateStatus('Became active (didPopNext)');\n  }\n\n  // Called when this route has been pushed\n  // Note: For the initial push, this might be called before didChangeDependencies\n  // where we subscribe. didChangeDependencies is a safer place for initial status check.\n  @override\n  void didPush() {\n    // This route came into view.\n    // _updateStatus('Became active (didPush)'); // Often called before subscription, less reliable for first state\n  }\n\n\n  // Called when this route has been popped\n  @override\n  void didPop() {\n    // This route is leaving.\n    _updateStatus('Was popped (didPop)');\n  }\n\n  // Called when a new route has been pushed on top of this route\n  @override\n  void didPushNext() {\n    // This route is now covered.\n    _updateStatus('Became inactive (didPushNext)');\n  }\n\n  // --- RouteAware Methods End ---\n\n  void _updateStatus(String status) {\n    // Update the widget's state to show the status\n    if (mounted) { // Make sure the widget is still in the tree\n      setState(() {\n        _status = status;\n      });\n       print('[${widget.screenName}] $_status'); // Log to console\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Widget in \"${widget.screenName}\" - Status: $_status');\n  }\n}\n\n// To run this example, you'd set up your MaterialApp with the observer:\n// MaterialApp(\n//   home: const TrackedScreen(screenName: 'Home'),\n//   navigatorObservers: [routeObserver], // Add your observer here!\n// );\n\n```\n\nExplanation:\n\n1.  We create a global `RouteObserver` instance. You'd pass this to your `MaterialApp` or `CupertinoApp` via `navigatorObservers`.\n2.  `TrackedScreen` is a simple wrapper, pushing more `TrackedScreen`s when a button is tapped.\n3.  `RouteAwareWidget` is our custom widget. Its `_RouteAwareWidgetState` mixes in `RouteAware`.\n4.  The `_route` getter helps us easily access the `ModalRoute` this widget is inside.\n5.  Crucially, in `didChangeDependencies`, we get the `_route` and call `widget.routeObserver.subscribe(this, newRoute)`. This registers `this` state object (`RouteAware`) with the observer for the `newRoute` object. We also update the initial status.\n6.  In `dispose`, we call `widget.routeObserver.unsubscribe(this)` to stop receiving notifications and allow the state and its resources to be properly garbage collected.\n7.  We implement the four `RouteAware` methods (`didPopNext`, `didPush`, `didPop`, `didPushNext`). Inside these, we simply update a status string and print to the console so you can see when they are called.\n8.  The `_updateStatus` helper is used to safely update the state and print logs.\n\nWhen you run this and navigate:\n\n*   Pushing \"Home\": `[Home] pushed (active)` (from didChangeDependencies)\n*   Tapping \"Push New Screen\": `[Home] Became inactive (didPushNext)` printed for the Home screen's widget, then `[Home Child] pushed (active)` (from didChangeDependencies) printed for the new screen's widget.\n*   Tapping \"Push New Screen\" again: `[Home Child] Became inactive (didPushNext)` for the second screen's widget, then `[Home Child Child] pushed (active)` for the third screen's widget.\n*   Pressing Back: `[Home Child Child] Was popped (didPop)` for the third screen's widget, then `[Home Child] Became active (didPopNext)` for the second screen's widget.\n*   Pressing Back again: `[Home Child] Was popped (didPop)` for the second screen's widget, then `[Home] Became active (didPopNext)` for the first screen's widget.\n\nThis demonstrates how the `RouteAware` methods are called as screens are pushed and popped on top of the widget's route.\n\n### Conclusion\n\nIn this chapter, we explored `RouteAware`, a mixin that allows Flutter widgets to receive notifications about changes to the visibility status of the route they belong to. We learned about the four key methods (`didPush`, `didPop`, `didPushNext`, `didPopNext`) that get called in response to navigation events. We also saw conceptually how `RouteAware` works together with a [RouteObserver](10_routeobserver_.md) (which we'll dive into next) to deliver these notifications, and how to use `didChangeDependencies` and `dispose` to subscribe and unsubscribe. Understanding `RouteAware` is essential for building widgets that need to react to navigation lifecycle events.\n\nIn the next chapter, we'll look at [RouteObserver](10_routeobserver_.md), the class that tracks navigation and dispatches these `RouteAware` notifications.\n\n[Chapter 10: RouteObserver](10_routeobserver_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"RouteObserver\n\". This is Chapter 10.\n\nConcept Details:\n- Name: RouteObserver\n\n- Description:\nImagine a watchful person who keeps track of which playing cards are being added or removed from the stack. A `RouteObserver` does this for your app's navigation. You can register other parts of your app (like widgets that are \"RouteAware\") with the observer, and it will tell them when their corresponding screen is about to appear, disappear, or become the top card.\n\n\nComplete Tutorial Structure:\n1. [Route\n](01_route_.md)\n2. [TransitionRoute\n](02_transitionroute_.md)\n3. [OverlayRoute\n](03_overlayroute_.md)\n4. [ModalRoute\n](04_modalroute_.md)\n5. [PopupRoute\n](05_popuproute_.md)\n6. [PredictiveBackRoute\n](06_predictivebackroute_.md)\n7. [LocalHistoryRoute\n](07_localhistoryroute_.md)\n8. [PopEntry\n](08_popentry_.md)\n9. [RouteAware\n](09_routeaware_.md)\n10. [RouteObserver\n](10_routeobserver_.md)\n\nContext from previous chapters:\n# Chapter 1: Route\n\nWelcome to the first chapter of our Flutter tutorial on navigation! In this chapter, we're going to talk about a fundamental concept in Flutter: the `Route`.\n\nImagine you're using a phone app, like a social media app or a shopping app. You start on a main screen, maybe a feed of posts or a list of products. When you tap on a post to see more details or tap on a product to see its description, you move to a new screen. Then, when you want to go back, you tap a back button and you're back on the previous screen.\n\nIn Flutter, each one of these screens is often represented by something called a `Route`. Think of it like a destination you can navigate to within your app.\n\n### What is a Route?\n\nLet's use an analogy. Imagine you have a stack of cards. Each card in this stack represents a different screen or page in your app. A `Route` is like a single card in this stack. It knows what content (widgets) should be displayed for that specific screen.\n\nWhen you navigate to a new screen in your app, it's like pushing a new card onto the top of the stack. The new card (the new `Route`) is now visible.\n\nWhen you go back to the previous screen, it's like taking the top card off the stack. The card below it (the previous `Route`) becomes visible again.\n\nThe component in Flutter that manages this stack of `Route`s is called the [Navigator](03_navigator.md). We'll learn more about the [Navigator](03_navigator.md) later, but for now, just know that it's what handles showing and hiding these \"cards\" (your `Route`s).\n\n### Why do we need Routes?\n\nUsing `Route`s helps us organize our app's screens and manage navigation between them. Instead of having one giant piece of code for your entire app, you break it down into smaller, manageable `Route`s, each responsible for a single screen. This makes your code easier to understand, maintain, and test.\n\n### How to Use a Simple Route (Conceptually)\n\nWhile you don't often create a base `Route` directly, you work with subclasses of `Route` that add more functionality. A common way to define a simple screen is using a `MaterialPageRoute` (which is a type of [ModalRoute](04_modalroute_.md), and [TransitionRoute](02_transitionroute_.md), which inherits from [OverlayRoute](03_overlayroute_.md), which inherits from `Route`!). Don't worry about all the subclasses for now, we'll cover them in later chapters. Let's look at a very basic example of how you might define a simple screen conceptually using something like a `MaterialPageRoute`.\n\nImagine we have a simple app with two screens: `HomePage` and `SecondPage`.\n\nHere's a conceptual look at how you might define the `SecondPage` as a route:\n\n```dart\n// This is an abstract representation and not the actual code you write directly for Route.\n// You'll use subclasses like MaterialPageRoute.\n\n// Represents our Second Page screen content.\nclass SecondPageContent extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Second Page')),\n      body: Center(child: Text('Welcome to the Second Page!')),\n    );\n  }\n}\n\n// Conceptually, how the SecondPage could be represented as a Route.\n// In reality, you'd use a MaterialPageRoute or similar.\nclass SecondPageRoute /* extends Route */ {\n  Widget buildPageContent(BuildContext context) {\n    return SecondPageContent();\n  }\n}\n```\n\nThis isn't the exact code you'd use for a base `Route`, but it illustrates the idea: a `Route` is associated with the content of a screen.\n\nNow, let's think about how the [Navigator](03_navigator.md) uses these `Route`s like a stack of cards.\n\n### The Route Stack with Navigator\n\nWhen you start your app, the first screen ([Route](01_route_.md)) is pushed onto the [Navigator](03_navigator.md)'s stack.\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant HomePageRoute as Home Page Route\n\n    App->>Navigator: Start App\n    Navigator->>HomePageRoute: Create Home Page Route\n    Navigator->>Navigator: Push Home Page Route onto stack\n```\n\nThen, when you navigate from `HomePage` to `SecondPage`, the [Navigator](03_navigator.md) pushes the `SecondPage`'s `Route` onto the stack.\n\n```mermaid\nsequenceDiagram\n    participant HomePage as Home Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    HomePage->>Navigator: Navigate to Second Page\n    Navigator->>SecondPageRoute: Create Second Page Route\n    Navigator->>Navigator: Push Second Page Route onto stack\n```\n\nNow, the `SecondPage` `Route` is at the top of the stack and is visible to the user.\n\nWhen you tap the back button, the [Navigator](03_navigator.md) pops the top `Route` (the `SecondPage` `Route`) off the stack.\n\n```mermaid\nsequenceDiagram\n    participant SecondPage as Second Page\n    participant Navigator as Navigator\n    participant SecondPageRoute as Second Page Route\n\n    SecondPage->>Navigator: Tap Back Button\n    Navigator->>SecondPageRoute: Dispose Second Page Route (conceptually)\n    Navigator->>Navigator: Pop Second Page Route from stack\n```\n\nAnd now, the `HomePage` `Route` is at the top of the stack again, and you see the home screen.\n\n### Looking at the Code (Briefly)\n\nLet's take a peek at the actual Flutter code for the base `Route` class (from the provided snippet). Don't worry if this looks complex; we're just highlighting a few key things.\n\n```dart\nabstract class Route<T> extends Listenable {\n  // ... other properties and methods ...\n\n  /// Called when this route is pushed onto the navigator.\n  @protected\n  TickerFuture didPush() { /* ... */ }\n\n  /// Called when this route is popped.\n  @mustCallSuper\n  bool didPop(T? result) { /* ... */ }\n\n  // ... more code ...\n}\n```\n\nEven in this simplified view, you can see methods like `didPush()` and `didPop()`. These are methods that the [Navigator](03_navigator.md) calls on a `Route` when it's pushed onto or popped off the stack. This allows a `Route` to react to these navigation events if needed.\n\nThe `<T>` in `<T> extends Listenable` means that a `Route` (and its subclasses) can have a return type. When a route is popped, it can optionally return a value back to the route that launched it. For example, you might have a screen to select an item from a list, and when you pop that screen, you return the selected item.\n\n### Conclusion\n\nIn this chapter, we introduced the concept of a `Route` in Flutter navigation. We learned that a `Route` represents a screen or destination in your app and how the [Navigator](03_navigator.md) manages a stack of these `Route`s to handle navigation. While you usually work with subclasses of `Route`, understanding the basic idea of a `Route` as a screen in a stack is crucial for understanding how navigation works in Flutter.\n\nIn the next chapter, we'll dive into [TransitionRoute](02_transitionroute_.md), a type of `Route` that adds animations when you navigate between screens.\n\n[Chapter 2: TransitionRoute](02_transitionroute_.md)\n---\n# Chapter 2: TransitionRoute\n\nWelcome back! In the last chapter, [Chapter 1: Route](01_route_.md), we learned that a [Route](01_route_.md) in Flutter is like a card in a stack, representing a screen in your app. When you navigate, you're essentially pushing or popping these cards from the [Navigator](03_navigator.md)'s stack.\n\nBut if you've ever used an app, you know that switching between screens isn't usually just an instant swap. Screens often smoothly slide in, fade out, or have other cool visual effects. That's where `TransitionRoute` comes in.\n\n### What is a TransitionRoute?\n\nImagine those cards we talked about. A `TransitionRoute` is like a special animated card. When you add (push) a `TransitionRoute` onto the stack, it doesn't just appear; it animates into view. Similarly, when you remove (pop) it, it animates out of view.\n\nIt's like adding visual flair to your navigation! These animations make moving between screens feel more natural and engaging for the user.\n\n### Why Use TransitionRoute?\n\nWhile `TransitionRoute` is an abstract class you don't use directly, understanding it helps you understand the animation behavior of common Flutter routes like `MaterialPageRoute` (which we'll see in a later chapter, [Chapter 4: ModalRoute](04_modalroute_.md)). These common routes *are* `TransitionRoute`s under the hood, inheriting its animation capabilities.\n\nUsing routes that handle transitions automatically saves you a lot of work. Instead of manually animating every screen change, the `TransitionRoute` does it for you based on its definition.\n\n### Key Concepts of TransitionRoute\n\nLet's look at some core ideas that make `TransitionRoute` work:\n\n*   **Animations:** `TransitionRoute` manages two main animations:\n    *   The **primary animation**: This animation controls how *this* route enters or exits the screen. It typically goes from 0.0 to 1.0 when the route is pushed and 1.0 to 0.0 when it's popped.\n    *   The **secondary animation**: This animation controls how the *previous* route (the one below this one in the stack) reacts when this route is pushed on top of it, or how the *next* route (the one pushed on top of this one) reacts when it's popped. This allows routes to coordinate their transitions.\n\n*   **Transition Duration:** A `TransitionRoute` defines how long its animations should take when going forwards ([`transitionDuration`](#transitionDuration)) and backwards ([`reverseTransitionDuration`](#reverseTransitionDuration)).\n\n*   **Opaque:** Some routes, like a full-screen page, cover everything below them. These are called \"opaque\" routes. `TransitionRoute` has a property ([`opaque`](#opaque)) to indicate this. When an opaque route is fully visible, the routes below it don't need to be built, which can save performance.\n\n### How TransitionRoute Works (Conceptually)\n\nLet's go back to our card stack analogy, but now with animated cards.\n\nWhen you push a `TransitionRoute` (`Screen B Route`) onto the stack which already contains a `TransitionRoute` (`Screen A Route`):\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Push Screen B Route\n    Navigator->>ScreenBRoute: Create Screen B Route\n    Navigator->>ScreenARoute: Notify Screen A Route About Next Route\n    Navigator->>ScreenBRoute: Notify Screen B Route About Previous Route\n    Navigator->>ScreenBRoute: Push Screen B Route onto stack\n    Navigator->>ScreenBRoute: Start primary animation (0.0 -> 1.0)\n    Navigator->>ScreenARoute: Start secondary animation (0.0 -> 1.0)\n    ScreenBRoute-->>App: Animates into view\n    ScreenARoute-->>App: Animates away (optionally)\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 0.0 (fully hidden or partially visible depending on the type of transition) to 1.0 (fully visible).\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` as `Screen B` covers it.\n\nWhen you pop `Screen B Route`:\n\n```mermaid\nsequenceDiagram\n    participant App as App\n    participant Navigator as Navigator\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n\n    App->>Navigator: Pop Screen B Route\n    Navigator->>ScreenBRoute: Start primary animation (1.0 -> 0.0)\n    Navigator->>ScreenARoute: Start secondary animation (1.0 -> 0.0)\n    ScreenBRoute-->>App: Animates out of view\n    ScreenARoute-->>App: Animates back (optionally)\n    Navigator->>ScreenBRoute: Dispose Screen B Route (after animation)\n    Navigator->>ScreenARoute: Notify Screen A Route that next is null\n\n```\n\nDuring this animation:\n\n*   `Screen B Route`'s primary animation is running from 1.0 to 0.0, animating it out.\n*   `Screen A Route`'s secondary animation is running, potentially animating `Screen A` back into its full state as `Screen B` is removed.\n\nThe `TransitionRoute` handles linking these animations together, so the pushing and popping feel smooth.\n\n### Looking at the Code\n\nLet's peek at the `TransitionRoute` code definition from the provided snippet. Again, don't feel pressured to understand every detail, but observe the parts that relate to animation:\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other properties and methods ...\n\n  /// The duration the transition going forwards.\n  Duration get transitionDuration;\n\n  /// The duration the transition going in reverse.\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// Whether the route obscures previous routes when the transition is complete.\n  bool get opaque;\n\n  // ... other properties and methods ...\n\n  /// The animation that drives the route's transition...\n  Animation<double>? get animation;\n\n  /// The animation for the route being pushed on top of this route.\n  Animation<double>? get secondaryAnimation;\n\n  // ... more code ...\n\n  @override\n  TickerFuture didPush(); // Called when pushed, starts forward animation\n\n  @override\n  bool didPop(T? result); // Called when popped, starts reverse animation\n\n  // ... more code ...\n}\n```\n\nHere we see the properties we discussed: `transitionDuration`, `reverseTransitionDuration`, `opaque`, `animation`, and `secondaryAnimation`. The `didPush` and `didPop` methods are where the `TransitionRoute` typically tells its animation controller to start the transition animation.\n\nYou also see that `TransitionRoute` `extends OverlayRoute<T>`, which means it's a type of [OverlayRoute](03_overlayroute_.md). We'll learn more about [OverlayRoute](03_overlayroute_.md) in the next chapter, but for now, know that [OverlayRoute](03_overlayroute_.md)s display their content in the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md), which is necessary for animations and showing overlays like modal barriers.\n\n### Example (Conceptual)\n\nWhile we won't write a full `TransitionRoute` from scratch (you usually work with subclasses), let's see conceptually how a simple fade transition might be described within a `TransitionRoute` structure.\n\nImagine a `FadePageRoute` which is a `TransitionRoute`. It would define how its page content fades in and out.\n\n```dart\n// This is a conceptual example, not actual Flutter code for a bare TransitionRoute.\n// You'd use a subclass like ModalRoute or PageRouteBuilder.\n\nclass FadePageRoute extends TransitionRoute<void> {\n\n  // This would be the widget for the screen content.\n  final Widget pageContent;\n\n  FadePageRoute({required this.pageContent});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // Fade in 300ms\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // Fade out 300ms\n\n  @override\n  bool get opaque => false; // A fade transition isn't opaque until fully visible.\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // In a real TransitionRoute/OverlayRoute, this would create the\n    // OverlayEntry that holds the transition and the page content.\n    // We'll see OverlayEntry in the next chapter.\n    return []; // Simplified for this conceptual example\n  }\n\n  // Conceptual: This is where you'd build the transition widget.\n  // The 'animation' here is the primary animation for THIS route.\n  Widget buildTransition(BuildContext context, Animation<double> animation) {\n    // Use the animation to control the opacity.\n    return FadeTransition(\n      opacity: animation, // Drives the fade animation\n      child: pageContent, // The actual screen content\n    );\n  }\n\n  // In a real TransitionRoute, you'd implement methods like buildPage\n  // and buildTransitions as part of a ModalRoute subclass.\n  // For simplicity, we just show the transition idea.\n}\n```\n\nIn a real Flutter app, when you use a route like `MaterialPageRoute`, it internally uses the `animation` and `secondaryAnimation` provided by its `TransitionRoute` foundation to create the Material Design animated transitions (like sliding in from the side). You provide the `pageContent`, and the `MaterialPageRoute` (which is a `TransitionRoute`) handles the animation around it using its `buildTransitions` method.\n\n### Conclusion\n\nIn this chapter, we explored the concept of `TransitionRoute`, the foundation for animated screen transitions in Flutter navigation. We learned how it manages primary and secondary animations to create smooth visual effects when navigating between screens, how it defines transition durations, and the meaning of the `opaque` property. Understanding `TransitionRoute` is key to understanding how common routes like `MaterialPageRoute` provide their built-in animations.\n\nIn the next chapter, we'll look at [OverlayRoute](03_overlayroute_.md), which is another layer routes use to display themselves within the [Navigator](03_navigator.md)'s [Overlay](03_overlayroute_.md).\n\n[Chapter 3: OverlayRoute](03_overlayroute_.md)\n---\n# Chapter 3: OverlayRoute\n\nWelcome back, future Flutter expert! In the last chapter, [Chapter 2: TransitionRoute](02_transitionroute_.md), we saw how a `TransitionRoute` adds cool animations when you switch screens, making your app feel smooth.\n\nNow, sometimes you don't want to completely *replace* the current screen like a new card on the stack. Instead, you want to put something *on top* of it, maybe a small pop-up message or a menu, while still being able to see or interact with the screen underneath. That's where `OverlayRoute` comes in!\n\n### What is an OverlayRoute?\n\nLet's go back to our playing card analogy. An `OverlayRoute` is like a special, transparent card you place on top of the existing stack. You can usually see through parts of this transparent card to the cards below. This is different from a regular route that acts like a solid card, completely covering whatever is beneath it.\n\nThink of it like putting a sticky note or a transparent sheet with some information on top of a page in a book. The original page is still there, and you can see it, but there's a new layer on top.\n\nCommon examples of things that use `OverlayRoute` include:\n\n*   **Dialogs:** Those small boxes that pop up to ask you a question or show important information.\n*   **Pop-up Menus:** Menus that appear when you tap a button, floating over the content.\n*   **Bottom Sheets:** Panels that slide up from the bottom of the screen.\n\nThese elements don't take over the whole screen, but they still need to be on top and often prevent interaction with the content below.\n\n### Why Use OverlayRoute?\n\n`OverlayRoute` is a crucial piece of the puzzle for displaying widgets that aren't part of the main screen layout but need to appear above everything else within the [Navigator](03_navigator_.md)'s view. It uses a special helper called an `OverlayEntry` to actually place its widgets on top of the existing routes in the [Navigator](03_.overlayroute_.md)'s [Overlay](03_.overlayroute_.md).\n\nYou won't usually create a raw `OverlayRoute` yourself. Instead, you'll use subclasses that build upon `OverlayRoute`'s capabilities, like [ModalRoute](04_modalroute_.md), which adds features like modal barriers (the dimming effect behind a dialog).\n\n### Key Concepts of OverlayRoute\n\n*   **Overlay:** The [Navigator](03_overlayroute_.md) has an `Overlay` widget which acts like a layered canvas. `OverlayEntry`s are placed into this `Overlay` to display content on top of other things.\n*   **OverlayEntry:** This is the piece that holds the widget you want to display on top. An `OverlayRoute` creates and manages one or more `OverlayEntry`s.\n*   **Transparency:** The key characteristic of an `OverlayRoute` is its ability to be non-opaque, meaning you can potentially see through it to the routes below.\n\n### How OverlayRoute Works (Conceptually)\n\nWhen an `OverlayRoute` (like a dialog route) is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Overlay Route (Dialog Route)\n    Navigator->>OverlayRoute: Create Overlay Route\n    OverlayRoute->>OverlayEntry: Create Overlay Entry\n    OverlayEntry->>Navigator: Ask Navigator for Overlay\n    Navigator->>Overlay: Add Overlay Entry to Overlay\n    Overlay->>App: Draw Overlay Entry (Dialog) on top\n\n```\n\nThe `OverlayRoute` calculates what it needs to display (like the dialog box and the dimming barrier) and creates `OverlayEntry` objects for them. These `OverlayEntry`s are then added to the [Navigator](03_overlayroute_.md)'s `Overlay`. The `Overlay` renders these entries on top of all the other routes currently in the stack.\n\nWhen the `OverlayRoute` is popped (the dialog is dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant OverlayRoute as Overlay Route\n    participant OverlayEntry as Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog/Tap OK\n    App->>Navigator: Pop Overlay Route\n    Navigator->>OverlayRoute: Pop Overlay Route\n    OverlayRoute->>OverlayEntry: Dispose Overlay Entry\n    OverlayEntry->>Overlay: Request removal from Overlay\n    Overlay->>Navigator: Remove Overlay Entry\n    Navigator->>OverlayRoute: Dispose Overlay Route (conceptually)\n\n```\n\nThe `OverlayRoute` disposes of its `OverlayEntry` objects, which tells the `Overlay` to remove them. The content disappears from the screen, and you can interact with the routes below again.\n\n### Looking at the Code\n\nLet's look at the provided code snippet for the `OverlayRoute` class.\n\n```dart\nabstract class OverlayRoute<T> extends Route<T> {\n  // ... other properties and methods ...\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  // ... more code ...\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n```\n\nKey things to notice:\n\n*   `abstract class OverlayRoute<T> extends Route<T>`: This tells us that `OverlayRoute` is a type of [Route](01_route_.md) and means you can't create an instance of it directly. It's a base class for other route types.\n*   `Iterable<OverlayEntry> createOverlayEntries()`: This is an abstract method that subclasses must implement. This method is where the subclass defines what `OverlayEntry` (or entries) it needs to create to display its content.\n*   `List<OverlayEntry> get overlayEntries`: This property holds the actual `OverlayEntry` objects that the route creates.\n*   `install()`: When the route is installed (added to the [Navigator](03_overlayroute_.md)), it calls `createOverlayEntries()` to get the `OverlayEntry` list.\n*   `dispose()`: When the route is disposed, it makes sure to dispose of its `OverlayEntry` objects too, cleaning them up from the `Overlay`.\n\nThis structure ensures that subclasses provide the necessary content (through `createOverlayEntries`) and that the base `OverlayRoute` handles the creation and cleanup of these `OverlayEntry`s within the [Navigator](03_overlayroute_.md)'s `Overlay`.\n\n### Example (Conceptual)\n\nLet's imagine a very simple `SimplePopupRoute` that shows a text message on top of everything.\n\n```dart\n// This is a simplified conceptual example, not real code for a direct OverlayRoute.\n// You'd typically extend ModalRoute which extends OverlayRoute.\n\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/animation.dart'; // For Animation\n\nclass SimplePopupRoute extends OverlayRoute<void> {\n\n  final String message;\n\n  SimplePopupRoute({required this.message});\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    // This route creates one OverlayEntry to display its content.\n    return [\n      OverlayEntry(\n        // The builder function gets called by the Overlay to create the widget.\n        builder: (BuildContext context) {\n          return Center(\n            child: Card( // Simple card background\n              child: Padding(\n                padding: const EdgeInsets.all(16.0),\n                child: Text(message), // Display the message\n              ),\n            ),\n          );\n        },\n      ),\n    ];\n  }\n\n  // Overlay routes often need animations, so methods from TransitionRoute\n  // would be implemented in a subclass like ModalRoute or PopupRoute.\n  // For this simple conceptual example, we'll skip explicit transition details.\n\n  // In a real scenario extending ModalRoute, you'd implement methods\n  // like barrierColor, barrierDismissible, and buildPage/buildTransitions.\n\n  @override\n  bool get opaque => false; // It's a pop-up, so it's not fully opaque.\n\n  @override\n  bool get maintainState => true; // Keep the state of the route below it.\n\n  // These are abstract in OverlayRoute and implemented in subclasses:\n  // @override\n  // Duration get transitionDuration => Duration.zero; // Example: no transition easily here\n\n  // @override\n  // String? get barrierLabel => 'Dismiss popup'; // Example for accessibility\n\n  // @override\n  // Color? get barrierColor => Colors.black54; // Example for dimming\n\n  // @override\n  // bool get barrierDismissible => true; // Example: allow tapping outside to dismiss\n\n}\n```\n\nIn this conceptual example, the `SimplePopupRoute` implements `createOverlayEntries` and returns a list containing a single `OverlayEntry`. The `OverlayEntry`'s `builder` function creates the actual widget (`Center` > `Card` > `Padding` > `Text`) that appears as the popup.\n\nWhen you push this route onto the [Navigator](03_overlayroute_.md), the `OverlayRoute` framework ensures that this `OverlayEntry` gets added to the [Navigator](03_overlayroute_.md)'s `Overlay`, making the popup visible on top of the current screen.\n\n### Conclusion\n\nIn this chapter, we introduced `OverlayRoute`, the abstraction that allows routes to display content on top of other routes within the [Navigator](03_overlayroute_.md)'s `Overlay`. We learned that it uses `OverlayEntry` to place its widgets and is the foundation for elements like dialogs and pop-up menus that don't replace the whole screen. While you typically work with subclasses rather than `OverlayRoute` directly, understanding its role is essential for grasping how these temporary, layered UI elements work in Flutter navigation.\n\nIn the next chapter, we'll delve into [ModalRoute](04_modalroute_.md), a very common type of route that builds upon `OverlayRoute` and `TransitionRoute` to provide features like modal barriers and easy integration with standard page transitions.\n\n[Chapter 4: ModalRoute](04_modalroute_.md)\n---\n# Chapter 4: ModalRoute\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 3: OverlayRoute](03_overlayroute_.md), we learned how `OverlayRoute` allows us to display widgets on top of existing screens without replacing them entirely, kind of like putting a transparent layer on your playing cards. This is great for things like pop-ups.\n\nBut what about those times when you want to show something like a full-screen page *over* the previous one, but still indicate that the previous page is there in the background, maybe by dimming it? You also want to prevent the user from tapping on anything in the background. That's exactly what `ModalRoute` helps us with!\n\n### What is a ModalRoute?\n\nA `ModalRoute` is a specific and very common type of route in Flutter that creates a \"modal\" experience. Imagine you have your deck of playing cards ([Route](01_route_.md) stack). When you push a `ModalRoute` onto the stack, it's like putting a semi-transparent sheet over your playing cards. This sheet is called a **modal barrier**.\n\nHere's what the modal barrier does:\n\n1.  **Visual Indication:** It often slightly dims or blurs the screens below, making it clear that the new content is the primary focus.\n2.  **Interaction Blocker:** It prevents you from touching or interacting with anything on the screens underneath it.\n3.  **Dismissal:** Often, tapping this modal barrier dismisses the `ModalRoute` (like tapping outside a dialog to close it).\n\nSo, a `ModalRoute` isn't just about putting something *on top* like an `OverlayRoute`; it's about putting something *on top* with a special \"modal\" behavior that focuses the user's attention and blocks background interaction.\n\nCommon examples of things built using `ModalRoute` include:\n\n*   **Dialogs:** The confirmation boxes or alert messages you see.\n*   **Bottom Sheets:** Panels that slide up from the bottom (like the share sheet on your phone).\n*   **Full-screen Modals:** Sometimes used for creating or editing items where you want a clear separation from the main flow.\n*   **`MaterialPageRoute`:** One of the most common routes for navigating between full-screen pages in Material Design apps, it is a subclass of `ModalRoute`.\n\n### Why Use ModalRoute?\n\n`ModalRoute` provides the built-in mechanism for managing the modal barrier and handling its behavior (like tapping to dismiss). It also inherits the animation capabilities from `TransitionRoute` and the overlay management from `OverlayRoute`. This makes it the perfect foundation for creating screens and pop-ups that need this modal behavior.\n\nInstead of building the dimming and tap-blocking logic yourself, you use a `ModalRoute` (or a route that extends `ModalRoute`) and configure its properties.\n\n### Key Concepts of ModalRoute\n\nBuilding on the concepts from [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md), here are the key things that distinguish `ModalRoute`:\n\n*   **Modal Barrier:** This is the defining feature. It's the visual overlay (often dimmed) that blocks interaction with routes below. `ModalRoute` handles creating and managing this barrier using an `OverlayEntry`.\n*   **`barrierDismissible`:** A property that controls whether tapping the modal barrier will automatically pop (dismiss) the route.\n*   **`barrierColor`:** The color to use for the modal barrier (often a semi-transparent black). If `null`, there's no visible barrier.\n*   **`barrierLabel`:** A semantic label for the barrier, important for accessibility (for screen readers).\n*   **Inherits Transitions:** Since it extends `TransitionRoute`, `ModalRoute` has the `animation` and `secondaryAnimation` properties and methods like `buildTransitions` to handle animated entrances and exits.\n*   **Inherits Overlay Management:** Since it extends `OverlayRoute`, `ModalRoute` creates and manages `OverlayEntry`s to display its content and the modal barrier in the [Navigator](03_overlayroute_.md)'s `Overlay`.\n*   **`buildPage` vs `buildTransitions`:** `ModalRoute` clearly separates the task of building the *content* of the screen (`buildPage`) from building the *animations* around that content (`buildTransitions`). `buildPage` is typically called once when the route is first built, while `buildTransitions` is called more frequently as the animation progresses.\n\n### How ModalRoute Works (Conceptually)\n\nWhen a `ModalRoute` is pushed onto the [Navigator](03_overlayroute_.md)'s stack:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show dialog)\n    App->>Navigator: Push Modal Route (Dialog Route)\n    Navigator->>ModalRoute: Create Modal Route\n    ModalRoute->>BarrierEntry: Create Barrier Overlay Entry (calls buildModalBarrier)\n    ModalRoute->>PageEntry: Create Page Overlay Entry (calls buildPage & buildTransitions)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PageEntry->>Navigator: Add Page Entry to Overlay\n    Navigator->>Overlay: Draw Barrier and Page on top\n    Navigator->>ModalRoute: Start Entry Transition (calls buildTransitions)\n    ModalRoute-->>App: Animates into view (Barrier fades, Page slides/fades)\n\n```\n\nHere's what's happening:\n\n1.  The `ModalRoute` is created.\n2.  It implements `createOverlayEntries()` (from `OverlayRoute`) to create *two* main `OverlayEntry`s: one for the **modal barrier** and one for the **page content** itself.\n3.  The `buildModalBarrier()` method is called to create the barrier widget.\n4.  The `buildPage()` method is called to create the main content widget of the route.\n5.  The `buildTransitions()` method is called, which wraps the content returned by `buildPage` with transition widgets driven by the route's `animation` and `secondaryAnimation`.\n6.  These two `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`. Crucially, the modal barrier `OverlayEntry` is positioned *below* the page content `OverlayEntry` in the `Overlay` stack.\n7.  The transition animation (`animation`) starts. The barrier's opacity animates from transparent to the `barrierColor`, and the page content animates according to `buildTransitions`.\n\nWhen the `ModalRoute` is popped (dismissed):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant ModalRoute as Modal Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PageEntry as Page Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap outside dialog / Tap Close / Tap Back Button\n    App->>Navigator: Pop Modal Route\n    Navigator->>ModalRoute: Start Exit Transition\n    ModalRoute-->>App: Animates out of view (Barrier fades out, Page slides/fades out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PageEntry: Dispose Page Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Page\n    Navigator->>ModalRoute: Dispose Modal Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, fading the barrier out and animating the page content away. Once the animation is complete, the `OverlayEntry`s for the barrier and the page are disposed, removing them from the `Overlay`, and you see the previous route again. `ModalRoute` manages this whole process.\n\n### Looking at the Code\n\nLet's examine relevant parts of the `ModalRoute` class definition from the provided snippet.\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  // ... other properties and methods ...\n\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  bool get barrierDismissible;\n\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  Color? get barrierColor;\n\n  /// The semantic label used for a dismissible barrier.\n  String? get barrierLabel;\n\n  /// The curved that is used for animating the modal barrier in and out.\n  Curve get barrierCurve => Curves.ease;\n\n  /// Whether the route should remain in memory when it is inactive.\n  bool get maintainState;\n\n  // ... The API for subclasses to override ...\n\n  /// Override this method to build the primary content of this route.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child; // Default is no transition\n  }\n\n  // ... The API for subclasses to override - used by this class ...\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  Widget buildModalBarrier() { /* ... default implementation using AnimatedModalBarrier ... */ }\n\n  // ... Internals ...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope, // This builds the page content and transitions\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  // ... more code ...\n}\n```\n\nNotice these key points:\n\n*   `extends TransitionRoute<T> with LocalHistoryRoute<T>`: It inherits all the animation features of `TransitionRoute` and capabilities related to local history from `LocalHistoryRoute`.\n*   `barrierDismissible`, `barrierColor`, `barrierLabel`, `barrierCurve`: These are properties that subclasses must provide or can override to configure the modal barrier.\n*   `maintainState`: Controls whether the route's widgets are kept alive even when it's not the current screen. Important for transitions and cases where you might need to access the previous route's state.\n*   `buildPage()`: An abstract method (must be implemented by subclasses) that defines the main visual content of the route.\n*   `buildTransitions()`: Can be overridden by subclasses to wrap the `child` (the result of `buildPage`) with custom transition widgets. The default just returns the child without transitions.\n*   `buildModalBarrier()`: Can be overridden, but usually the default implementation is sufficient, using `AnimatedModalBarrier`.\n*   `createOverlayEntries()`: Overrides the `OverlayRoute` method to create *two* `OverlayEntry`s: one for the barrier (`_modalBarrier`) and one for the page content and its transitions (`_modalScope`).\n\n### Example: A Simple Custom ModalRoute (Conceptual)\n\nLet's create a very basic custom `ModalRoute` that shows a solid color dimmed barrier and some text in the center, and can be dismissed by tapping the barrier.\n\n```dart\nimport 'package:flutter/material.dart'; // For Colors and basic widgets\nimport 'package:flutter/widgets.dart'; // For abstract classes and core widgets\n// ModalRoute is in flutter/src/widgets/routes.dart, but we import material.dart\n// for convenience and common widgets like Material, Scaffold, Text, Center, etc.\n\n// Extending ModalRoute directly is advanced. Usually you'd extend PageRoute\n// (a subclass of ModalRoute) or use RouteBuilder.\n// This example is for showing ModalRoute concepts.\nclass SimpleModalRoute extends ModalRoute<void> {\n\n  final String message;\n\n  SimpleModalRoute({required this.message, super.settings});\n\n  @override\n  Duration get transitionDuration => const Duration(milliseconds: 300); // How long animations take\n\n  @override\n  Duration get reverseTransitionDuration => const Duration(milliseconds: 300); // How long reverse animations take\n\n  @override\n  bool get barrierDismissible => true; // Can tap barrier to dismiss\n\n  @override\n  Color? get barrierColor => Colors.black.withOpacity(0.5); // Semi-transparent black barrier\n\n  @override\n  String? get barrierLabel => 'Dismiss Simple Modal'; // Accessibility label\n\n  @override\n  bool get opaque => false;\n  // It's not fully opaque immediately because the barrier and content\n  // are animating in. The ModalRoute's internal logic sets opaque to true\n  // on an OverlayEntry once the animation is complete if the route is opaque.\n  // For a dialog like this, it's generally not considered fully \"opaque\" in\n  // the sense of completely covering the previous route's render object.\n\n  @override\n  bool get maintainState => true; // Keep previous route state\n\n  // This is where we build the main content of the modal screen.\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    // The actual content of your modal.\n    return Material( // Standard Material design container\n      type: MaterialType.transparency, // Don't show default Material background\n      child: Center( // Center the content\n        child: Card( // A simple card for the message\n          margin: const EdgeInsets.all(40.0),\n          child: Padding(\n            padding: const EdgeInsets.all(16.0),\n            child: Text(message), // Display the message\n          ),\n        ),\n      ),\n    );\n  }\n\n  // This is where we define entrance and exit animations around the content.\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child, // This is the widget returned by buildPage\n  ) {\n    // Use a FadeTransition for the content.\n    return FadeTransition(\n      opacity: animation, // Drive opacity with the primary animation (0.0 to 1.0)\n      child: child, // The content from buildPage\n    );\n    // We could add more complex transitions here if needed,\n    // potentially using secondaryAnimation as well.\n  }\n}\n```\n\nTo show this conceptual route, you would use `Navigator.push`:\n\n```dart\n// Assuming you are in a widget that has access to BuildContext\nElevatedButton(\n  onPressed: () {\n    Navigator.of(context).push(\n      SimpleModalRoute(message: 'This is my simple modal!'),\n    );\n  },\n  child: const Text('Show Simple Modal'),\n)\n```\n\nWhen you tap the button:\n\n1.  A `SimpleModalRoute` instance is created.\n2.  It's pushed onto the [Navigator](03_overlayroute_.md)'s stack.\n3.  `createOverlayEntries()` is called, creating an `OverlayEntry` for the barrier and an `OverlayEntry` for the page content.\n4.  The barrier `OverlayEntry`'s builder calls `buildModalBarrier()`, which creates an `AnimatedModalBarrier`. Since `barrierColor` is set, it will animate to semi-transparent black.\n5.  The page content `OverlayEntry`'s builder calls `_buildModalScope`, which internally calls `buildPage()` (to get the `Card` with the `Text`) and `buildTransitions()` (which adds a `FadeTransition` around the card).\n6.  Both `OverlayEntry`s are added to the [Navigator](03_overlayroute_.md)'s `Overlay`.\n7.  Since `buildTransitions` uses the `animation`, the `Card` widget will fade in as the route pushes.\n8.  Since `barrierDismissible` is true, tapping the semi-transparent area around the card will pop (dismiss) the route.\n\n### Conclusion\n\nIn this chapter, we explored `ModalRoute`, a crucial abstraction in Flutter navigation that provides a \"modal\" user experience. We learned how it builds upon [TransitionRoute](02_transitionroute_.md) and [OverlayRoute](03_overlayroute_.md) to add features like the modal barrier (with properties like `barrierDismissible` and `barrierColor`) and clearly separates content building (`buildPage`) from transition building (`buildTransitions`). Understanding `ModalRoute` is fundamental to working with common routes like `MaterialPageRoute` and creating your own custom modal experiences.\n\nIn the next chapter, we'll look at [PopupRoute](05_popuproute_.md), a specific type of `ModalRoute` often used for menus and other non-fullscreen overlays.\n\n[Chapter 5: PopupRoute](05_popuproute_.md)\n---\n# Chapter 5: PopupRoute\n\nWelcome back! In [Chapter 4: ModalRoute](04_modalroute_.md), we learned about `ModalRoute`, a powerful tool for creating screens or overlays that block interaction with the content below, often with a dimming \"modal barrier.\" This is perfect for full-screen pages and dialogs that demand the user's full attention.\n\nBut sometimes, you need something lighter \u2013 a small menu that pops up, an informational bubble, or a simple toast message. These aren't full-screen pages and they don't always need a heavy modal barrier. They're more like small pieces of content that temporarily appear *on top* of the current screen. That's where `PopupRoute` comes in!\n\n### What is a PopupRoute?\n\nThink of our playing cards again, representing your screens ([Route](01_route_.md)s). A `PopupRoute` is like a very specific kind of transparent card you put on top, but it only contains a *small* image or text snippet, centered or placed in a specific spot. It doesn't usually cover the whole card below, and while it's technically a type of [ModalRoute](04_modalroute_.md) (meaning it can have a barrier), that barrier is often transparent or very light, and it might not block gestures to the same extent as a full modal.\n\nThe key idea is that a `PopupRoute` is designed for temporary, often non-fullscreen, overlay content.\n\nUse cases for things that often use `PopupRoute` (or routes built on top of it) include:\n\n*   **Dropdown menus:** When you tap a button and a small list of options appears below it.\n*   **Tooltips:** The small informational boxes that appear when you long-press a UI element.\n*   **Simple Popover notifications:** Small messages that appear briefly.\n\n### Why Use PopupRoute?\n\n`PopupRoute` is a specialized type of [ModalRoute](04_modalroute_.md) that comes with some default behaviors suitable for pop-up style elements. By inheriting from [ModalRoute](04_modalroute_.md), it automatically gets the ability to be displayed in the [Navigator](03_overlayroute_.md)'s [Overlay](03_overlayroute_.md) ([OverlayRoute](03_overlayroute_.md)) and handle entrance/exit animations ([TransitionRoute](02_transitionroute_.md)).\n\nHowever, `PopupRoute` overrides some of the default `ModalRoute` properties to make it better suited for pop-ups:\n\n*   **`opaque` is `false`:** By default, pop-ups are not fully opaque. You can usually see through them to the content below, or they only cover a small area. This is different from a full-screen page route where `opaque` is usually true.\n*   **`maintainState` is `true`:** Pop-ups often appear and disappear quickly. Keeping the state of the route below them active can make transitions smoother.\n*   **`allowSnapshotting` is `false`:** Pop-up animations are typically lightweight coordinate system transitions, rather than full-screen snapshots.\n\nYou won't usually create a raw `PopupRoute` yourself. You'll typically use concrete subclasses provided by the framework or packages, or build your own custom routes that extend `PopupRoute` for specialized pop-up needs. For example, the internal routes used for `showMenu` often extend `PopupRoute`.\n\n### Key Concepts of PopupRoute\n\nSince `PopupRoute` extends [ModalRoute](04_modalroute_.md), it inherits most of its concepts like the barrier (though often transparent), dismissibility, animation, and overlay management. The main distinctions are the default values for the properties mentioned above:\n\n*   `opaque`: Defaults to `false` (not fully covering the previous route).\n*   `maintainState`: Defaults to `true` (previous route state is maintained).\n*   `allowSnapshotting`: Defaults to `false` (doesn't use snapshots for transitions).\n*   **Content Placement:** While the base `PopupRoute` doesn't dictate *where* on the screen the pop-up appears, concrete subclasses will handle positioning (e.g., relative to a button for a dropdown).\n*   **Minimal Barrier:** Often configured with a fully transparent or nearly transparent barrier or no barrier at all, as interaction blocking might not be the primary goal.\n\n### How PopupRoute Works (Conceptually simplified)\n\nLet's imagine a simple pop-up message. When a `PopupRoute` for this message is pushed:\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap button (e.g., show message)\n    App->>Navigator: Push Popup Route (Message Route)\n    Navigator->>PopupRoute: Create Popup Route\n    PopupRoute->>BarrierEntry: Create Barrier Overlay Entry (potentially transparent)\n    PopupRoute->>PopupContentEntry: Create Popup Content Overlay Entry (Message content)\n    BarrierEntry->>Navigator: Add Barrier Entry to Overlay\n    PopupContentEntry->>Navigator: Add Popup Content Entry to Overlay\n    Navigator->>Overlay: Draw Potentially Invisible Barrier and Message on top\n    Navigator->>PopupRoute: Start Entry Transition (calls buildTransitions)\n    PopupRoute-->>App: Message animates into view (fades/slides)\n\n```\n\nSimilar to a regular [ModalRoute](04_modalroute_.md), it creates `OverlayEntry`s for a barrier (even if transparent) and its content, adding them to the [Navigator](03_overlayroute_.md)'s `Overlay`. The difference is in how these entries are built and behave based on the `PopupRoute`'s default properties and the specific implementation of the pop-up itself (e.g., its size, position, and custom transitions).\n\nWhen the `PopupRoute` is popped (the message disappears or is tapped):\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant App as App\n    participant Navigator as Navigator\n    participant PopupRoute as Popup Route\n    participant BarrierEntry as Barrier Overlay Entry\n    participant PopupContentEntry as Popup Content Overlay Entry\n    participant Overlay as Overlay\n\n    User->>App: Tap away / Timer expires / Tap message\n    App->>Navigator: Pop Popup Route\n    Navigator->>PopupRoute: Start Exit Transition\n    PopupRoute-->>App: Message animates out of view (fades/slides out)\n    Navigator->>BarrierEntry: Dispose Barrier Entry (after animation)\n    Navigator->>PopupContentEntry: Dispose Popup Content Entry (after animation)\n    Overlay->>Navigator: Remove Barrier and Content\n    Navigator->>PopupRoute: Dispose Popup Route (after animation and removal)\n\n```\n\nThe animation runs in reverse, and the `OverlayEntry`s are removed.\n\n### Looking at the Code\n\nLet's look at the simple definition of the `PopupRoute` class from the provided snippet.\n\n```dart\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n```\n\nAs you can see:\n\n*   `abstract class PopupRoute<T> extends ModalRoute<T>`: It directly inherits from [ModalRoute](04_modalroute_.md).\n*   It overrides three properties: `opaque`, `maintainState`, and `allowSnapshotting` to provide the default behaviors expected for pop-up style routes. These defaults are specifically chosen because pop-ups typically appear as overlays without fully obscuring the previous route (`opaque: false`), often need the previous route's state intact for smooth transitions (`maintainState: true`), and rely on widget-based position/size animations rather than rendering snapshots (`allowSnapshotting: false`).\n\nThese simple overrides make `PopupRoute` a convenient starting point for creating new types of pop-up overlays.\n\n### Example: A Simple Pop-up with RawDialogRoute\n\nWhile directly extending `PopupRoute` is less common for beginners, `RawDialogRoute` (which `showGeneralDialog` uses internally) *is* a `PopupRoute`. Let's revisit a slightly modified conceptual example using `RawDialogRoute` to see how it aligns with `PopupRoute` characteristics.\n\n`RawDialogRoute` inherently embodies the `PopupRoute` concept because it's designed for showing arbitrary content ([`pageBuilder`](#pageBuilder)) often not full-screen, typically with a barrier (configurable color/dismissibility), and benefiting from the default non-opaque behavior.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// Using showGeneralDialog which creates a RawDialogRoute internally\nFuture<void> showSimplePopup(BuildContext context, String message) async {\n  await showGeneralDialog<void>(\n    context: context,\n    barrierColor: Colors.black.withOpacity(0.1), // A very light semi-transparent barrier\n    barrierDismissible: true, // Tap outside to dismiss\n    barrierLabel: 'Dismiss Message',\n    transitionDuration: const Duration(milliseconds: 200),\n    // RawDialogRoute sets this to PopupRoute which defaults to false\n    // allowSnapshotting: false, // This is already the default for PopupRoute\n\n    pageBuilder: (\n      BuildContext dialogContext,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    ) {\n      // This is where you build the content of your pop-up\n      return Center( // Center the popup content\n        child: Card( // Put content in a card\n          margin: const EdgeInsets.all(50.0),\n          child: Padding(\n            padding: const EdgeInsets.all(20.0),\n            child: Text(message), // Show the message\n          ),\n        ),\n      );\n    },\n     transitionBuilder: (\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    ) {\n      // Define how the popup animates in/out\n      return ScaleTransition( // Scale animation\n        scale: CurvedAnimation( // Use a curve for smoother animation\n          parent: animation,\n          curve: Curves.easeOutCubic,\n        ),\n        child: child, // The content from pageBuilder\n      );\n    },\n  );\n}\n\n// Example usage in a widget:\n// ElevatedButton(\n//   onPressed: () {\n//     showSimplePopup(context, 'Hello from the popup!');\n//   },\n//   child: const Text('Show Popup'),\n// )\n\n```\n\nIn this example, calling `showSimplePopup` uses `showGeneralDialog`, which creates a `RawDialogRoute` (a `PopupRoute`). We configure a very light barrier, make it dismissible by tapping the barrier, and provide a `pageBuilder` to define the content (a centered `Card` with text) and a `transitionBuilder` for a scale animation.\n\nBecause `RawDialogRoute` is a `PopupRoute`, it benefits from the `opaque: false` default, allowing you to see the content behind the pop-up. The `maintainState: true` default helps ensure smooth transitions.\n\n### Conclusion\n\nIn this chapter, we introduced `PopupRoute`, a specialized type of [ModalRoute](04_modalroute_.md) tailored for creating temporary, often non-fullscreen, overlay elements like menus and simple notifications. We learned how it inherits capabilities from [ModalRoute](04_modalroute_.md) and [TransitionRoute](02_transitionroute_.md) but overrides properties like `opaque`, `maintainState`, and `allowSnapshotting` to better fit typical pop-up behaviors. While you often use routes like `RawDialogRoute` (created by `showGeneralDialog`) that are subclasses of `PopupRoute`, understanding `PopupRoute` helps explain why these elements behave the way they do.\n\nIn the next chapter, we'll briefly look at [PredictiveBackRoute](06_predictivebackroute_.md), an interface related to handling platform-specific back gestures.\n\n[Chapter 6: PredictiveBackRoute](06_predictivebackroute_.md)\n---\n# Chapter 6: PredictiveBackRoute\n\nWelcome back! In our previous chapters, we've explored how Flutter uses [Route](01_route_.md)s like a stack of playing cards to manage screens, how [TransitionRoute](02_transitionroute_.md) adds animations to make screen changes smooth, and how [OverlayRoute](03_overlayroute_.md) and [ModalRoute](04_modalroute_.md) let us place content on top of existing screens, sometimes with a dimming barrier.\n\nToday, we\u2019re going to look at a concept called `PredictiveBackRoute`. This is a slightly more advanced topic, specifically related to how users interact with the \"back\" action on platforms like Android, where you can sometimes swipe from the edge of the screen to preview the previous screen *before* fully completing the back gesture.\n\n### What is a PredictiveBackRoute?\n\nImagine you're looking at a detailed picture in a gallery app on your phone. You know you want to go back to the list of pictures. On some operating systems (like recent Android versions), you can start a swipe gesture from the left or right edge of the screen. As you swipe, the current screen starts to shrink and move away, and you can see the previous screen (the list of pictures) peeking from behind! If you complete the swipe, you go back. If you let go halfway, the current screen snaps back into place.\n\nThis interactive, visual \"pull-to-go-back\" experience is what **Predictive Back** is all about. It gives the user a clearer idea of where they're going before they commit to the back action.\n\n`PredictiveBackRoute` is an abstraction in Flutter that helps routes participate in this predictive back gesture. It's like giving your animated playing cards a special edge that responds to a \"pulling\" motion, showing what's underneath before you actually lift the card off the stack.\n\nYou won't often create a `PredictiveBackRoute` directly because it's an `interface` (a contract for what a class *should* do). Instead, other route types like `TransitionRoute` (which includes `ModalRoute` like `MaterialPageRoute`) *implement* this interface, adding the necessary logic to respond to these predictive back gestures.\n\n### Why Use PredictiveBackRoute?\n\nImplementing predictive back requires coordination between the operating system's gesture detection and the route's animation. The OS tells the app that a back gesture is starting, how far along it is, if it's canceled, or if it's committed. The route needs to respond by animating its appearance accordingly.\n\nThe `PredictiveBackRoute` interface defines the standard methods that routes need to provide to handle these events. By having routes implement this interface, the Flutter framework (specifically, the [Navigator](03_overlayroute_.md) or underlying low-level gesture handlers) knows how to communicate with the route during a predictive back gesture.\n\nThis makes integrating with native predictive back much cleaner. The route, by implementing `PredictiveBackRoute`, declares that it *knows how* to handle such gestures, and the framework uses the defined methods to control its animation during the gesture.\n\n### Key Concepts of PredictiveBackRoute\n\nSince `PredictiveBackRoute` is an interface, its main \"concepts\" are the methods it requires implementing classes to have:\n\n*   **`handleStartBackGesture({double progress})`:** Called when a predictive back gesture *begins*. The `progress` tells the route how much the user has already swiped (0.0 is the start, 1.0 is fully back).\n*   **`handleUpdateBackGestureProgress({required double progress})`:** Called repeatedly as the user *drags* the swipe gesture. The `progress` updates continuously from near 0.0 up to 1.0. This is where the route should update its transition animation based on the user's finger movement.\n*   **`handleCancelBackGesture()`:** Called if the user *releases* the gesture *before* reaching the commit threshold (usually before reaching the edge). The route should animate back to its fully visible state.\n*   **`handleCommitBackGesture()`:** Called if the user *completes* the gesture (swipes all the way or past a certain point). The route should finish its exit animation and be popped from the navigator.\n*   **`popGestureEnabled`:** A getter that indicates whether the route *can* currently be dismissed by a pop gesture (like predictive back). This helps the framework decide if it should even start sending gesture events to this route.\n\nRoutes that implement `PredictiveBackRoute` use these methods to control their existing animation controllers (like the one inherited from [TransitionRoute](02_transitionroute_.md)).\n\n### How PredictiveBackRoute Works (Simplified)\n\nLet's trace what happens conceptually when a user performs a predictive back gesture on a screen represented by a route that implements `PredictiveBackRoute` (like a `MaterialPageRoute`).\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant FlutterEngine as Flutter Engine\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (PredictiveBackRoute)\n\n    User->>OS: Starts swipe from edge\n    OS->>FlutterEngine: Notifies gesture started\n    FlutterEngine->>Navigator: Notifies back gesture started (PredictiveBackEvent)\n    Navigator->>CurrentRoute: Calls handleStartBackGesture({progress: 0.0})\n    CurrentRoute-->>Navigator: Route starts responding to gesture\n\n    loop User swipes further\n        User->>OS: Drags finger\n        OS->>FlutterEngine: Notifies progress update (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes progress to Navigator\n        Navigator->>CurrentRoute: Calls handleUpdateBackGestureProgress({progress: ...})\n        CurrentRoute-->>Navigator: Route updates animation based on progress\n    end\n\n    alt User lets go (cancel)\n        User->>OS: Stops swiping before threshold\n        OS->>FlutterEngine: Notifies gesture canceled (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes cancel to Navigator\n        Navigator->>CurrentRoute: Calls handleCancelBackGesture()\n        CurrentRoute-->>Navigator: Route animates back to full visibility\n        Navigator-->>User: Screen returns to original state\n    else User swipes fully (commit)\n        User->>OS: Completes swipe\n        OS->>FlutterEngine: Notifies gesture completed (PredictiveBackEvent)\n        FlutterEngine->>Navigator: Passes commit to Navigator\n        Navigator->>CurrentRoute: Calls handleCommitBackGesture()\n        CurrentRoute-->>Navigator: Route starts exit animation\n        Navigator->>Navigator: Pops CurrentRoute from stack\n        Navigator-->>User: Transition finishes, previous screen is shown\n    end\n```\n\nNotice how the operating system detects the gesture, passes information through the Flutter engine to the [Navigator](03_overlayroute_.md), and the [Navigator](03_overlayroute_.md) then uses the `PredictiveBackRoute` methods to tell the specific route how to animate.\n\n### Looking at the Code\n\nLet's look at the `PredictiveBackRoute` interface definition (it's part of the `TransitionRoute` code snippet you have, near the end). Remember, an interface just lists methods that a class *must* provide.\n\n```dart\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n```\n\nThis code snippet confirms the methods we discussed: `isCurrent` (useful to check if this is the route the user is trying to back from), `popGestureEnabled` (to check if the gesture is allowed), and the four `handle...BackGesture` methods for the different phases of the gesture.\n\nNow, let's look at how `TransitionRoute` (which `ModalRoute` extends) implements these methods. This logic is also in the provided snippet.\n\n```dart\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  // ... other code ...\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress; // Set animation value to initial progress\n    navigator?.didStartUserGesture(); // Notify navigator a gesture started\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress; // Update animation value based on drag progress\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true); // Animate forward (back to original state)\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false); // Animate backward (complete pop)\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // Calculate animation duration based on current progress\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0, // Animate to fully forward (visible)\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop(); // Trigger the pop\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // If still animating, finish the pop animation\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0, // Animate back to fully dismissed\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    // Notify navigator the gesture stopped after delay if needed\n    if (_controller?.isAnimating ?? false) {\n       // ... animation status listener logic ...\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // ... more code ...\n\n  @override\n  bool get popGestureEnabled {\n    // ... checks if a pop gesture is currently allowed ...\n    // Checks things like: is this the first route? Is there a WillPopScope blocking?\n    // Is another gesture or animation already happening?\n    return true; // Simplified example - actual logic depends on many factors\n  }\n\n  // End PredictiveBackRoute.\n\n  // ... rest of TransitionRoute code ...\n}\n```\n\nIn this code (simplified):\n\n*   When the gesture starts (`handleStartBackGesture`), the route's internal animation controller (`_controller`) is set to the initial progress, and the [Navigator](03_overlayroute_.md) is notified a gesture is active.\n*   When the gesture updates (`handleUpdateBackGestureProgress`), the animation controller's value is directly set to the current gesture `progress`. This makes the transition animation track the user's finger!\n*   When the gesture ends (either `handleCancelBackGesture` or `handleCommitBackGesture`), the `_handleDragEnd` method is called.\n*   `_handleDragEnd` decides whether to animate the route back to fully visible (`animateForward: true`) or fully dismissed (`animateForward: false`).\n*   If completing the pop, it calls `navigator?.pop()`, which triggers the standard route popping process, and then finishes any remaining animation smoothly.\n*   `popGestureEnabled` contains logic to determine if this route is a candidate for a back gesture.\n\nThis implementation in `TransitionRoute` provides the generic plumbing for predictive back. Specific route types, like `MaterialPageRoute`, might use the `animation` value provided by the `_controller` (which is now being manipulated by the gesture handlers) within their `buildTransitions` method to create the actual visual effect of the previous screen peeking out or the current screen sliding away.\n\n### Example (Conceptual)\n\nYou don't typically *use* `PredictiveBackRoute` directly. You benefit from it when using routes that *implement* it.\n\nFor example, `MaterialPageRoute` implements `PredictiveBackRoute` (because it extends `ModalRoute` which extends `TransitionRoute`). When you use `Navigator.push(context, MaterialPageRoute(...))`, the resulting route automatically participates in Android's predictive back gesture because `MaterialPageRoute` provides the gesture handling logic inherited from `TransitionRoute`. You don't write any predictive back code yourself!\n\n```dart\n// You don't implement PredictiveBackRoute yourself for standard routes.\n// MaterialPageRoute already does this for you.\n\nNavigator.push(\n  context,\n  MaterialPageRoute(\n    builder: (context) {\n      return Scaffold(\n        appBar: AppBar(title: const Text('Detail Page')),\n        body: const Center(child: Text('Swipe from the edge to see predictive back!')),\n      );\n    },\n  ),\n);\n\n// Because MaterialPageRoute is (indirectly) a PredictiveBackRoute,\n// when a predictive back gesture starts on an Android device:\n// The framework calls handleStartBackGesture on the MaterialPageRoute instance.\n// As the user swipes, handleUpdateBackGestureProgress is called repeatedly.\n// The MaterialPageRoute's buildTransitions method (using the manipulated animation)\n// draws the predictive back effect (e.g., the page sliding away).\n// If the user cancels, handleCancelBackGesture is called.\n// If the user commits, handleCommitBackGesture is called, triggering a pop.\n```\n\nThis is the power of abstraction: you get complex behavior like predictive back \"for free\" when using standard routes that implement the necessary interfaces and base classes.\n\n### Conclusion\n\nIn this chapter, we briefly explored `PredictiveBackRoute`, an interface that enables routes to participate in platform-specific interactive back gestures like Android's predictive back. We learned that it defines methods for handling the start, update, cancel, and commit phases of the gesture, and that base classes like `TransitionRoute` implement this interface to provide the core logic for controlling the route's animation based on user input. By using routes that implement `PredictiveBackRoute` (like `MaterialPageRoute`), you automatically get support for these modern navigation features on supporting platforms.\n\nIn the next chapter, we'll look at [LocalHistoryRoute](07_localhistoryroute_.md), a mixin that allows routes to handle some \"back\" actions internally without actually popping the route from the navigator stack.\n\n[Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md)\n---\n# Chapter 7: LocalHistoryRoute\n\nWelcome back, future Flutter expert! In our previous chapters, we've climbed the `Route` hierarchy, learning about animated transitions ([TransitionRoute](02_transitionroute_.md)), layered overlays ([OverlayRoute](03_overlayroute_.md)), and modal experiences ([ModalRoute](04_modalroute_.md)), even touching on predictive back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)). Our mental model has been a stack of full playing cards, where \"back\" always means peeling off the top card to reveal the one below.\n\nBut what if you're on a single screen (one card), and within that screen, you perform a few actions that feel like mini-navigations, but you don't want to fully leave that screen? Imagine a search feature within a product details page. You:\n\n1.  Are viewing product details.\n2.  Tap a search icon within that page.\n3.  A search bar appears on the *same* page, and you start typing.\n4.  As you type, search results appear, perhaps covering the main product details.\n5.  You tap a result, maybe showing a mini-preview, still within this screen.\n\nNow, what happens if you press the back button? You probably don't want to go *all the way back* to the list of products. You likely want to:\n\n1.  Hide the mini-preview.\n2.  Hide the search results.\n3.  Hide the search bar, returning to the original product details view.\n4.  *Then*, if you press back again, you go back to the product list.\n\nThis is where `LocalHistoryRoute` comes in! It allows a single [Route](01_route_.md) (or rather, a `ModalRoute` that uses the `LocalHistoryRoute` *mixin*) to manage its *own* mini-stack of pop-like behaviors without involving the main [Navigator](03_overlayroute_.md) stack.\n\n### What is a LocalHistoryRoute?\n\nA `LocalHistoryRoute` is not a separate type of route in the same way that [ModalRoute](04_modalroute_.md) is a separate type from [OverlayRoute](03_overlayroute_.md). Instead, it's a **mixin**. Think of a mixin as a set of extra powers or abilities you can *add* to an existing class. `LocalHistoryRoute` adds the ability to handle \"back\" actions *locally*, within that route itself, instead of letting the [Navigator](03_overlayroute_.md) pop the entire route off the stack.\n\nSpecifically, `ModalRoute` uses ([mixes in](04_modalroute_.md)) the `LocalHistoryRoute` capabilities. This means any `ModalRoute` (including common ones like `MaterialPageRoute`) can have its own *local history*.\n\nImagine your single screen (the playing card) can have sticky notes attached to its *front*. When you add a sticky note (like showing a search bar), you're adding an entry to the screen's \"local history.\" When you press back, instead of removing the entire card, the screen checks its sticky notes. If there's a sticky note, it removes the top sticky note (hiding the search bar) and stays on the same card. Only when all sticky notes are gone does the next back press remove the main card.\n\n### Why Use LocalHistoryRoute?\n\nUsing `LocalHistoryRoute` (by adding entries to the local history of a `ModalRoute`) is essential for implementing UI patterns where a \"back\" action within a screen should reverse a temporary state change or overlay *before* navigating away from that screen.\n\nThis provides a more intuitive and consistent user experience, especially on platforms where the hardware or OS back button is commonly used. You keep the user focused on the current screen until they've finished the sub-tasks (like search or filtering) they started within it.\n\n### Key Concepts of LocalHistoryRoute\n\n`LocalHistoryRoute` introduces a simple mechanism:\n\n*   **Local History Entry (`LocalHistoryEntry`):** This is the core concept! It's an object representing a single \"step\" in the route's local history. You add these entries when you perform an action that should be reversible by a local back press (e.g., showing an overlay, expanding a section).\n*   **`onRemove` callback:** Each `LocalHistoryEntry` has an optional `onRemove` callback. This function is called when that specific history entry is removed (when the user performs a local back action that corresponds to this entry). This is where you put the code to *undo* the action associated with this entry (e.g., hide the search results, close the search bar).\n*   **Adding Entries (`addLocalHistoryEntry`):** Routes that use the mixin (`LocalHistoryRoute`) have a method to add a new `LocalHistoryEntry` to their history stack. The most recently added entry is at the top.\n*   **Handling Pop (`didPop` & `willHandlePopInternally`):** The `LocalHistoryRoute` mixin overrides the route's `didPop` method. When the [Navigator](03_overlayroute_.md) tries to pop the route, the `LocalHistoryRoute` checks its local history. If there are entries, it *doesn't* let the [Navigator](03_overlayroute_.md) pop the main route. Instead, it removes the last `LocalHistoryEntry` and calls its `onRemove` callback. Only if the local history is empty does it allow the `Navigator` to proceed with popping the main route. The `willHandlePopInternally` getter also reflects this state; it returns `true` if there are local history entries, indicating that the route will handle the pop itself.\n\nEssentially, the `LocalHistoryRoute` mixin intercept's the `Navigator`'s `pop` command when the route has local history entries, handles it internally by removing an entry, and then tells the `Navigator` \"No, I wasn't popped, I handled it.\"\n\n### How LocalHistoryRoute Works (Conceptual)\n\nLet's trace the playing card example with a local search feature using `LocalHistoryRoute`.\n\n**Scenario 1: Adding a Local History Entry (Showing Search)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant SearchOverlay as Search Overlay Widget\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>Routeroute: Tap Search Icon\n    Routeroute->>SearchOverlay: Show Search Overlay Widget\n    Routeroute->>LocalHistoryEntry: Create Local History Entry\n    Routeroute->>Routeroute: Add Local History Entry to local history stack\n    Routeroute-->>User: Screen now shows Search Overlay\n```\n\nThe key here is that tapping the search icon doesn't push a new route. It changes the UI *within* the current route and adds a marker (`LocalHistoryEntry`) to the route's internal history list.\n\n**Scenario 2: Pressing Back (Local Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant LocalHistoryEntry as Local History Entry (for Search)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It's NOT empty)\n    Routeroute->>LocalHistoryEntry: Remove top Local History Entry\n    Routeroute->>LocalHistoryEntry: Call onRemove() callback (...which hides the Search Overlay)\n    Routeroute-->>Navigator: Returns 'false' (claiming it was NOT popped)\n    Navigator-->>User: Navigator stays on the same route; User sees Product Details again.\n```\n\nWhen back is pressed, the `Navigator` asks the route to pop. But the route, thanks to the mixin, sees a `LocalHistoryEntry` and *doesn't* let the `Navigator` pop it. Instead, it handles the \"pop\" locally by removing the entry and triggering its `onRemove` callback, which reverses the local UI change.\n\n**Scenario 3: Pressing Back Again (Full Pop)**\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Routeroute as Product Details Route (ModalRoute + LocalHistoryRoute)\n    participant Navigator as Navigator\n    participant PrevRoute as Previous Route (Product List)\n\n    User->>OS: Press Back Button (Local history is now EMPTY)\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>Routeroute: Calls didPop(null) on current route\n    Routeroute->>Routeroute: Check local history list... (It IS empty)\n    Routeroute-->>Navigator: Returns 'true' (allowing Navigator to pop)\n    Navigator->>Routeroute: Disposes Route (conceptually after animation)\n    Navigator->>Navigator: Pops Routeroute from stack\n    Navigator-->>User: User now sees Product List\n```\n\nWith the local history empty, when back is pressed again, the route's `didPop` sees the empty list and *does* return `true`, indicating that it allowed itself to be popped. The `Navigator` then proceeds with removing the route from its stack.\n\n### Looking at the Code\n\nLet's examine the relevant parts of the `LocalHistoryRoute` mixin definition.\n\n```dart\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  void addLocalHistoryEntry(LocalHistoryEntry entry) { /* ... adds to _localHistory ... */ }\n\n  /// Remove a local history entry from this route.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) { /* ... removes from _localHistory and calls onRemove */ }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop; // Indicate that this route will handle the pop internally.\n    }\n    return super.popDisposition; // Let the base class decide (usually allows Navigator pop).\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      // ... cleanup and call entry._notifyRemoved() which calls onRemove ...\n      return false; // IMPORTANT: Return false to tell Navigator it was NOT popped\n    }\n    return super.didPop(result); // Local history empty, let the base class handle the pop.\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty; // True if local history exists.\n  }\n}\n```\n\nKey things to note:\n\n*   `mixin LocalHistoryRoute<T> on Route<T>`: This confirms it's a mixin that can only be applied to classes that are (or inherit from) `Route<T>`.\n*   `_localHistory`: A private list that stores the `LocalHistoryEntry` objects. It acts as the local history stack.\n*   `addLocalHistoryEntry(LocalHistoryEntry entry)`: Adds an entry to the `_localHistory` list.\n*   `removeLocalHistoryEntry(LocalHistoryEntry entry)`: Removes a specific entry (you might call this if a local state change is reversed by something other than a back button).\n*   `popDisposition`: Overridden to return `RoutePopDisposition.pop` if `willHandlePopInternally` is true, signaling that the route will handle the pop itself.\n*   `didPop(T? result)`: This is the crucial override. It checks if `_localHistory` is empty. If not, it removes the last entry, calls its `onRemove` callback, and returns `false`. Returning `false` signifies to the [Navigator](03_overlayroute_.md) that this route *was not* removed from the stack. If `_localHistory` *is* empty, it calls `super.didPop`, letting the base `Route` (and thus the [Navigator](03_overlayroute_.md)) handle the pop.\n*   `willHandlePopInternally`: This getter returns `true` if there are any local history entries, informing potentially other parts of the framework (like an `AppBar` which might decide to show a back button or not) that the route has internal pop handling.\n\nNow let's look at the `LocalHistoryEntry` itself:\n\n```dart\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n```\n\nHere:\n\n*   `LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true})`: The constructor takes an optional `onRemove` callback.\n*   `onRemove`: The function that gets called when this specific entry is popped from the local history.\n*   `impliesAppBarDismissal`: A flag that affects whether an `AppBar` automatically shows a back button. If a route has local history entries where this is true, the `AppBar` might show a back button, even if the route isn't truly `canPop` from the `Navigator`'s perspective.\n\n### Example: Implementing Local History for Search\n\nLet's build a conceptual example showing how you'd use `LocalHistoryRoute` (via a `ModalRoute` subclass like `MaterialPageRoute`) to implement the local search functionality we discussed.\n\nWe'll create a simple screen that shows content, and tapping a button adds a \"search bar\" overlay and a local history entry. Tapping back will hide the search bar.\n\n```dart\nimport 'package:flutter/material.dart';\n\n// This widget represents our screen that we push as a route.\nclass ProductDetailsScreen extends StatefulWidget {\n  const ProductDetailsScreen({super.key});\n\n  @override\n  State<ProductDetailsScreen> createState() => _ProductDetailsScreenState();\n}\n\nclass _ProductDetailsScreenState extends State<ProductDetailsScreen> {\n  // State to control the visibility of the \"search bar\" overlay.\n  bool _showSearchBar = false;\n\n  // The LocalHistoryEntry we'll manage. We need to keep a reference\n  // so we can potentially remove it explicitly if needed (though pop handles it).\n  LocalHistoryEntry? _searchHistoryEntry;\n\n  // Function to show the search bar and add a local history entry.\n  void _activateSearch() {\n    // If the search bar is already shown, do nothing.\n    if (_showSearchBar) {\n      return;\n    }\n    setState(() {\n      _showSearchBar = true;\n    });\n\n    // Get the current ModalRoute for this screen.\n    // MaterialPageRoute is a ModalRoute, so this works.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    // Create a new LocalHistoryEntry.\n    _searchHistoryEntry = LocalHistoryEntry(\n      // When this entry is removed (via local pop), this function is called.\n      onRemove: () {\n        // Hide the search bar.\n        setState(() {\n          _showSearchBar = false;\n        });\n        // Clear our reference to the entry.\n        _searchHistoryEntry = null;\n      },\n      // Setting this to true means the AppBar might show a back button\n      // while the search bar is visible.\n      impliesAppBarDismissal: true,\n    );\n\n    // Add the entry to the current route's local history.\n    modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!);\n\n    print('Search activated, LocalHistoryEntry added.');\n  }\n\n  // Function to explicitly close the search bar (e.g., tapping an 'x' button).\n  void _deactivateSearch() {\n     if (!_showSearchBar || _searchHistoryEntry == null) {\n       return;\n     }\n     // Removing the entry manually also calls its onRemove callback\n     // which will hide the search bar.\n     _searchHistoryEntry!.remove();\n     print('Search deactivated, LocalHistoryEntry removed manually.');\n   }\n\n\n  @override\n  Widget build(BuildContext context) {\n    // Getting the ModalRoute here makes the widget rebuild if the route's\n    // properties related to ModalRoute.of change (like canPop, isCurrent).\n    // This is often how widgets react to route changes.\n    final ModalRoute<dynamic>? modalRoute = ModalRoute.of(context);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Product Details'),\n        // AppBar automatically uses ModalRoute.of(context).willHandlePopInternally\n        // (or popDisposition indirectly) and impliesAppBarDismissal\n        // to decide whether to show a back button.\n      ),\n      body: Stack( // Use a Stack to layer the search bar on top\n        children: [\n          // Main product details content\n          Center(\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              children: <Widget>[\n                const Text('Product Details Go Here'),\n                const SizedBox(height: 20),\n                ElevatedButton(\n                  onPressed: _activateSearch, // Button to trigger local navigation\n                  child: const Text('Show Search (Local)'),\n                ),\n                 // Example of a widget that might disappear on local pop\n                if (_showSearchBar)\n                 Padding(\n                    padding: const EdgeInsets.only(top: 20.0),\n                    child: Text('Search Results Placeholder...'),\n                 ),\n              ],\n            ),\n          ),\n\n          // The \"search bar\" overlay, conditionally visible\n          if (_showSearchBar)\n            Positioned( // Position on top\n              top: 0,\n              left: 0,\n              right: 0,\n              child: Container(\n                color: Colors.white,\n                 padding: const EdgeInsets.symmetric(horizontal: 8.0),\n                 child: Row(\n                    children: [\n                       Expanded(\n                          child: TextField(\n                             decoration: InputDecoration(hintText: 'Search...'),\n                             autofocus: true,\n                          ),\n                       ),\n                       IconButton(\n                           icon: Icon(Icons.close),\n                           onPressed: _deactivateSearch, // Explicit close button\n                       ),\n                    ],\n                 ),\n              ),\n            ),\n        ],\n      ),\n    );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const ProductDetailsScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have a `ProductDetailsScreen` StatefulWidget.\n2.  We use a boolean `_showSearchBar` to control the visibility of our pseudo-search overlay.\n3.  When the \"Show Search\" button is pressed (`_activateSearch`):\n    *   We set `_showSearchBar` to `true`, making the search UI visible.\n    *   We get the current `ModalRoute.of(context)`. Since `MaterialPageRoute` is a `ModalRoute`, this gives us the route object for this screen.\n    *   We create a `LocalHistoryEntry`. Its `onRemove` callback sets `_showSearchBar` back to `false`.\n    *   We call `modalRoute?.addLocalHistoryEntry(_searchHistoryEntry!)` to add the entry to the route's local history list.\n4.  Now, if you press the device's back button:\n    *   The `Navigator` receives the pop request.\n    *   It calls `didPop` on our `MaterialPageRoute`.\n    *   The `MaterialPageRoute` (thanks to the `LocalHistoryRoute` mixin) sees that its local history (`_localHistory`) is not empty.\n    *   It removes the `_searchHistoryEntry` from its `_localHistory`.\n    *   It calls the `onRemove` callback of that `_searchHistoryEntry`.\n    *   The `onRemove` callback fires, setting `_showSearchBar = false`, which hides the search UI.\n    *   The `didPop` method returns `false` to the `Navigator`.\n    *   The `Navigator` does *not* pop the `ProductDetailsScreen`.\n5.  If you press back again:\n    *   The `Navigator` calls `didPop` again.\n    *   The route's local history is now empty.\n    *   `didPop` calls `super.didPop`, which allows the standard route popping mechanism to happen.\n    *   The `ProductDetailsScreen` is popped, and you return to the previous full screen.\n\nThe `impliesAppBarDismissal: true` on the `LocalHistoryEntry` hints to the `AppBar` that it should show a back button. When the local history is empty, the base route's `willHandlePopInternally` becomes false, and the `AppBar` correctly reflects that the next back press will pop the whole route.\n\n### Conclusion\n\nIn this chapter, we explored `LocalHistoryRoute`, not a direct route class, but a powerful mixin used by `ModalRoute` to enable routes to manage their own internal history of pop-like behaviors. We learned how `LocalHistoryEntry` with its `onRemove` callback serves as the mechanism for capturing reversible state changes within a single screen, and how the mixin intercepts the `Navigator`'s pop requests to handle them locally when history entries exist. Understanding `LocalHistoryRoute` is crucial for building intuitive navigation flows where a back press within a screen should undo a temporary UI change before exiting the screen entirely.\n\nIn the next chapter, we will discuss [PopEntry](08_popentry_.md), a more modern way to declaratively manage pop behavior within a route's widget subtree.\n\n[Chapter 8: PopEntry](08_popentry_.md)\n---\n# Chapter 8: PopEntry\n\nWelcome back to our Flutter navigation journey! In the last chapter, [Chapter 7: LocalHistoryRoute](07_localhistoryroute_.md), we learned how a single route could manage its own \"mini-history\" using `LocalHistoryEntry` to handle back presses internally, perfect for showing/hiding overlays or sections within a screen without leaving it.\n\nNow, let's introduce `PopEntry`. This is a newer and often more declarative way to manage if a route can be popped and to react when it *is* popped. Think of it as putting special \"stickers\" onto a playing card ([ModalRoute](04_modalroute_.md)) that can either stick the card to the stack (preventing the pop) or react when the card finally gets removed.\n\n### What is a PopEntry?\n\nA `PopEntry` is a simple object that you can associate with a [ModalRoute](04_modalroute_.md). It holds two key pieces of information:\n\n1.  **Can Pop:** Whether this specific entry thinks the route can currently be popped.\n2.  **On Pop Invoked:** A function (`onPopInvokedWithResult`) to call when the route is popped (or a pop is attempted and blocked).\n\nImagine your [ModalRoute](04_modalroute_.md) (the playing card) can have multiple stickers (`PopEntry`s) stuck to it by different parts of your screen's UI (like different widgets). Before the card can be removed (popped), *every* sticker must agree that it's okay to remove the card. If even one sticker says \"No, don't pop yet!\" then the card stays. If all stickers say \"Yes, go ahead!\", the card can be popped. When the card *is* removed, *every* sticker gets notified.\n\nThis is the mechanism used by the modern `PopScope` widget. When you use `PopScope` inside a route, it often works by creating a `PopEntry` and registering it with the [ModalRoute](04_modalroute_.md) that contains it.\n\nCommon use cases for `PopEntry` (often via `PopScope`):\n\n*   **Blocking pops with unsaved data:** If the user is editing a form, you can create a `PopEntry` that says the route *cannot* be popped while there are unsaved changes.\n*   **Showing a confirmation dialog:** When a pop is attempted but blocked (because a `PopEntry` said no), you can use the `onPopInvokedWithResult` callback of that `PopEntry` to show a \"Discard changes?\" dialog.\n*   **Reacting to a pop:** Even if you don't block the pop, a `PopEntry`'s `onPopInvokedWithResult` can be used to perform cleanup or other actions just before or after the route is popped.\n\n### Why Use PopEntry?\n\n`PopEntry` provides a more structured and explicit way to manage pop behavior compared to the older `WillPopCallback`s (though those are still supported for compatibility and specific advanced cases).\n\n*   **Declarative:** Widgets like `PopScope` make it easy to declare pop behavior right where the relevant UI lives, creating a `PopEntry` under the hood.\n*   **Multiple handlers:** Several `PopEntry` instances can be registered with a single route, each controlling its own `canPop` status and reacting to pop attempts independently. The route's overall `canPop` becomes the logical AND of all registered `PopEntry`s.\n*   **Rich callback:** The `onPopInvokedWithResult` callback provides information about whether the pop *actually* happened (`didPop` boolean) and the `result` the route was popped with, allowing for more nuanced reactions.\n\n### Key Concepts of PopEntry\n\n*   **`canPopNotifier`:** This is a `ValueListenable<bool>`. When its value is `true`, this `PopEntry` contributes to the route being potentially pop-able. When it's `false`, this entry signals \"do not pop.\" The route listens to this notifier and updates its own `canPop` status accordingly.\n*   **`onPopInvokedWithResult(bool didPop, T? result)`:** This callback is triggered whenever a pop is attempted on the route, regardless of whether it was successfully popped or blocked.\n    *   `didPop`: `true` if the route *was* actually popped and removed from the navigator stack; `false` if the pop was blocked (e.g., by a `PopEntry` or [LocalHistoryRoute](07_localhistoryroute_.md)).\n    *   `result`: The value the route was popped with (if `didPop` is true).\n*   **Registering/Unregistering:** A `PopEntry` must be registered with its containing [ModalRoute](04_modalroute_.md) using `modalRoute.registerPopEntry()` and unregistered using `modalRoute.unregisterPopEntry()` when it's no longer needed (typically handled automatically by widgets like `PopScope`).\n\n### How PopEntry Works (Conceptual)\n\nLet's see how a Route with a several PopEntries (stickers) behaves when a pop is attempted.\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant OS as Operating System\n    participant Navigator as Navigator\n    participant CurrentRoute as Current Route (ModalRoute)\n    participant PopEntry1 as PopEntry 1 (Form)\n    participant PopEntry2 as PopEntry 2 (Editing)\n\n    User->>OS: Press Back Button\n    OS->>Navigator: Notify Back Pressed\n    Navigator->>CurrentRoute: Check popDisposition\n    CurrentRoute->>PopEntry1: Check canPopNotifier.value (e.g., is Form clean?)\n    CurrentRoute->>PopEntry2: Check canPopNotifier.value (e.g., is Editing complete?)\n\n    alt Both PopEntry1 and PopEntry2 can pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.pop\n        Navigator->>CurrentRoute: Call didPop(...)\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: true, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: true, ...)\n        Navigator->>Navigator: Pops CurrentRoute\n        Navigator-->>User: Previous screen visible\n    else At least one PopEntry cannot pop\n        CurrentRoute-->>Navigator: Result: RoutePopDisposition.doNotPop\n        Navigator->>CurrentRoute: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry1: Call onPopInvokedWithResult(didPop: false, ...)\n        CurrentRoute->>PopEntry2: Call onPopInvokedWithResult(didPop: false, ...)\n        User-->>App: Route remains on screen\n        Note right of User: Might show dialog in callback\n    end\n```\n\n1.  The user initiates a back action.\n2.  The OS notifies the [Navigator](03_overlayroute_.md).\n3.  The [Navigator](03_overlayroute_.md) consults the current route's `popDisposition`.\n4.  The route's `popDisposition` (specifically, the `ModalRoute` implementation using the `LocalHistoryRoute` mixin logic, which also checks registered `PopEntry`s) iterates through its registered `PopEntry` instances and reads their `canPopNotifier.value`.\n5.  If *all* `PopEntry`s return `true` (and there's no [LocalHistoryRoute](07_localhistoryroute_.md) blocking it), the `popDisposition` signals that the route *can* be popped. The [Navigator](03_overlayroute_.md) proceeds with popping the route. After or during the animation, the route's `onPopInvokedWithResult` method is called with `didPop: true`. This cascades to calling `onPopInvokedWithResult` on all registered `PopEntry`s with `didPop: true`.\n6.  If *any* `PopEntry` returns `false`, the `popDisposition` signals `RoutePopDisposition.doNotPop`. The [Navigator](03_overlayroute_.md) *does not* pop the route off the stack. The route's `onPopInvokedWithResult` method is called with `didPop: false`, which cascades to all registered `PopEntry`s calling their `onPopInvokedWithResult` with `didPop: false`. This is where a `PopEntry` might trigger a confirmation dialog.\n\n### Looking at the Code\n\nLet's look at the `PopEntry` definition itself.\n\n```dart\nabstract class PopEntry<T> {\n  // ... deprecated onPopInvoked ...\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  // ... toString ...\n}\n```\nThis abstract class defines the two key parts: the getter for `canPopNotifier` and the abstract method `onPopInvokedWithResult` that subclasses must implement.\n\nNow, let's look at how `ModalRoute` uses `PopEntry` (from the provided snippet):\n\n```dart\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  // ... other properties and methods ...\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{}; // Stores registered entries\n\n  // ... willPop (deprecated) ...\n\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      if (!popEntry.canPopNotifier.value) { // Check each entry's canPopNotifier\n        return RoutePopDisposition.doNotPop; // If any is false, block the pop\n      }\n    }\n\n    return super.popDisposition; // If all can pop, let the base (LocalHistoryRoute) decide\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) { // Loop through registered entries\n      popEntry.onPopInvokedWithResult(didPop, result); // Call callback on each entry\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry); // Add to the set of entries\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification); // Listen for canPop changes\n    _maybeDispatchNavigationNotification(); // Trigger notification after adding\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry); // Remove from the set\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification); // Stop listening\n    _maybeDispatchNavigationNotification(); // Trigger notification after removing\n  }\n\n  // ... more code ...\n}\n```\nHere, we see:\n*   `_popEntries`: A `Set` within `ModalRoute` to keep track of all the `PopEntry` instances that have been registered with this route.\n*   `popDisposition`: This overridden getter now explicitly loops through `_popEntries`. If *any* `PopEntry`'s `canPopNotifier.value` is `false`, it immediately returns `RoutePopDisposition.doNotPop`, effectively blocking the pop. If the loop completes (all `canPopNotifier.value`s were true), it then asks `super.popDisposition` (which handles the `LocalHistoryRoute` logic) whether the pop should happen or be handled locally.\n*   `onPopInvokedWithResult`: This overridden method simply iterates through the registered `_popEntries` and calls `onPopInvokedWithResult` on each one, passing the same `didPop` and `result` arguments.\n*   `registerPopEntry` and `unregisterPopEntry`: These methods manage adding/removing entries from the `_popEntries` set. They also add/remove a listener to the `PopEntry`'s `canPopNotifier` so that the route can react when a `PopEntry`'s `canPop` status changes (`_maybeDispatchNavigationNotification` is called to potentially notify listeners like the `AppBar`).\n\n### Example: Using PopScope (Which Uses PopEntry)\n\nYou overwhelmingly interact with `PopEntry` through the `PopScope` widget. `PopScope` is a simple widget that wraps another widget and automatically creates, registers, and unregisters a `PopEntry` with the nearest [ModalRoute](04_modalroute_.md).\n\nHere's how you'd use `PopScope` to prevent navigating away from a screen with unsaved changes without a confirmation:\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass EditItemScreen extends StatefulWidget {\n  const EditItemScreen({super.key});\n\n  @override\n  State<EditItemScreen> createState() => _EditItemScreenState();\n}\n\nclass _EditItemScreenState extends State<EditItemScreen> {\n  // State to track if there are unsaved changes\n  bool _hasUnsavedChanges = false;\n\n  // ValueNotifier for PopScope's canPop property\n  // PopScope will automatically wrap this in a PopEntry's canPopNotifier\n  final ValueNotifier<bool> _canPop = ValueNotifier<bool>(true); // Start as pop-able\n\n  @override\n  void dispose() {\n    _canPop.dispose(); // Clean up the notifier\n    super.dispose();\n  }\n\n  void _onTextFieldChanged(String text) {\n    // If the text changes, there are unsaved changes\n    final bool hasChanges = text.isNotEmpty; // Simplified check\n    if (_hasUnsavedChanges != hasChanges) {\n      setState(() {\n        _hasUnsavedChanges = hasChanges;\n        // Update the ValueNotifier based on changes\n        _canPop.value = !_hasUnsavedChanges; // Can pop IF there are NO unsaved changes\n      });\n    }\n  }\n\n  // This callback is called when a pop is invoked, regardless of whether it succeeds.\n  void _onPopInvoked(bool didPop) {\n    print('onPopInvoked called: didPop = $didPop');\n    if (didPop) {\n      // Route was successfully popped - maybe do cleanup here\n       print('Route was popped.');\n    } else {\n      // Pop was blocked (because _canPop.value was false) - show a dialog\n      print('Pop was blocked. Showing confirmation dialog...');\n      _showDiscardChangesDialog();\n    }\n  }\n\n  // Show a dialog asking the user if they want to discard changes\n  Future<void> _showDiscardChangesDialog() async {\n    final bool? discard = await showDialog<bool>(\n      context: context,\n      builder: (BuildContext dialogContext) {\n        return AlertDialog(\n          title: const Text('Discard Changes?'),\n          content: const Text('You have unsaved changes. Do you want to discard them?'),\n          actions: <Widget>[\n            TextButton(\n              child: const Text('Cancel'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(false); // Don't discard\n              },\n            ),\n            TextButton(\n              child: const Text('Discard'),\n              onPressed: () {\n                Navigator.of(dialogContext).pop(true); // Discard changes\n              },\n            ),\n          ],\n        );\n      },\n    );\n\n    if (discard == true) {\n      // User chose to discard changes - allow the pop now\n      // This must be done AFTER the dialog is dismissed\n       Navigator.of(context).pop();\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Wrap the entire screen content in PopScope\n    return PopScope(\n      canPop: _canPop.value, // Control pop-ability using your state\n      onPopInvoked: _onPopInvoked, // Handle pop attempts\n      child: Scaffold(\n        appBar: AppBar(\n          title: const Text('Edit Item'),\n          // AppBar's back button respects the route's popDisposition,\n          // which is influenced by PopScope's canPop.\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              TextField(\n                decoration: const InputDecoration(labelText: 'Item Name'),\n                onChanged: _onTextFieldChanged, // Listen for changes\n              ),\n              const SizedBox(height: 20),\n              Text(\n                _hasUnsavedChanges ? 'You have unsaved changes.' : 'No unsaved changes.',\n                style: TextStyle(color: _hasUnsavedChanges ? Colors.red : Colors.green),\n              ),\n              // Save button (example, not fully implemented pop logic here)\n               // ElevatedButton(\n               //   onPressed: _hasUnsavedChanges ? () {\n               //      // Save logic... then maybe Navigator.of(context).pop(true);\n               //      // After saving, _hasUnsavedChanges would become false,\n               //      // making canPop true again for future back presses.\n               //   } : null,\n               //   child: const Text('Save'),\n               // ),\n            ],\n          ),\n        ),\n      ),\n     );\n  }\n}\n\n// To use this:\n// Navigator.push(\n//   context,\n//   MaterialPageRoute(builder: (context) => const EditItemScreen()),\n// );\n```\n\nIn this example:\n\n1.  We have an `EditItemScreen` that uses a boolean `_hasUnsavedChanges` and a `ValueNotifier<bool> _canPop` to manage its state.\n2.  The `_onTextFieldChanged` method updates `_hasUnsavedChanges` and, crucially, updates `_canPop.value`. When there are unsaved changes, `_canPop.value` becomes `false`.\n3.  The entire `Scaffold` is wrapped in a `PopScope`.\n4.  `PopScope`'s `canPop` property is bound to `_canPop.value`. When `_canPop.value` is false, `PopScope` configures the underlying `PopEntry`'s notifier to be false, telling the route \"Don't pop yet!\".\n5.  `PopScope`'s `onPopInvoked` property is set to our `_onPopInvoked` method.\n6.  When the user presses the back button while `_hasUnsavedChanges` is true:\n    *   The [Navigator](03_overlayroute_.md) initiates a pop.\n    *   The route checks its `popDisposition`.\n    *   The `PopScope`'s underlying `PopEntry` contributes `false` to the check.\n    *   The route's `popDisposition` returns `RoutePopDisposition.doNotPop`.\n    *   The [Navigator](03_overlayroute_.md) *does not* pop the route.\n    *   The route calls `onPopInvokedWithResult(didPop: false, result: null)` on all registered `PopEntry`s.\n    *   Our `_onPopInvoked` method is called with `didPop: false`.\n    *   Inside `_onPopInvoked`, since `didPop` is false, we show the \"Discard Changes?\" dialog.\n    *   If the user chooses \"Discard\", the dialog pops with `true`. We then *manually* call `Navigator.of(context).pop()` again. This time, because we're leaving, we'd typically save or discard changes such that `_hasUnsavedChanges` would be false, making `_canPop.value` true *before* this second pop attempt is processed, and the route *can* be popped.\n\nThis demonstrates how `PopScope` (and thus `PopEntry` underneath) provides a clean way to intercept and react to back navigation based on your screen's state.\n\n### Conclusion\n\nIn this chapter, we introduced `PopEntry`, a modern abstraction to declaratively manage a route's pop behavior and react to pop events. We learned that `PopEntry`s, often created by the `PopScope` widget, use a `canPopNotifier` to signal whether a route should currently be allowed to pop and an `onPopInvokedWithResult` callback to handle the outcome of a pop attempt. Understanding `PopEntry` illuminates how widgets like `PopScope` provide powerful control over navigation within your Flutter applications.\n\nIn the next chapter, we'll explore `RouteAware` and `RouteObserver`, which allow widgets to be notified when the route they are in changes state (e.g., when it becomes the top-most route or is covered by another route).\n\n[Chapter 9: RouteAware](09_routeaware_.md)\n---\n# Chapter 9: RouteAware\n\nWelcome back, future Flutter expert! We've been learning a lot about how Flutter stacks up screens like playing cards ([Route](01_route_.md)s), adding cool animations ([TransitionRoute](02_transitionroute_.md)), layering content on top ([OverlayRoute](03_overlayroute_.md), [ModalRoute](04_modalroute_.md), [PopupRoute](05_popuproute_.md)), handling fancy back gestures ([PredictiveBackRoute](06_predictivebackroute_.md)), and even managing mini-histories within a single screen ([LocalHistoryRoute](07_localhistoryroute_.md), [PopEntry](08_popentry_.md)).\n\nNow, imagine you have a little widget on one of these screens, and this widget needs to know *when* its screen becomes the main focus, or when another screen covers it up, or when its screen is completely removed. For instance, maybe a video player widget on a screen needs to pause the video when another screen pops up, and resume when its screen becomes fully visible again.\n\nThat's where `RouteAware` comes in! It's a way for widgets to \"listen\" for what's happening to the route (screen) they are a part of.\n\n### What is a RouteAware?\n\nThink of a `RouteAware` as a gadget you plug into a widget. This gadget lets the widget receive special messages (notifications) whenever the screen it lives on changes its visibility state relative to the top of the navigation stack.\n\nThese messages tell the widget:\n\n*   \"Your screen is now the very top screen, the user can see and interact with only your screen.\" (`didPopNext` - implies the route *above* it was popped)\n*   \"Your screen just got pushed onto the stack and is now the top screen.\" (`didPush`)\n*   \"Your screen is no longer the top screen because a new screen was pushed on top of it.\" (`didPushNext`)\n*   \"Your screen was completely removed from the navigation stack (like hitting back when it was the first screen).\" (`didPop`)\n\nTo get these messages, your widget needs to somehow register itself with something that *knows* about route changes. This \"something\" is usually a [RouteObserver](10_routeobserver_.md) (which we'll cover in the next chapter).\n\n### Why Use RouteAware?\n\nAs mentioned in the intro, listening to route changes is useful for managing state or behavior in response to navigation. Common scenarios include:\n\n*   **Pausing/resuming animations or media playback:** Stop a video when covered, resume when visible.\n*   **Saving/loading state:** Maybe save temporary data when the screen is about to be covered.\n*   **Tracking analytics:** Log when a screen becomes fully visible.\n*   **Managing resources:** Release resources when a screen is hidden and reallocate them when it becomes active again.\n\nInstead of constantly checking the [Navigator](03_overlayroute_.md) state, a `RouteAware` widget simply defines methods that get called when specific navigation events happen to its route.\n\n### Key Concepts of RouteAware\n\n`RouteAware` is actually a **mixin**. Remember, a mixin is like adding extra abilities to a class. By mixing `RouteAware` into your `State` class for a stateful widget, you give that state object the ability to implement and respond to the specific `RouteAware` methods.\n\nThe key concept is the set of methods it adds:\n\n*   **`didPopNext()`:** Called when the route on top of this route is popped, making this route visible again.\n*   **`didPush()`:** Called when this route is pushed onto the navigator.\n*   **`didPop()`:** Called when this route is popped off the navigator.\n*   **`didPushNext()`:** Called when a new route has been pushed on top of this this route.\n\nYour widget's `State` class will mix in `RouteAware` and provide the code inside these methods to react to the events.\n\n### How RouteAware Works (Conceptual)\n\nHere's a simplified look at how a widget using `RouteAware` gets notified, involving a `RouteObserver`.\n\n```mermaid\nsequenceDiagram\n    participant User as User\n    participant Navigator as Navigator\n    participant RouteObserver as Route Observer\n    participant ScreenARoute as Screen A Route\n    participant ScreenBRoute as Screen B Route\n    participant WidgetA as Widget A (RouteAware)\n    participant WidgetB as Widget B (RouteAware)\n\n    Setup->>RouteObserver: Create Route Observer and give it to Navigator\n    WidgetA->>RouteObserver: Subscribe Widget A to Screen A Route\n    WidgetB->>RouteObserver: Subscribe Widget B to Screen B Route (currently not on stack)\n\n    User->>Navigator: Push ScreenABtn (pushes Screen B Route)\n    Navigator->>RouteObserver: Notify didPush(Screen B), previousRoute: Screen A\n    RouteObserver->>WidgetB: Calls didPush() (enters)\n    RouteObserver->>WidgetA: Calls didPushNext() (covered)\n\n    User->>Navigator: Press Back Btn (Pops Screen B Route)\n    Navigator->>RouteObserver: Notify didPop(Screen B), previousRoute: Screen A\n    RouteObserver->>WidgetB: Calls didPop() (exits)\n    RouteObserver->>WidgetA: Calls didPopNext() (becomes visible again)\n```\n\n1.  You create a `RouteObserver` and provide it to your app's `Navigator` (or `MaterialApp`/`CupertinoApp` using the `navigatorObservers` property).\n2.  Inside your `StatefulWidget`'s `State` (that mixes in `RouteAware`), in the `init` method, you use the `RouteObserver` to **subscribe** this `State` object to notifications for *its* route (`ModalRoute.of(context)`).\n3.  When navigation happens (push, pop), the `Navigator` notifies the `RouteObserver`.\n4.  The `RouteObserver` looks at which routes were involved and calls the appropriate `RouteAware` methods (`didPushNext`, `didPopNext`, `didPop`, `didPush`) on the widgets it knows are subscribed to those routes.\n5.  In the `dispose` method of your `State`, you **unsubscribe** from the `RouteObserver` to prevent memory leaks.\n\nThe key enabler here is the [RouteObserver](10_routeobserver_.md) (next chapter!), which sits in the middle, tracking navigation and calling the `RouteAware` methods on subscribed widgets.\n\n### Looking at the Code\n\nLet's look at the definition of the `RouteAware` mixin.\n\n```dart\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {} // Implies route below this one IS being popped and this is about to become active.\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {} // Implies this route IS being popped (removed).\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n```\n\nAs you can see, it's an abstract mixin with four empty methods. You provide the implementation when you mix it into your `State` class.\n\n### Example: A Widget Aware of Route Changes\n\nLet's create a simple widget that changes the text it displays based on whether its screen is the top-most route.\n\n```dart\nimport 'package:flutter/material.dart'; // For MaterialPageRoute and MaterialApp\nimport 'package:flutter/widgets.dart'; // For State, StatefulWidget\n\n// We'll need a RouteObserver. You typically create this ONCE for your app.\n// For simplicity, let's create it here. Usually, it would be higher up,\n// like in your MaterialApp or a Provider.\nfinal RouteObserver<ModalRoute<dynamic>> routeObserver = RouteObserver<ModalRoute<dynamic>>();\n\n// This is the screen that contains our RouteAware widget.\nclass TrackedScreen extends StatelessWidget {\n  const TrackedScreen({super.key, required this.screenName});\n\n  final String screenName;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('$screenName Screen')),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            // Our RouteAware widget lives here\n            RouteAwareWidget(\n              key: ValueKey(screenName), // Give it a key to differentiate instances\n              routeObserver: routeObserver, // Pass the observer\n              screenName: screenName, // Pass screen name for context\n            ),\n            const SizedBox(height: 20),\n            ElevatedButton(\n              // Button to push a new screen on top\n              onPressed: () {\n                Navigator.of(context).push(\n                  MaterialPageRoute(\n                    builder: (context) => TrackedScreen(screenName: '${screenName} Child'),\n                  ),\n                );\n              },\n              child: const Text('Push New Screen on Top'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// Our custom widget that is aware of its route's state\nclass RouteAwareWidget extends StatefulWidget {\n  const RouteAwareWidget({\n    super.key,\n    required this.routeObserver, // Requires the RouteObserver\n    required this.screenName,\n  });\n\n  final RouteObserver<ModalRoute<dynamic>> routeObserver;\n  final String screenName;\n\n  @override\n  State<RouteAwareWidget> createState() => _RouteAwareWidgetState();\n}\n\n// Mixin RouteAware into the State class\nclass _RouteAwareWidgetState extends State<RouteAwareWidget> with RouteAware {\n\n  String _status = 'Initializing...';\n\n  // Get the route this widget is in\n  ModalRoute<dynamic>? get _route => ModalRoute.of(context);\n\n  @override\n  void initState() {\n    super.initState();\n    // We can't subscribe here because the ModalRoute might not be available yet\n    // or the observer isn't ready. Do it in didChangeDependencies.\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    // Get the route object and subscribe to the observer\n    // Check if _route is not null and the route has changed since the last call\n    final ModalRoute<dynamic>? newRoute = _route; // Get current route\n    final ModalRoute<dynamic>? oldRoute = ModalRoute.of(context, listen: false); // Get previous route without subscribing\n\n    if (newRoute != null && newRoute != oldRoute) { // Only subscribe if route is valid and has changed\n        widget.routeObserver.subscribe(this, newRoute); // THIS is the important part!\n        // Update status based on initial state (when didChangeDependencies is first called after push)\n        _updateStatus(newRoute.isCurrent ? 'pushed (active)' : 'pushed (covered)');\n    }\n  }\n\n\n  @override\n  void dispose() {\n    // ALWAYS unsubscribe when the widget is removed from the tree\n    widget.routeObserver.unsubscribe(this); // Clean up!\n    super.dispose();\n  }\n\n  // --- RouteAware Methods Start ---\n\n  // Called when the route on top of this route is popped\n  @override\n  void didPopNext() {\n    // Route below this one became visible\n    _updateStatus('Became active (didPopNext)');\n  }\n\n  // Called when this route has been pushed\n  // Note: For the initial push, this might be called before didChangeDependencies\n  // where we subscribe. didChangeDependencies is a safer place for initial status check.\n  @override\n  void didPush() {\n    // This route came into view.\n    // _updateStatus('Became active (didPush)'); // Often called before subscription, less reliable for first state\n  }\n\n\n  // Called when this route has been popped\n  @override\n  void didPop() {\n    // This route is leaving.\n    _updateStatus('Was popped (didPop)');\n  }\n\n  // Called when a new route has been pushed on top of this route\n  @override\n  void didPushNext() {\n    // This route is now covered.\n    _updateStatus('Became inactive (didPushNext)');\n  }\n\n  // --- RouteAware Methods End ---\n\n  void _updateStatus(String status) {\n    // Update the widget's state to show the status\n    if (mounted) { // Make sure the widget is still in the tree\n      setState(() {\n        _status = status;\n      });\n       print('[${widget.screenName}] $_status'); // Log to console\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Widget in \"${widget.screenName}\" - Status: $_status');\n  }\n}\n\n// To run this example, you'd set up your MaterialApp with the observer:\n// MaterialApp(\n//   home: const TrackedScreen(screenName: 'Home'),\n//   navigatorObservers: [routeObserver], // Add your observer here!\n// );\n\n```\n\nExplanation:\n\n1.  We create a global `RouteObserver` instance. You'd pass this to your `MaterialApp` or `CupertinoApp` via `navigatorObservers`.\n2.  `TrackedScreen` is a simple wrapper, pushing more `TrackedScreen`s when a button is tapped.\n3.  `RouteAwareWidget` is our custom widget. Its `_RouteAwareWidgetState` mixes in `RouteAware`.\n4.  The `_route` getter helps us easily access the `ModalRoute` this widget is inside.\n5.  Crucially, in `didChangeDependencies`, we get the `_route` and call `widget.routeObserver.subscribe(this, newRoute)`. This registers `this` state object (`RouteAware`) with the observer for the `newRoute` object. We also update the initial status.\n6.  In `dispose`, we call `widget.routeObserver.unsubscribe(this)` to stop receiving notifications and allow the state and its resources to be properly garbage collected.\n7.  We implement the four `RouteAware` methods (`didPopNext`, `didPush`, `didPop`, `didPushNext`). Inside these, we simply update a status string and print to the console so you can see when they are called.\n8.  The `_updateStatus` helper is used to safely update the state and print logs.\n\nWhen you run this and navigate:\n\n*   Pushing \"Home\": `[Home] pushed (active)` (from didChangeDependencies)\n*   Tapping \"Push New Screen\": `[Home] Became inactive (didPushNext)` printed for the Home screen's widget, then `[Home Child] pushed (active)` (from didChangeDependencies) printed for the new screen's widget.\n*   Tapping \"Push New Screen\" again: `[Home Child] Became inactive (didPushNext)` for the second screen's widget, then `[Home Child Child] pushed (active)` for the third screen's widget.\n*   Pressing Back: `[Home Child Child] Was popped (didPop)` for the third screen's widget, then `[Home Child] Became active (didPopNext)` for the second screen's widget.\n*   Pressing Back again: `[Home Child] Was popped (didPop)` for the second screen's widget, then `[Home] Became active (didPopNext)` for the first screen's widget.\n\nThis demonstrates how the `RouteAware` methods are called as screens are pushed and popped on top of the widget's route.\n\n### Conclusion\n\nIn this chapter, we explored `RouteAware`, a mixin that allows Flutter widgets to receive notifications about changes to the visibility status of the route they belong to. We learned about the four key methods (`didPush`, `didPop`, `didPushNext`, `didPopNext`) that get called in response to navigation events. We also saw conceptually how `RouteAware` works together with a [RouteObserver](10_routeobserver_.md) (which we'll dive into next) to deliver these notifications, and how to use `didChangeDependencies` and `dispose` to subscribe and unsubscribe. Understanding `RouteAware` is essential for building widgets that need to react to navigation lifecycle events.\n\nIn the next chapter, we'll look at [RouteObserver](10_routeobserver_.md), the class that tracks navigation and dispatches these `RouteAware` notifications.\n\n[Chapter 10: RouteObserver](10_routeobserver_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/widgets/routes.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'dart:ui';\n/// @docImport 'package:flutter/cupertino.dart';\n/// @docImport 'package:flutter/material.dart';\n///\n/// @docImport 'app.dart';\n/// @docImport 'form.dart';\n/// @docImport 'heroes.dart';\n/// @docImport 'pages.dart';\n/// @docImport 'pop_scope.dart';\n/// @docImport 'will_pop_scope.dart';\nlibrary;\n\nimport 'dart:async';\nimport 'dart:math';\nimport 'dart:ui' as ui;\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/rendering.dart';\nimport 'package:flutter/scheduler.dart';\nimport 'package:flutter/services.dart';\n\nimport 'actions.dart';\nimport 'basic.dart';\nimport 'display_feature_sub_screen.dart';\nimport 'focus_manager.dart';\nimport 'focus_scope.dart';\nimport 'focus_traversal.dart';\nimport 'framework.dart';\nimport 'inherited_model.dart';\nimport 'modal_barrier.dart';\nimport 'navigator.dart';\nimport 'overlay.dart';\nimport 'page_storage.dart';\nimport 'primary_scroll_controller.dart';\nimport 'restoration.dart';\nimport 'scroll_controller.dart';\nimport 'transitions.dart';\n\n// Examples can assume:\n// late NavigatorState navigator;\n// late BuildContext context;\n// Future<bool> askTheUserIfTheyAreSure() async { return true; }\n// abstract class MyWidget extends StatefulWidget { const MyWidget({super.key}); }\n// late dynamic _myState, newValue;\n// late StateSetter setState;\n\n/// A route that displays widgets in the [Navigator]'s [Overlay].\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class OverlayRoute<T> extends Route<T> {\n  /// Creates a route that knows how to interact with an [Overlay].\n  OverlayRoute({super.settings, super.requestFocus});\n\n  /// Subclasses should override this getter to return the builders for the overlay.\n  @factory\n  Iterable<OverlayEntry> createOverlayEntries();\n\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n\n  @override\n  void install() {\n    assert(_overlayEntries.isEmpty);\n    _overlayEntries.addAll(createOverlayEntries());\n    super.install();\n  }\n\n  /// Controls whether [didPop] calls [NavigatorState.finalizeRoute].\n  ///\n  /// If true, this route removes its overlay entries during [didPop].\n  /// Subclasses can override this getter if they want to delay finalization\n  /// (for example to animate the route's exit before removing it from the\n  /// overlay).\n  ///\n  /// Subclasses that return false from [finishedWhenPopped] are responsible for\n  /// calling [NavigatorState.finalizeRoute] themselves.\n  @protected\n  bool get finishedWhenPopped => true;\n\n  @override\n  bool didPop(T? result) {\n    final bool returnValue = super.didPop(result);\n    assert(returnValue);\n    if (finishedWhenPopped) {\n      navigator!.finalizeRoute(this);\n    }\n    return returnValue;\n  }\n\n  @override\n  void dispose() {\n    for (final OverlayEntry entry in _overlayEntries) {\n      entry.dispose();\n    }\n    _overlayEntries.clear();\n    super.dispose();\n  }\n}\n\n/// A route with entrance and exit transitions.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nabstract class TransitionRoute<T> extends OverlayRoute<T> implements PredictiveBackRoute {\n  /// Creates a route that animates itself when it is pushed or popped.\n  TransitionRoute({super.settings, super.requestFocus});\n\n  /// This future completes only once the transition itself has finished, after\n  /// the overlay entries have been removed from the navigator's overlay.\n  ///\n  /// This future completes once the animation has been dismissed. That will be\n  /// after [popped], because [popped] typically completes before the animation\n  /// even starts, as soon as the route is popped.\n  Future<T?> get completed => _transitionCompleter.future;\n  final Completer<T?> _transitionCompleter = Completer<T?>();\n\n  /// Handle to the performance mode request.\n  ///\n  /// When the route is animating, the performance mode is requested. It is then\n  /// disposed when the animation ends. Requesting [DartPerformanceMode.latency]\n  /// indicates to the engine that the transition is latency sensitive and to delay\n  /// non-essential work while this handle is active.\n  PerformanceModeRequestHandle? _performanceModeRequestHandle;\n\n  /// {@template flutter.widgets.TransitionRoute.transitionDuration}\n  /// The duration the transition going forwards.\n  ///\n  /// See also:\n  ///\n  /// * [reverseTransitionDuration], which controls the duration of the\n  /// transition when it is in reverse.\n  /// {@endtemplate}\n  Duration get transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.reverseTransitionDuration}\n  /// The duration the transition going in reverse.\n  ///\n  /// By default, the reverse transition duration is set to the value of\n  /// the forwards [transitionDuration].\n  /// {@endtemplate}\n  Duration get reverseTransitionDuration => transitionDuration;\n\n  /// {@template flutter.widgets.TransitionRoute.opaque}\n  /// Whether the route obscures previous routes when the transition is complete.\n  ///\n  /// When an opaque route's entrance transition is complete, the routes behind\n  /// the opaque route will not be built to save resources.\n  /// {@endtemplate}\n  bool get opaque;\n\n  /// {@template flutter.widgets.TransitionRoute.allowSnapshotting}\n  /// Whether the route transition will prefer to animate a snapshot of the\n  /// entering/exiting routes.\n  ///\n  /// When this value is true, certain route transitions (such as the Android\n  /// zoom page transition) will snapshot the entering and exiting routes.\n  /// These snapshots are then animated in place of the underlying widgets to\n  /// improve performance of the transition.\n  ///\n  /// Generally this means that animations that occur on the entering/exiting\n  /// route while the route animation plays may appear frozen - unless they\n  /// are a hero animation or something that is drawn in a separate overlay.\n  /// {@endtemplate}\n  bool get allowSnapshotting => true;\n\n  // This ensures that if we got to the dismissed state while still current,\n  // we will still be disposed when we are eventually popped.\n  //\n  // This situation arises when dealing with the Cupertino dismiss gesture.\n  @override\n  bool get finishedWhenPopped => _controller!.isDismissed && !_popFinalized;\n\n  bool _popFinalized = false;\n\n  /// The animation that drives the route's transition and the previous route's\n  /// forward transition.\n  Animation<double>? get animation => _animation;\n  Animation<double>? _animation;\n\n  /// The animation controller that the route uses to drive the transitions.\n  ///\n  /// The animation itself is exposed by the [animation] property.\n  @protected\n  AnimationController? get controller => _controller;\n  AnimationController? _controller;\n\n  /// The animation for the route being pushed on top of this route. This\n  /// animation lets this route coordinate with the entrance and exit transition\n  /// of route pushed on top of this route.\n  Animation<double>? get secondaryAnimation => _secondaryAnimation;\n  final ProxyAnimation _secondaryAnimation = ProxyAnimation(kAlwaysDismissedAnimation);\n\n  /// Whether to takeover the [controller] created by [createAnimationController].\n  ///\n  /// If true, this route will call [AnimationController.dispose] when the\n  /// controller is no longer needed.\n  /// If false, the controller should be disposed by whoever owned it.\n  ///\n  /// It defaults to `true`.\n  bool willDisposeAnimationController = true;\n\n  /// Returns true if the transition has completed.\n  ///\n  /// It is equivalent to whether the future returned by [completed] has\n  /// completed.\n  ///\n  /// This method only works if assert is enabled. Otherwise it always returns\n  /// false.\n  @protected\n  bool debugTransitionCompleted() {\n    bool disposed = false;\n    assert(() {\n      disposed = _transitionCompleter.isCompleted;\n      return true;\n    }());\n    return disposed;\n  }\n\n  /// Called to create the animation controller that will drive the transitions to\n  /// this route from the previous one, and back to the previous route from this\n  /// one.\n  ///\n  /// The returned controller will be disposed by [AnimationController.dispose]\n  /// if the [willDisposeAnimationController] is `true`.\n  AnimationController createAnimationController() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    final Duration duration = transitionDuration;\n    final Duration reverseDuration = reverseTransitionDuration;\n    return AnimationController(\n      duration: duration,\n      reverseDuration: reverseDuration,\n      debugLabel: debugLabel,\n      vsync: navigator!,\n    );\n  }\n\n  /// Called to create the animation that exposes the current progress of\n  /// the transition controlled by the animation controller created by\n  /// [createAnimationController()].\n  Animation<double> createAnimation() {\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    assert(_controller != null);\n    return _controller!.view;\n  }\n\n  Simulation? _simulation;\n\n  /// Creates the simulation that drives the transition animation for this route.\n  ///\n  /// By default, this method returns null, indicating that the route doesn't\n  /// use simulations, but initiates the transition by calling either\n  /// [AnimationController.forward] or [AnimationController.reverse] with\n  /// [transitionDuration] and the controller's curve.\n  ///\n  /// Subclasses can override this method to return a non-null [Simulation]. In\n  /// this case, the [controller] will instead use the provided simulation to\n  /// animate the transition using [AnimationController.animateWith] or\n  /// [AnimationController.animateBackWith], and the [Simulation.x] is forwarded\n  /// to the value of [animation]. The [controller]'s curve and\n  /// [transitionDuration] are ignored.\n  ///\n  /// This method is invoked each time the navigator pushes or pops this route.\n  /// The `forward` parameter indicates the direction of the transition: true when\n  /// the route is pushed, and false when it is popped.\n  Simulation? createSimulation({required bool forward}) {\n    assert(\n      transitionDuration >= Duration.zero,\n      'The `duration` must be positive for a non-simulation animation. Received $transitionDuration.',\n    );\n    return null;\n  }\n\n  Simulation? _createSimulationAndVerify({required bool forward}) {\n    final Simulation? simulation = createSimulation(forward: forward);\n    assert(\n      transitionDuration >= Duration.zero,\n      \"The `duration` must be positive for an animation that doesn't use simulation. \"\n      'Either set `transitionDuration` or set `createSimulation`. '\n      'Received $transitionDuration.',\n    );\n    return simulation;\n  }\n\n  T? _result;\n\n  void _handleStatusChanged(AnimationStatus status) {\n    switch (status) {\n      case AnimationStatus.completed:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = opaque;\n        }\n        _performanceModeRequestHandle?.dispose();\n        _performanceModeRequestHandle = null;\n      case AnimationStatus.forward:\n      case AnimationStatus.reverse:\n        if (overlayEntries.isNotEmpty) {\n          overlayEntries.first.opaque = false;\n        }\n        _performanceModeRequestHandle ??= SchedulerBinding.instance.requestPerformanceMode(\n          ui.DartPerformanceMode.latency,\n        );\n      case AnimationStatus.dismissed:\n        // We might still be an active route if a subclass is controlling the\n        // transition and hits the dismissed status. For example, the iOS\n        // back gesture drives this animation to the dismissed status before\n        // removing the route and disposing it.\n        if (!isActive) {\n          navigator!.finalizeRoute(this);\n          _popFinalized = true;\n          _performanceModeRequestHandle?.dispose();\n          _performanceModeRequestHandle = null;\n        }\n    }\n  }\n\n  @override\n  void install() {\n    assert(!debugTransitionCompleted(), 'Cannot install a $runtimeType after disposing it.');\n    _controller = createAnimationController();\n    assert(_controller != null, '$runtimeType.createAnimationController() returned null.');\n    _animation = createAnimation()..addStatusListener(_handleStatusChanged);\n    assert(_animation != null, '$runtimeType.createAnimation() returned null.');\n    super.install();\n    if (_animation!.isCompleted && overlayEntries.isNotEmpty) {\n      overlayEntries.first.opaque = opaque;\n    }\n  }\n\n  @override\n  TickerFuture didPush() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didPush();\n    _simulation = _createSimulationAndVerify(forward: true);\n    if (_simulation == null) {\n      return _controller!.forward();\n    } else {\n      return _controller!.animateWith(_simulation!);\n    }\n  }\n\n  @override\n  void didAdd() {\n    assert(\n      _controller != null,\n      '$runtimeType.didPush called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    super.didAdd();\n    _controller!.value = _controller!.upperBound;\n  }\n\n  @override\n  void didReplace(Route<dynamic>? oldRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didReplace called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    if (oldRoute is TransitionRoute) {\n      _controller!.value = oldRoute._controller!.value;\n    }\n    super.didReplace(oldRoute);\n  }\n\n  @override\n  bool didPop(T? result) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPop called before calling install() or after calling dispose().',\n    );\n    assert(!_transitionCompleter.isCompleted, 'Cannot reuse a $runtimeType after disposing it.');\n    _result = result;\n    _simulation = _createSimulationAndVerify(forward: false);\n    if (_simulation == null) {\n      _controller!.reverse();\n    } else {\n      _controller!.animateBackWith(_simulation!);\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didPopNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didPopNext(nextRoute);\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    assert(\n      _controller != null,\n      '$runtimeType.didChangeNext called before calling install() or after calling dispose().',\n    );\n    assert(!debugTransitionCompleted(), 'Cannot reuse a $runtimeType after disposing it.');\n    _updateSecondaryAnimation(nextRoute);\n    super.didChangeNext(nextRoute);\n  }\n\n  // A callback method that disposes existing train hopping animation and\n  // removes its listener.\n  //\n  // This property is non-null if there is a train hopping in progress, and the\n  // caller must reset this property to null after it is called.\n  VoidCallback? _trainHoppingListenerRemover;\n\n  void _updateSecondaryAnimation(Route<dynamic>? nextRoute) {\n    // There is an existing train hopping in progress. Unfortunately, we cannot\n    // dispose current train hopping animation until we replace it with a new\n    // animation.\n    final VoidCallback? previousTrainHoppingListenerRemover = _trainHoppingListenerRemover;\n    _trainHoppingListenerRemover = null;\n\n    if (nextRoute is TransitionRoute<dynamic> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.canTransitionFrom(this)) {\n      final Animation<double>? current = _secondaryAnimation.parent;\n      if (current != null) {\n        final Animation<double> currentTrain =\n            (current is TrainHoppingAnimation ? current.currentTrain : current)!;\n        final Animation<double> nextTrain = nextRoute._animation!;\n        if (currentTrain.value == nextTrain.value || !nextTrain.isAnimating) {\n          _setSecondaryAnimation(nextTrain, nextRoute.completed);\n        } else {\n          // Two trains animate at different values. We have to do train hopping.\n          // There are three possibilities of train hopping:\n          //  1. We hop on the nextTrain when two trains meet in the middle using\n          //     TrainHoppingAnimation.\n          //  2. There is no chance to hop on nextTrain because two trains never\n          //     cross each other. We have to directly set the animation to\n          //     nextTrain once the nextTrain stops animating.\n          //  3. A new _updateSecondaryAnimation is called before train hopping\n          //     finishes. We leave a listener remover for the next call to\n          //     properly clean up the existing train hopping.\n          TrainHoppingAnimation? newAnimation;\n          void jumpOnAnimationEnd(AnimationStatus status) {\n            if (!status.isAnimating) {\n              // The nextTrain has stopped animating without train hopping.\n              // Directly sets the secondary animation and disposes the\n              // TrainHoppingAnimation.\n              _setSecondaryAnimation(nextTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            }\n          }\n\n          _trainHoppingListenerRemover = () {\n            nextTrain.removeStatusListener(jumpOnAnimationEnd);\n            newAnimation?.dispose();\n          };\n          nextTrain.addStatusListener(jumpOnAnimationEnd);\n          newAnimation = TrainHoppingAnimation(\n            currentTrain,\n            nextTrain,\n            onSwitchedTrain: () {\n              assert(_secondaryAnimation.parent == newAnimation);\n              assert(newAnimation!.currentTrain == nextRoute._animation);\n              // We can hop on the nextTrain, so we don't need to listen to\n              // whether the nextTrain has stopped.\n              _setSecondaryAnimation(newAnimation!.currentTrain, nextRoute.completed);\n              if (_trainHoppingListenerRemover != null) {\n                _trainHoppingListenerRemover!();\n                _trainHoppingListenerRemover = null;\n              }\n            },\n          );\n          _setSecondaryAnimation(newAnimation, nextRoute.completed);\n        }\n      } else {\n        _setSecondaryAnimation(nextRoute._animation, nextRoute.completed);\n      }\n    } else {\n      _setSecondaryAnimation(kAlwaysDismissedAnimation);\n    }\n    // Finally, we dispose any previous train hopping animation because it\n    // has been successfully updated at this point.\n    previousTrainHoppingListenerRemover?.call();\n  }\n\n  void _setSecondaryAnimation(Animation<double>? animation, [Future<dynamic>? disposed]) {\n    _secondaryAnimation.parent = animation;\n    // Releases the reference to the next route's animation when that route\n    // is disposed.\n    disposed?.then((dynamic _) {\n      if (_secondaryAnimation.parent == animation) {\n        _secondaryAnimation.parent = kAlwaysDismissedAnimation;\n        if (animation is TrainHoppingAnimation) {\n          animation.dispose();\n        }\n      }\n    });\n  }\n\n  /// Returns true if this route supports a transition animation that runs\n  /// when [nextRoute] is pushed on top of it or when [nextRoute] is popped\n  /// off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `nextRoute.canTransitionFrom()` is true, then the\n  /// [ModalRoute.buildTransitions] `secondaryAnimation` will run from 0.0 - 1.0\n  /// when [nextRoute] is pushed on top of this one. Similarly, if\n  /// the [nextRoute] is popped off of this route, the\n  /// `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, this route's [ModalRoute.buildTransitions] `secondaryAnimation` parameter\n  /// value will be [kAlwaysDismissedAnimation]. In other words, this route\n  /// will not animate when [nextRoute] is pushed on top of it or when\n  /// [nextRoute] is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionFrom], which must be true for [nextRoute] for the\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionTo(TransitionRoute<dynamic> nextRoute) => true;\n\n  /// Returns true if [previousRoute] should animate when this route\n  /// is pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Subclasses can override this method to restrict the set of routes they\n  /// need to coordinate transitions with.\n  ///\n  /// If true, and `previousRoute.canTransitionTo()` is true, then the\n  /// previous route's [ModalRoute.buildTransitions] `secondaryAnimation` will\n  /// run from 0.0 - 1.0 when this route is pushed on top of\n  /// it. Similarly, if this route is popped off of [previousRoute]\n  /// the previous route's `secondaryAnimation` will run from 1.0 - 0.0.\n  ///\n  /// If false, then the previous route's [ModalRoute.buildTransitions]\n  /// `secondaryAnimation` value will be kAlwaysDismissedAnimation. In\n  /// other words [previousRoute] will not animate when this route is\n  /// pushed on top of it or when then this route is popped off of it.\n  ///\n  /// Returns true by default.\n  ///\n  /// See also:\n  ///\n  ///  * [canTransitionTo], which must be true for [previousRoute] for its\n  ///    [ModalRoute.buildTransitions] `secondaryAnimation` to run.\n  bool canTransitionFrom(TransitionRoute<dynamic> previousRoute) => true;\n\n  // Begin PredictiveBackRoute.\n\n  @override\n  void handleStartBackGesture({double progress = 0.0}) {\n    assert(isCurrent);\n    _controller?.value = progress;\n    navigator?.didStartUserGesture();\n  }\n\n  @override\n  void handleUpdateBackGestureProgress({required double progress}) {\n    // If some other navigation happened during this gesture, don't mess with\n    // the transition anymore.\n    if (!isCurrent) {\n      return;\n    }\n    _controller?.value = progress;\n  }\n\n  @override\n  void handleCancelBackGesture() {\n    _handleDragEnd(animateForward: true);\n  }\n\n  @override\n  void handleCommitBackGesture() {\n    _handleDragEnd(animateForward: false);\n  }\n\n  void _handleDragEnd({required bool animateForward}) {\n    if (isCurrent) {\n      if (animateForward) {\n        // The closer the panel is to dismissing, the shorter the animation is.\n        // We want to cap the animation time, but we want to use a linear curve\n        // to determine it.\n        // These values were eyeballed to match the native predictive back\n        // animation on a Pixel 2 running Android API 34.\n        final int droppedPageForwardAnimationTime = min(\n          ui.lerpDouble(800, 0, _controller!.value)!.floor(),\n          300,\n        );\n        _controller?.animateTo(\n          1.0,\n          duration: Duration(milliseconds: droppedPageForwardAnimationTime),\n          curve: Curves.fastLinearToSlowEaseIn,\n        );\n      } else {\n        // This route is destined to pop at this point. Reuse navigator's pop.\n        navigator?.pop();\n\n        // The popping may have finished inline if already at the target destination.\n        if (_controller?.isAnimating ?? false) {\n          // Otherwise, use a custom popping animation duration and curve.\n          final int droppedPageBackAnimationTime =\n              ui.lerpDouble(0, 800, _controller!.value)!.floor();\n          _controller!.animateBack(\n            0.0,\n            duration: Duration(milliseconds: droppedPageBackAnimationTime),\n            curve: Curves.fastLinearToSlowEaseIn,\n          );\n        }\n      }\n    }\n\n    if (_controller?.isAnimating ?? false) {\n      // Keep the userGestureInProgress in true state since AndroidBackGesturePageTransitionsBuilder\n      // depends on userGestureInProgress.\n      late final AnimationStatusListener animationStatusCallback;\n      animationStatusCallback = (AnimationStatus status) {\n        navigator?.didStopUserGesture();\n        _controller!.removeStatusListener(animationStatusCallback);\n      };\n      _controller!.addStatusListener(animationStatusCallback);\n    } else {\n      navigator?.didStopUserGesture();\n    }\n  }\n\n  // End PredictiveBackRoute.\n\n  @override\n  void dispose() {\n    assert(!_transitionCompleter.isCompleted, 'Cannot dispose a $runtimeType twice.');\n    assert(!debugTransitionCompleted(), 'Cannot dispose a $runtimeType twice.');\n    _animation?.removeStatusListener(_handleStatusChanged);\n    _performanceModeRequestHandle?.dispose();\n    _performanceModeRequestHandle = null;\n    if (willDisposeAnimationController) {\n      _controller?.dispose();\n    }\n    _transitionCompleter.complete(_result);\n    super.dispose();\n  }\n\n  /// A short description of this route useful for debugging.\n  String get debugLabel => objectRuntimeType(this, 'TransitionRoute');\n\n  @override\n  String toString() => '${objectRuntimeType(this, 'TransitionRoute')}(animation: $_controller)';\n}\n\n/// An interface for a route that supports predictive back gestures.\n///\n/// See also:\n///\n///  * [PredictiveBackPageTransitionsBuilder], which builds page transitions for\n///    predictive back.\nabstract interface class PredictiveBackRoute {\n  /// Whether this route is the top-most route on the navigator.\n  bool get isCurrent;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  bool get popGestureEnabled;\n\n  /// Handles a predictive back gesture starting.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleStartBackGesture({double progress = 0.0});\n\n  /// Handles a predictive back gesture updating as the user drags across the\n  /// screen.\n  ///\n  /// The `progress` parameter indicates the progress of the gesture from 0.0 to\n  /// 1.0, as in [PredictiveBackEvent.progress].\n  void handleUpdateBackGestureProgress({required double progress});\n\n  /// Handles a predictive back gesture ending successfully.\n  void handleCommitBackGesture();\n\n  /// Handles a predictive back gesture ending in cancellation.\n  void handleCancelBackGesture();\n}\n\n/// An entry in the history of a [LocalHistoryRoute].\nclass LocalHistoryEntry {\n  /// Creates an entry in the history of a [LocalHistoryRoute].\n  ///\n  /// The [impliesAppBarDismissal] defaults to true if not provided.\n  LocalHistoryEntry({this.onRemove, this.impliesAppBarDismissal = true});\n\n  /// Called when this entry is removed from the history of its associated [LocalHistoryRoute].\n  final VoidCallback? onRemove;\n\n  LocalHistoryRoute<dynamic>? _owner;\n\n  /// Whether an [AppBar] in the route this entry belongs to should\n  /// automatically add a back button or close button.\n  ///\n  /// Defaults to true.\n  final bool impliesAppBarDismissal;\n\n  /// Remove this entry from the history of its associated [LocalHistoryRoute].\n  void remove() {\n    _owner?.removeLocalHistoryEntry(this);\n    assert(_owner == null);\n  }\n\n  void _notifyRemoved() {\n    onRemove?.call();\n  }\n}\n\n/// A mixin used by routes to handle back navigations internally by popping a list.\n///\n/// When a [Navigator] is instructed to pop, the current route is given an\n/// opportunity to handle the pop internally. A [LocalHistoryRoute] handles the\n/// pop internally if its list of local history entries is non-empty. Rather\n/// than being removed as the current route, the most recent [LocalHistoryEntry]\n/// is removed from the list and its [LocalHistoryEntry.onRemove] is called.\n///\n/// See also:\n///\n///  * [Route], which documents the meaning of the `T` generic type argument.\nmixin LocalHistoryRoute<T> on Route<T> {\n  List<LocalHistoryEntry>? _localHistory;\n  int _entriesImpliesAppBarDismissal = 0;\n\n  /// Adds a local history entry to this route.\n  ///\n  /// When asked to pop, if this route has any local history entries, this route\n  /// will handle the pop internally by removing the most recently added local\n  /// history entry.\n  ///\n  /// The given local history entry must not already be part of another local\n  /// history route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// The following example is an app with 2 pages: `HomePage` and `SecondPage`.\n  /// The `HomePage` can navigate to the `SecondPage`.\n  ///\n  /// The `SecondPage` uses a [LocalHistoryEntry] to implement local navigation\n  /// within that page. Pressing 'show rectangle' displays a red rectangle and\n  /// adds a local history entry. At that point, pressing the '< back' button\n  /// pops the latest route, which is the local history entry, and the red\n  /// rectangle disappears. Pressing the '< back' button a second time\n  /// once again pops the latest route, which is the `SecondPage`, itself.\n  /// Therefore, the second press navigates back to the `HomePage`.\n  ///\n  /// ```dart\n  /// class App extends StatelessWidget {\n  ///   const App({super.key});\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return MaterialApp(\n  ///       initialRoute: '/',\n  ///       routes: <String, WidgetBuilder>{\n  ///         '/': (BuildContext context) => const HomePage(),\n  ///         '/second_page': (BuildContext context) => const SecondPage(),\n  ///       },\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class HomePage extends StatefulWidget {\n  ///   const HomePage({super.key});\n  ///\n  ///   @override\n  ///   State<HomePage> createState() => _HomePageState();\n  /// }\n  ///\n  /// class _HomePageState extends State<HomePage> {\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisSize: MainAxisSize.min,\n  ///           children: <Widget>[\n  ///             const Text('HomePage'),\n  ///             // Press this button to open the SecondPage.\n  ///             ElevatedButton(\n  ///               child: const Text('Second Page >'),\n  ///               onPressed: () {\n  ///                 Navigator.pushNamed(context, '/second_page');\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  ///\n  /// class SecondPage extends StatefulWidget {\n  ///   const SecondPage({super.key});\n  ///\n  ///   @override\n  ///   State<SecondPage> createState() => _SecondPageState();\n  /// }\n  ///\n  /// class _SecondPageState extends State<SecondPage> {\n  ///\n  ///   bool _showRectangle = false;\n  ///\n  ///   Future<void> _navigateLocallyToShowRectangle() async {\n  ///     // This local history entry essentially represents the display of the red\n  ///     // rectangle. When this local history entry is removed, we hide the red\n  ///     // rectangle.\n  ///     setState(() => _showRectangle = true);\n  ///     ModalRoute.of(context)?.addLocalHistoryEntry(\n  ///         LocalHistoryEntry(\n  ///             onRemove: () {\n  ///               // Hide the red rectangle.\n  ///               setState(() => _showRectangle = false);\n  ///             }\n  ///         )\n  ///     );\n  ///   }\n  ///\n  ///   @override\n  ///   Widget build(BuildContext context) {\n  ///     final Widget localNavContent = _showRectangle\n  ///       ? Container(\n  ///           width: 100.0,\n  ///           height: 100.0,\n  ///           color: Colors.red,\n  ///         )\n  ///       : ElevatedButton(\n  ///           onPressed: _navigateLocallyToShowRectangle,\n  ///           child: const Text('Show Rectangle'),\n  ///         );\n  ///\n  ///     return Scaffold(\n  ///       body: Center(\n  ///         child: Column(\n  ///           mainAxisAlignment: MainAxisAlignment.center,\n  ///           children: <Widget>[\n  ///             localNavContent,\n  ///             ElevatedButton(\n  ///               child: const Text('< Back'),\n  ///               onPressed: () {\n  ///                 // Pop a route. If this is pressed while the red rectangle is\n  ///                 // visible then it will pop our local history entry, which\n  ///                 // will hide the red rectangle. Otherwise, the SecondPage will\n  ///                 // navigate back to the HomePage.\n  ///                 Navigator.of(context).pop();\n  ///               },\n  ///             ),\n  ///           ],\n  ///         ),\n  ///       ),\n  ///     );\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  void addLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == null);\n    entry._owner = this;\n    _localHistory ??= <LocalHistoryEntry>[];\n    final bool wasEmpty = _localHistory!.isEmpty;\n    _localHistory!.add(entry);\n    bool internalStateChanged = false;\n    if (entry.impliesAppBarDismissal) {\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      _entriesImpliesAppBarDismissal += 1;\n    }\n    if (wasEmpty || internalStateChanged) {\n      changedInternalState();\n    }\n  }\n\n  /// Remove a local history entry from this route.\n  ///\n  /// The entry's [LocalHistoryEntry.onRemove] callback, if any, will be called\n  /// synchronously.\n  void removeLocalHistoryEntry(LocalHistoryEntry entry) {\n    assert(entry._owner == this);\n    assert(_localHistory!.contains(entry));\n    bool internalStateChanged = false;\n    if (_localHistory!.remove(entry) && entry.impliesAppBarDismissal) {\n      _entriesImpliesAppBarDismissal -= 1;\n      internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n    }\n    entry._owner = null;\n    entry._notifyRemoved();\n    if (_localHistory!.isEmpty || internalStateChanged) {\n      assert(_entriesImpliesAppBarDismissal == 0);\n      if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n        // The local history might be removed as a result of disposing inactive\n        // elements during finalizeTree. The state is locked at this moment, and\n        // we can only notify state has changed in the next frame.\n        SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n          if (isActive) {\n            changedInternalState();\n          }\n        }, debugLabel: 'LocalHistoryRoute.changedInternalState');\n      } else {\n        changedInternalState();\n      }\n    }\n  }\n\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.willPop();\n  }\n\n  @override\n  RoutePopDisposition get popDisposition {\n    if (willHandlePopInternally) {\n      return RoutePopDisposition.pop;\n    }\n    return super.popDisposition;\n  }\n\n  @override\n  bool didPop(T? result) {\n    if (_localHistory != null && _localHistory!.isNotEmpty) {\n      final LocalHistoryEntry entry = _localHistory!.removeLast();\n      assert(entry._owner == this);\n      entry._owner = null;\n      entry._notifyRemoved();\n      bool internalStateChanged = false;\n      if (entry.impliesAppBarDismissal) {\n        _entriesImpliesAppBarDismissal -= 1;\n        internalStateChanged = _entriesImpliesAppBarDismissal == 0;\n      }\n      if (_localHistory!.isEmpty || internalStateChanged) {\n        changedInternalState();\n      }\n      return false;\n    }\n    return super.didPop(result);\n  }\n\n  @override\n  bool get willHandlePopInternally {\n    return _localHistory != null && _localHistory!.isNotEmpty;\n  }\n}\n\nclass _DismissModalAction extends DismissAction {\n  _DismissModalAction(this.context);\n\n  final BuildContext context;\n\n  @override\n  bool isEnabled(DismissIntent intent) {\n    final ModalRoute<dynamic> route = ModalRoute.of<dynamic>(context)!;\n    return route.barrierDismissible;\n  }\n\n  @override\n  Object invoke(DismissIntent intent) {\n    return Navigator.of(context).maybePop();\n  }\n}\n\nenum _ModalRouteAspect {\n  /// Specifies the aspect corresponding to [ModalRoute.isCurrent].\n  isCurrent,\n\n  /// Specifies the aspect corresponding to [ModalRoute.canPop].\n  canPop,\n\n  /// Specifies the aspect corresponding to [ModalRoute.settings].\n  settings,\n}\n\nclass _ModalScopeStatus extends InheritedModel<_ModalRouteAspect> {\n  const _ModalScopeStatus({\n    required this.isCurrent,\n    required this.canPop,\n    required this.impliesAppBarDismissal,\n    required this.route,\n    required super.child,\n  });\n\n  final bool isCurrent;\n  final bool canPop;\n  final bool impliesAppBarDismissal;\n  final Route<dynamic> route;\n\n  @override\n  bool updateShouldNotify(_ModalScopeStatus old) {\n    return isCurrent != old.isCurrent ||\n        canPop != old.canPop ||\n        impliesAppBarDismissal != old.impliesAppBarDismissal ||\n        route != old.route;\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder description) {\n    super.debugFillProperties(description);\n    description.add(\n      FlagProperty('isCurrent', value: isCurrent, ifTrue: 'active', ifFalse: 'inactive'),\n    );\n    description.add(FlagProperty('canPop', value: canPop, ifTrue: 'can pop'));\n    description.add(\n      FlagProperty(\n        'impliesAppBarDismissal',\n        value: impliesAppBarDismissal,\n        ifTrue: 'implies app bar dismissal',\n      ),\n    );\n  }\n\n  @override\n  bool updateShouldNotifyDependent(\n    covariant _ModalScopeStatus oldWidget,\n    Set<_ModalRouteAspect> dependencies,\n  ) {\n    return dependencies.any(\n      (_ModalRouteAspect dependency) => switch (dependency) {\n        _ModalRouteAspect.isCurrent => isCurrent != oldWidget.isCurrent,\n        _ModalRouteAspect.canPop => canPop != oldWidget.canPop,\n        _ModalRouteAspect.settings => route.settings != oldWidget.route.settings,\n      },\n    );\n  }\n}\n\nclass _ModalScope<T> extends StatefulWidget {\n  const _ModalScope({super.key, required this.route});\n\n  final ModalRoute<T> route;\n\n  @override\n  _ModalScopeState<T> createState() => _ModalScopeState<T>();\n}\n\nclass _ModalScopeState<T> extends State<_ModalScope<T>> {\n  // We cache the result of calling the route's buildPage, and clear the cache\n  // whenever the dependencies change. This implements the contract described in\n  // the documentation for buildPage, namely that it gets called once, unless\n  // something like a ModalRoute.of() dependency triggers an update.\n  Widget? _page;\n\n  // This is the combination of the two animations for the route.\n  late Listenable _listenable;\n\n  /// The node this scope will use for its root [FocusScope] widget.\n  final FocusScopeNode focusScopeNode = FocusScopeNode(debugLabel: '$_ModalScopeState Focus Scope');\n  final ScrollController primaryScrollController = ScrollController();\n\n  @override\n  void initState() {\n    super.initState();\n    final List<Listenable> animations = <Listenable>[\n      if (widget.route.animation != null) widget.route.animation!,\n      if (widget.route.secondaryAnimation != null) widget.route.secondaryAnimation!,\n    ];\n    _listenable = Listenable.merge(animations);\n  }\n\n  @override\n  void didUpdateWidget(_ModalScope<T> oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    assert(widget.route == oldWidget.route);\n    _updateFocusScopeNode();\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    _page = null;\n    _updateFocusScopeNode();\n  }\n\n  void _updateFocusScopeNode() {\n    final TraversalEdgeBehavior traversalEdgeBehavior;\n    final ModalRoute<T> route = widget.route;\n    if (route.traversalEdgeBehavior != null) {\n      traversalEdgeBehavior = route.traversalEdgeBehavior!;\n    } else {\n      traversalEdgeBehavior = route.navigator!.widget.routeTraversalEdgeBehavior;\n    }\n    focusScopeNode.traversalEdgeBehavior = traversalEdgeBehavior;\n    if (route.isCurrent && _shouldRequestFocus) {\n      route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n  }\n\n  void _forceRebuildPage() {\n    setState(() {\n      _page = null;\n    });\n  }\n\n  @override\n  void dispose() {\n    focusScopeNode.dispose();\n    primaryScrollController.dispose();\n    super.dispose();\n  }\n\n  bool get _shouldIgnoreFocusRequest {\n    return widget.route.animation?.status == AnimationStatus.reverse ||\n        (widget.route.navigator?.userGestureInProgress ?? false);\n  }\n\n  bool get _shouldRequestFocus {\n    return widget.route.requestFocus;\n  }\n\n  // This should be called to wrap any changes to route.isCurrent, route.canPop,\n  // and route.offstage.\n  void _routeSetState(VoidCallback fn) {\n    if (widget.route.isCurrent && !_shouldIgnoreFocusRequest && _shouldRequestFocus) {\n      widget.route.navigator!.focusNode.enclosingScope?.setFirstFocus(focusScopeNode);\n    }\n    setState(fn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Only top most route can participate in focus traversal.\n    focusScopeNode.skipTraversal = !widget.route.isCurrent;\n    return AnimatedBuilder(\n      animation: widget.route.restorationScopeId,\n      builder: (BuildContext context, Widget? child) {\n        assert(child != null);\n        return RestorationScope(\n          restorationId: widget.route.restorationScopeId.value,\n          child: child!,\n        );\n      },\n      child: _ModalScopeStatus(\n        route: widget.route,\n        isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n        canPop: widget.route.canPop, // _routeSetState is called if this updates\n        impliesAppBarDismissal: widget.route.impliesAppBarDismissal,\n        child: Offstage(\n          offstage: widget.route.offstage, // _routeSetState is called if this updates\n          child: PageStorage(\n            bucket: widget.route._storageBucket, // immutable\n            child: Builder(\n              builder: (BuildContext context) {\n                return Actions(\n                  actions: <Type, Action<Intent>>{DismissIntent: _DismissModalAction(context)},\n                  child: PrimaryScrollController(\n                    controller: primaryScrollController,\n                    child: FocusScope.withExternalFocusNode(\n                      focusScopeNode: focusScopeNode, // immutable\n                      child: RepaintBoundary(\n                        child: ListenableBuilder(\n                          listenable: _listenable, // immutable\n                          builder: (BuildContext context, Widget? child) {\n                            return widget.route._buildFlexibleTransitions(\n                              context,\n                              widget.route.animation!,\n                              widget.route.secondaryAnimation!,\n                              // This additional ListenableBuilder is include because if the\n                              // value of the userGestureInProgressNotifier changes, it's\n                              // only necessary to rebuild the IgnorePointer widget and set\n                              // the focus node's ability to focus.\n                              ListenableBuilder(\n                                listenable:\n                                    widget.route.navigator?.userGestureInProgressNotifier ??\n                                    ValueNotifier<bool>(false),\n                                builder: (BuildContext context, Widget? child) {\n                                  final bool ignoreEvents = _shouldIgnoreFocusRequest;\n                                  focusScopeNode.canRequestFocus = !ignoreEvents;\n                                  return IgnorePointer(ignoring: ignoreEvents, child: child);\n                                },\n                                child: child,\n                              ),\n                            );\n                          },\n                          child:\n                              _page ??= RepaintBoundary(\n                                key: widget.route._subtreeKey, // immutable\n                                child: Builder(\n                                  builder: (BuildContext context) {\n                                    return widget.route.buildPage(\n                                      context,\n                                      widget.route.animation!,\n                                      widget.route.secondaryAnimation!,\n                                    );\n                                  },\n                                ),\n                              ),\n                        ),\n                      ),\n                    ),\n                  ),\n                );\n              },\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n/// A route that blocks interaction with previous routes.\n///\n/// [ModalRoute]s cover the entire [Navigator]. They are not necessarily\n/// [opaque], however; for example, a pop-up menu uses a [ModalRoute] but only\n/// shows the menu in a small box overlapping the previous route.\n///\n/// The `T` type argument is the return value of the route. If there is no\n/// return value, consider using `void` as the return value.\n///\n/// See also:\n///\n///  * [Route], which further documents the meaning of the `T` generic type argument.\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n  /// Creates a route that blocks interaction with previous routes.\n  ModalRoute({super.settings, super.requestFocus, this.filter, this.traversalEdgeBehavior});\n\n  /// The filter to add to the barrier.\n  ///\n  /// If given, this filter will be applied to the modal barrier using\n  /// [BackdropFilter]. This allows blur effects, for example.\n  final ui.ImageFilter? filter;\n\n  /// Controls the transfer of focus beyond the first and the last items of a\n  /// [FocusScopeNode].\n  ///\n  /// If set to null, [Navigator.routeTraversalEdgeBehavior] is used.\n  final TraversalEdgeBehavior? traversalEdgeBehavior;\n\n  // The API for general users of this class\n\n  /// Returns the modal route most closely associated with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// {@tool snippet}\n  ///\n  /// Typical usage is as follows:\n  ///\n  /// ```dart\n  /// ModalRoute<int>? route = ModalRoute.of<int>(context);\n  /// ```\n  /// {@end-tool}\n  ///\n  /// The given [BuildContext] will be rebuilt if the state of the route changes\n  /// while it is visible (specifically, if [isCurrent] or [canPop] change value).\n  @optionalTypeArgs\n  static ModalRoute<T>? of<T extends Object?>(BuildContext context) {\n    return _of<T>(context);\n  }\n\n  static ModalRoute<T>? _of<T extends Object?>(BuildContext context, [_ModalRouteAspect? aspect]) {\n    return InheritedModel.inheritFrom<_ModalScopeStatus>(context, aspect: aspect)?.route\n        as ModalRoute<T>?;\n  }\n\n  /// Returns [ModalRoute.isCurrent] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.isCurrent] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? isCurrentOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.isCurrent)?.isCurrent;\n\n  /// Returns [ModalRoute.canPop] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.canPop] property of the ancestor [_ModalScopeStatus] changes.\n  static bool? canPopOf(BuildContext context) => _of(context, _ModalRouteAspect.canPop)?.canPop;\n\n  /// Returns [ModalRoute.settings] for the modal route most closely associated\n  /// with the given context.\n  ///\n  /// Returns null if the given context is not associated with a modal route.\n  ///\n  /// Use of this method will cause the given [context] to rebuild any time that\n  /// the [ModalRoute.settings] property of the ancestor [_ModalScopeStatus] changes.\n  static RouteSettings? settingsOf(BuildContext context) =>\n      _of(context, _ModalRouteAspect.settings)?.settings;\n\n  /// Schedule a call to [buildTransitions].\n  ///\n  /// Whenever you need to change internal state for a [ModalRoute] object, make\n  /// the change in a function that you pass to [setState], as in:\n  ///\n  /// ```dart\n  /// setState(() { _myState = newValue; });\n  /// ```\n  ///\n  /// If you just change the state directly without calling [setState], then the\n  /// route will not be scheduled for rebuilding, meaning that its rendering\n  /// will not be updated.\n  @protected\n  void setState(VoidCallback fn) {\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._routeSetState(fn);\n    } else {\n      // The route isn't currently visible, so we don't have to call its setState\n      // method, but we do still need to call the fn callback, otherwise the state\n      // in the route won't be updated!\n      fn();\n    }\n  }\n\n  /// Returns a predicate that's true if the route has the specified name and if\n  /// popping the route will not yield the same route, i.e. if the route's\n  /// [willHandlePopInternally] property is false.\n  ///\n  /// This function is typically used with [Navigator.popUntil()].\n  static RoutePredicate withName(String name) {\n    return (Route<dynamic> route) {\n      return !route.willHandlePopInternally && route is ModalRoute && route.settings.name == name;\n    };\n  }\n\n  // The API for subclasses to override - used by _ModalScope\n\n  /// Override this method to build the primary content of this route.\n  ///\n  /// The arguments have the following meanings:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: The animation for this route's transition. When entering,\n  ///    the animation runs forward from 0.0 to 1.0. When exiting, this animation\n  ///    runs backwards from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: The animation for the route being pushed on top of\n  ///    this route. This animation lets this route coordinate with the entrance\n  ///    and exit transition of routes pushed on top of this route.\n  ///\n  /// This method is only called when the route is first built, and rarely\n  /// thereafter. In particular, it is not automatically called again when the\n  /// route's state changes unless it uses [ModalRoute.of]. For a builder that\n  /// is called every time the route's state changes, consider\n  /// [buildTransitions]. For widgets that change their behavior when the\n  /// route's state changes, consider [ModalRoute.of] to obtain a reference to\n  /// the route; this will cause the widget to be rebuilt each time the route\n  /// changes state.\n  ///\n  /// In general, [buildPage] should be used to build the page contents, and\n  /// [buildTransitions] for the widgets that change as the page is brought in\n  /// and out of view. Avoid using [buildTransitions] for content that never\n  /// changes; building such content once from [buildPage] is more efficient.\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  );\n\n  /// Override this method to wrap the [child] with one or more transition\n  /// widgets that define how the route arrives on and leaves the screen.\n  ///\n  /// By default, the child (which contains the widget returned by [buildPage])\n  /// is not wrapped in any transition widgets.\n  ///\n  /// The [buildTransitions] method, in contrast to [buildPage], is called each\n  /// time the [Route]'s state changes while it is visible (e.g. if the value of\n  /// [canPop] changes on the active route).\n  ///\n  /// The [buildTransitions] method is typically used to define transitions\n  /// that animate the new topmost route's comings and goings. When the\n  /// [Navigator] pushes a route on the top of its stack, the new route's\n  /// primary [animation] runs from 0.0 to 1.0. When the Navigator pops the\n  /// topmost route, e.g. because the use pressed the back button, the\n  /// primary animation runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The following example uses the primary animation to drive a\n  /// [SlideTransition] that translates the top of the new route vertically\n  /// from the bottom of the screen when it is pushed on the Navigator's\n  /// stack. When the route is popped the SlideTransition translates the\n  /// route from the top of the screen back to the bottom.\n  ///\n  /// We've used [PageRouteBuilder] to demonstrate the [buildTransitions] method\n  /// here. The body of an override of the [buildTransitions] method would be\n  /// defined in the same way.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///    ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: child, // child is the value returned by pageBuilder\n  ///     );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// When the [Navigator] pushes a route on the top of its stack, the\n  /// [secondaryAnimation] can be used to define how the route that was on\n  /// the top of the stack leaves the screen. Similarly when the topmost route\n  /// is popped, the secondaryAnimation can be used to define how the route\n  /// below it reappears on the screen. When the Navigator pushes a new route\n  /// on the top of its stack, the old topmost route's secondaryAnimation\n  /// runs from 0.0 to 1.0. When the Navigator pops the topmost route, the\n  /// secondaryAnimation for the route below it runs from 1.0 to 0.0.\n  ///\n  /// {@tool snippet}\n  /// The example below adds a transition that's driven by the\n  /// [secondaryAnimation]. When this route disappears because a new route has\n  /// been pushed on top of it, it translates in the opposite direction of\n  /// the new route. Likewise when the route is exposed because the topmost\n  /// route has been popped off.\n  ///\n  /// ```dart\n  /// PageRouteBuilder<void>(\n  ///   pageBuilder: (BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///   ) {\n  ///     return Scaffold(\n  ///       appBar: AppBar(title: const Text('Hello')),\n  ///       body: const Center(\n  ///         child: Text('Hello World'),\n  ///       ),\n  ///     );\n  ///   },\n  ///   transitionsBuilder: (\n  ///       BuildContext context,\n  ///       Animation<double> animation,\n  ///       Animation<double> secondaryAnimation,\n  ///       Widget child,\n  ///   ) {\n  ///     return SlideTransition(\n  ///       position: Tween<Offset>(\n  ///         begin: const Offset(0.0, 1.0),\n  ///         end: Offset.zero,\n  ///       ).animate(animation),\n  ///       child: SlideTransition(\n  ///         position: Tween<Offset>(\n  ///           begin: Offset.zero,\n  ///           end: const Offset(0.0, 1.0),\n  ///         ).animate(secondaryAnimation),\n  ///         child: child,\n  ///       ),\n  ///      );\n  ///   },\n  /// )\n  /// ```\n  /// {@end-tool}\n  ///\n  /// In practice the `secondaryAnimation` is used pretty rarely.\n  ///\n  /// The arguments to this method are as follows:\n  ///\n  ///  * `context`: The context in which the route is being built.\n  ///  * [animation]: When the [Navigator] pushes a route on the top of its stack,\n  ///    the new route's primary [animation] runs from 0.0 to 1.0. When the [Navigator]\n  ///    pops the topmost route this animation runs from 1.0 to 0.0.\n  ///  * [secondaryAnimation]: When the Navigator pushes a new route\n  ///    on the top of its stack, the old topmost route's [secondaryAnimation]\n  ///    runs from 0.0 to 1.0. When the [Navigator] pops the topmost route, the\n  ///    [secondaryAnimation] for the route below it runs from 1.0 to 0.0.\n  ///  * `child`, the page contents, as returned by [buildPage].\n  ///\n  /// See also:\n  ///\n  ///  * [buildPage], which is used to describe the actual contents of the page,\n  ///    and whose result is passed to the `child` argument of this method.\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    return child;\n  }\n\n  /// The [DelegatedTransitionBuilder] provided to the route below this one in the\n  /// navigation stack.\n  ///\n  /// {@template flutter.widgets.delegatedTransition}\n  /// Used for the purposes of coordinating transitions between two routes with\n  /// different route transitions. When a route is added to the stack, the original\n  /// topmost route will look for this transition, and if available, it will use\n  /// the `delegatedTransition` from the incoming transition to animate off the\n  /// screen.\n  ///\n  /// If the return of the [DelegatedTransitionBuilder] is null, then by default\n  /// the original transition of the routes will be used. This is useful if a\n  /// route can conditionally provide a transition based on the [BuildContext].\n  /// {@endtemplate}\n  ///\n  /// The [ModalRoute] receiving this transition will set it to their\n  /// [receivedTransition] property.\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses three different page transitions, a\n  /// Material Zoom transition, the standard Cupertino sliding transition, and a\n  /// custom vertical transition. All of the page routes are able to inform the\n  /// previous page how to transition off the screen to sync with the new page.\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.0.dart **\n  /// {@end-tool}\n  ///\n  /// {@tool dartpad}\n  /// This sample shows an app that uses the same transitions as the previous\n  /// sample, this time in a [MaterialApp.router].\n  ///\n  /// ** See code in examples/api/lib/widgets/routes/flexible_route_transitions.1.dart **\n  /// {@end-tool}\n  DelegatedTransitionBuilder? get delegatedTransition => null;\n\n  /// The [DelegatedTransitionBuilder] received from the route above this one in\n  /// the navigation stack.\n  ///\n  /// {@macro flutter.widgets.delegatedTransition}\n  ///\n  /// The `receivedTransition` will use the above route's [delegatedTransition] in\n  /// order to show the right route transition when the above route either enters\n  /// or leaves the navigation stack. If not null, the `receivedTransition` will\n  /// wrap the route content.\n  @visibleForTesting\n  DelegatedTransitionBuilder? receivedTransition;\n\n  // Wraps the transitions of this route with a DelegatedTransitionBuilder, when\n  // _receivedTransition is not null.\n  Widget _buildFlexibleTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (receivedTransition == null) {\n      return buildTransitions(context, animation, secondaryAnimation, child);\n    }\n\n    // Create a static proxy animation to suppress the original secondary transition.\n    final ProxyAnimation proxyAnimation = ProxyAnimation();\n\n    final Widget proxiedOriginalTransitions = buildTransitions(\n      context,\n      animation,\n      proxyAnimation,\n      child,\n    );\n\n    // If receivedTransitions return null, then we want to return the original transitions,\n    // but with the secondary animation still proxied. This keeps a desynched\n    // animation from playing.\n    return receivedTransition!(\n          context,\n          animation,\n          secondaryAnimation,\n          allowSnapshotting,\n          proxiedOriginalTransitions,\n        ) ??\n        proxiedOriginalTransitions;\n  }\n\n  @override\n  void install() {\n    super.install();\n    _animationProxy = ProxyAnimation(super.animation);\n    _secondaryAnimationProxy = ProxyAnimation(super.secondaryAnimation);\n  }\n\n  @override\n  TickerFuture didPush() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    return super.didPush();\n  }\n\n  @override\n  void didAdd() {\n    if (_scopeKey.currentState != null && navigator!.widget.requestFocus) {\n      navigator!.focusNode.enclosingScope?.setFirstFocus(_scopeKey.currentState!.focusScopeNode);\n    }\n    super.didAdd();\n  }\n\n  // The API for subclasses to override - used by this class\n\n  /// {@template flutter.widgets.ModalRoute.barrierDismissible}\n  /// Whether you can dismiss this route by tapping the modal barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// If [barrierDismissible] is true, then tapping this barrier, pressing\n  /// the escape key on the keyboard, or calling route popping functions\n  /// such as [Navigator.pop] will cause the current route to be popped\n  /// with null as the value.\n  ///\n  /// If [barrierDismissible] is false, then tapping the barrier has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [Navigator.pop], which is used to dismiss the route.\n  ///  * [barrierColor], which controls the color of the scrim for this route.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  /// {@endtemplate}\n  bool get barrierDismissible;\n\n  /// Whether the semantics of the modal barrier are included in the\n  /// semantics tree.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// If [semanticsDismissible] is true, then modal barrier semantics are\n  /// included in the semantics tree.\n  ///\n  /// If [semanticsDismissible] is false, then modal barrier semantics are\n  /// excluded from the semantics tree and tapping on the modal barrier\n  /// has no effect.\n  ///\n  /// If this getter would ever start returning a different value,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  bool get semanticsDismissible => true;\n\n  /// {@template flutter.widgets.ModalRoute.barrierColor}\n  /// The color to use for the modal barrier. If this is null, the barrier will\n  /// be transparent.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// The color is ignored, and the barrier made invisible, when\n  /// [ModalRoute.offstage] is true.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified color.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different color, one\n  /// of the [changedInternalState] or [changedExternalState] methods\n  /// should be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// {@tool snippet}\n  ///\n  /// For example, to make the barrier color use the theme's\n  /// background color, one could say:\n  ///\n  /// ```dart\n  /// Color get barrierColor => Theme.of(navigator.context).colorScheme.surface;\n  /// ```\n  ///\n  /// {@end-tool}\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  Color? get barrierColor;\n\n  /// {@template flutter.widgets.ModalRoute.barrierLabel}\n  /// The semantic label used for a dismissible barrier.\n  ///\n  /// If the barrier is dismissible, this label will be read out if\n  /// accessibility tools (like VoiceOver on iOS) focus on the barrier.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different label,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// See also:\n  ///\n  ///  * [barrierDismissible], which controls the behavior of the barrier when\n  ///    tapped.\n  ///  * [ModalBarrier], the widget that implements this feature.\n  String? get barrierLabel;\n\n  /// The curve that is used for animating the modal barrier in and out.\n  ///\n  /// The modal barrier is the scrim that is rendered behind each route, which\n  /// generally prevents the user from interacting with the route below the\n  /// current route, and normally partially obscures such routes.\n  ///\n  /// For example, when a dialog is on the screen, the page below the dialog is\n  /// usually darkened by the modal barrier.\n  ///\n  /// While the route is animating into position, the color is animated from\n  /// transparent to the specified [barrierColor].\n  ///\n  /// If this getter would ever start returning a different curve,\n  /// either [changedInternalState] or [changedExternalState] should\n  /// be invoked so that the change can take effect.\n  ///\n  /// It is safe to use `navigator.context` to look up inherited\n  /// widgets here, because the [Navigator] calls\n  /// [changedExternalState] whenever its dependencies change, and\n  /// [changedExternalState] causes the modal barrier to rebuild.\n  ///\n  /// It defaults to [Curves.ease].\n  ///\n  /// See also:\n  ///\n  ///  * [barrierColor], which determines the color that the modal transitions\n  ///    to.\n  ///  * [Curves] for a collection of common curves.\n  ///  * [AnimatedModalBarrier], the widget that implements this feature.\n  Curve get barrierCurve => Curves.ease;\n\n  /// {@template flutter.widgets.ModalRoute.maintainState}\n  /// Whether the route should remain in memory when it is inactive.\n  ///\n  /// If this is true, then the route is maintained, so that any futures it is\n  /// holding from the next route will properly resolve when the next route\n  /// pops. If this is not necessary, this can be set to false to allow the\n  /// framework to entirely discard the route's widget hierarchy when it is not\n  /// visible.\n  ///\n  /// Setting [maintainState] to false does not guarantee that the route will be\n  /// discarded. For instance, it will not be discarded if it is still visible\n  /// because the next above it is not opaque (e.g. it is a popup dialog).\n  /// {@endtemplate}\n  ///\n  /// If this getter would ever start returning a different value, the\n  /// [changedInternalState] should be invoked so that the change can take\n  /// effect.\n  ///\n  /// See also:\n  ///\n  ///  * [OverlayEntry.maintainState], which is the underlying implementation\n  ///    of this property.\n  bool get maintainState;\n\n  /// True if a back gesture (iOS-style back swipe or Android predictive back)\n  /// is currently underway for this route.\n  ///\n  /// See also:\n  ///\n  ///  * [popGestureEnabled], which returns true if a user-triggered pop gesture\n  ///    would be allowed.\n  bool get popGestureInProgress => navigator!.userGestureInProgress;\n\n  /// Whether a pop gesture can be started by the user for this route.\n  ///\n  /// Returns true if the user can edge-swipe to a previous route.\n  ///\n  /// This should only be used between frames, not during build.\n  @override\n  bool get popGestureEnabled {\n    // If there's nothing to go back to, then obviously we don't support\n    // the back gesture.\n    if (isFirst) {\n      return false;\n    }\n    // If the route wouldn't actually pop if we popped it, then the gesture\n    // would be really confusing (or would skip internal routes), so disallow it.\n    if (willHandlePopInternally) {\n      return false;\n    }\n    // If attempts to dismiss this route might be vetoed such as in a page\n    // with forms, then do not allow the user to dismiss the route with a swipe.\n    if (hasScopedWillPopCallback || popDisposition == RoutePopDisposition.doNotPop) {\n      return false;\n    }\n    // If we're in an animation already, we cannot be manually swiped.\n    if (!animation!.isCompleted) {\n      return false;\n    }\n    // If we're being popped into, we also cannot be swiped until the pop above\n    // it completes. This translates to our secondary animation being\n    // dismissed.\n    if (!secondaryAnimation!.isDismissed) {\n      return false;\n    }\n    // If we're in a gesture already, we cannot start another.\n    if (popGestureInProgress) {\n      return false;\n    }\n\n    // Looks like a back gesture would be welcome!\n    return true;\n  }\n\n  // The API for _ModalScope and HeroController\n\n  /// Whether this route is currently offstage.\n  ///\n  /// On the first frame of a route's entrance transition, the route is built\n  /// [Offstage] using an animation progress of 1.0. The route is invisible and\n  /// non-interactive, but each widget has its final size and position. This\n  /// mechanism lets the [HeroController] determine the final local of any hero\n  /// widgets being animated as part of the transition.\n  ///\n  /// The modal barrier, if any, is not rendered if [offstage] is true (see\n  /// [barrierColor]).\n  ///\n  /// Whenever this changes value, [changedInternalState] is called.\n  bool get offstage => _offstage;\n  bool _offstage = false;\n  set offstage(bool value) {\n    if (_offstage == value) {\n      return;\n    }\n    setState(() {\n      _offstage = value;\n    });\n    _animationProxy!.parent = _offstage ? kAlwaysCompleteAnimation : super.animation;\n    _secondaryAnimationProxy!.parent =\n        _offstage ? kAlwaysDismissedAnimation : super.secondaryAnimation;\n    changedInternalState();\n  }\n\n  /// The build context for the subtree containing the primary content of this route.\n  BuildContext? get subtreeContext => _subtreeKey.currentContext;\n\n  @override\n  Animation<double>? get animation => _animationProxy;\n  ProxyAnimation? _animationProxy;\n\n  @override\n  Animation<double>? get secondaryAnimation => _secondaryAnimationProxy;\n  ProxyAnimation? _secondaryAnimationProxy;\n\n  final List<WillPopCallback> _willPopCallbacks = <WillPopCallback>[];\n\n  // Holding as Object? instead of T so that PopScope in this route can be\n  // declared with any supertype of T.\n  final Set<PopEntry<Object?>> _popEntries = <PopEntry<Object?>>{};\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of callbacks added with\n  /// [addScopedWillPopCallback] returns either false or null. If they all\n  /// return true, the base [Route.willPop]'s result will be returned. The\n  /// callbacks will be called in the order they were added, and will only be\n  /// called if all previous callbacks returned true.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [WillPopCallback] list makes it possible\n  /// for ModalRoute descendants to collectively define the value of [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds a callback to the list this\n  ///    method checks.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    this method checks.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @override\n  Future<RoutePopDisposition> willPop() async {\n    final _ModalScopeState<T>? scope = _scopeKey.currentState;\n    assert(scope != null);\n    for (final WillPopCallback callback in List<WillPopCallback>.of(_willPopCallbacks)) {\n      if (!await callback()) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n    return super.willPop();\n  }\n\n  /// Returns [RoutePopDisposition.doNotPop] if any of the [PopEntry] instances\n  /// registered with [registerPopEntry] have [PopEntry.canPopNotifier] set to\n  /// false.\n  ///\n  /// Typically this method is not overridden because applications usually\n  /// don't create modal routes directly, they use higher level primitives\n  /// like [showDialog]. The scoped [PopEntry] list makes it possible for\n  /// ModalRoute descendants to collectively define the value of\n  /// [popDisposition].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onPopInvokedWithResult` callback that is similar.\n  ///  * [registerPopEntry], which adds a [PopEntry] to the list this method\n  ///    checks.\n  ///  * [unregisterPopEntry], which removes a [PopEntry] from the list this\n  ///    method checks.\n  @override\n  RoutePopDisposition get popDisposition {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      if (!popEntry.canPopNotifier.value) {\n        return RoutePopDisposition.doNotPop;\n      }\n    }\n\n    return super.popDisposition;\n  }\n\n  @override\n  void onPopInvokedWithResult(bool didPop, T? result) {\n    for (final PopEntry<Object?> popEntry in _popEntries) {\n      popEntry.onPopInvokedWithResult(didPop, result);\n    }\n    super.onPopInvokedWithResult(didPop, result);\n  }\n\n  /// Enables this route to veto attempts by the user to dismiss it.\n  ///\n  /// This callback runs asynchronously and it's possible that it will be called\n  /// after its route has been disposed. The callback should check [State.mounted]\n  /// before doing anything.\n  ///\n  /// A typical application of this callback would be to warn the user about\n  /// unsaved [Form] data if the user attempts to back out of the form. In that\n  /// case, use the [Form.onWillPop] property to register the callback.\n  ///\n  /// See also:\n  ///\n  ///  * [WillPopScope], which manages the registration and unregistration\n  ///    process automatically.\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [willPop], which runs the callbacks added with this method.\n  ///  * [removeScopedWillPopCallback], which removes a callback from the list\n  ///    that [willPop] checks.\n  @Deprecated(\n    'Use registerPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void addScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to add a willPop callback to a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.add(callback);\n    if (_willPopCallbacks.length == 1) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Remove one of the callbacks run by [willPop].\n  ///\n  /// See also:\n  ///\n  ///  * [Form], which provides an `onWillPop` callback that uses this mechanism.\n  ///  * [addScopedWillPopCallback], which adds callback to the list\n  ///    checked by [willPop].\n  @Deprecated(\n    'Use unregisterPopEntry or PopScope instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  void removeScopedWillPopCallback(WillPopCallback callback) {\n    assert(\n      _scopeKey.currentState != null,\n      'Tried to remove a willPop callback from a route that is not currently in the tree.',\n    );\n    _willPopCallbacks.remove(callback);\n    if (_willPopCallbacks.isEmpty) {\n      _maybeDispatchNavigationNotification();\n    }\n  }\n\n  /// Registers the existence of a [PopEntry] in the route.\n  ///\n  /// [PopEntry] instances registered in this way will have their\n  /// [PopEntry.onPopInvokedWithResult] callbacks called when a route is popped or a pop\n  /// is attempted. They will also be able to block pop operations with\n  /// [PopEntry.canPopNotifier] through this route's [popDisposition] method.\n  ///\n  /// See also:\n  ///\n  ///  * [unregisterPopEntry], which performs the opposite operation.\n  void registerPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.add(popEntry);\n    popEntry.canPopNotifier.addListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  /// Unregisters a [PopEntry] in the route's widget subtree.\n  ///\n  /// See also:\n  ///\n  ///  * [registerPopEntry], which performs the opposite operation.\n  void unregisterPopEntry(PopEntry<Object?> popEntry) {\n    _popEntries.remove(popEntry);\n    popEntry.canPopNotifier.removeListener(_maybeDispatchNavigationNotification);\n    _maybeDispatchNavigationNotification();\n  }\n\n  void _maybeDispatchNavigationNotification() {\n    if (!isCurrent) {\n      return;\n    }\n    final NavigationNotification notification = NavigationNotification(\n      // canPop indicates that the originator of the Notification can handle a\n      // pop. In the case of PopScope, it handles pops when canPop is\n      // false. Hence the seemingly backward logic here.\n      canHandlePop: popDisposition == RoutePopDisposition.doNotPop || _willPopCallbacks.isNotEmpty,\n    );\n    // Avoid dispatching a notification in the middle of a build.\n    switch (SchedulerBinding.instance.schedulerPhase) {\n      case SchedulerPhase.postFrameCallbacks:\n        notification.dispatch(subtreeContext);\n      case SchedulerPhase.idle:\n      case SchedulerPhase.midFrameMicrotasks:\n      case SchedulerPhase.persistentCallbacks:\n      case SchedulerPhase.transientCallbacks:\n        SchedulerBinding.instance.addPostFrameCallback((Duration timeStamp) {\n          if (!(subtreeContext?.mounted ?? false)) {\n            return;\n          }\n          notification.dispatch(subtreeContext);\n        }, debugLabel: 'ModalRoute.dispatchNotification');\n    }\n  }\n\n  /// True if one or more [WillPopCallback] callbacks exist.\n  ///\n  /// This method is used to disable the horizontal swipe pop gesture supported\n  /// by [MaterialPageRoute] for [TargetPlatform.iOS] and\n  /// [TargetPlatform.macOS]. If a pop might be vetoed, then the back gesture is\n  /// disabled.\n  ///\n  /// The [buildTransitions] method will not be called again if this changes,\n  /// since it can change during the build as descendants of the route add or\n  /// remove callbacks.\n  ///\n  /// See also:\n  ///\n  ///  * [addScopedWillPopCallback], which adds a callback.\n  ///  * [removeScopedWillPopCallback], which removes a callback.\n  ///  * [willHandlePopInternally], which reports on another reason why\n  ///    a pop might be vetoed.\n  @Deprecated(\n    'Use popDisposition instead. '\n    'This feature was deprecated after v3.12.0-1.0.pre.',\n  )\n  @protected\n  bool get hasScopedWillPopCallback {\n    return _willPopCallbacks.isNotEmpty;\n  }\n\n  @override\n  void didChangePrevious(Route<dynamic>? previousRoute) {\n    super.didChangePrevious(previousRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didChangeNext(Route<dynamic>? nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didChangeNext(nextRoute);\n    changedInternalState();\n  }\n\n  @override\n  void didPopNext(Route<dynamic> nextRoute) {\n    if (nextRoute is ModalRoute<T> &&\n        canTransitionTo(nextRoute) &&\n        nextRoute.delegatedTransition != this.delegatedTransition) {\n      receivedTransition = nextRoute.delegatedTransition;\n    } else {\n      receivedTransition = null;\n    }\n    super.didPopNext(nextRoute);\n    changedInternalState();\n    _maybeDispatchNavigationNotification();\n  }\n\n  @override\n  void changedInternalState() {\n    super.changedInternalState();\n    // No need to mark dirty if this method is called during build phase.\n    if (SchedulerBinding.instance.schedulerPhase != SchedulerPhase.persistentCallbacks) {\n      setState(() {\n        /* internal state already changed */\n      });\n      _modalBarrier.markNeedsBuild();\n    }\n    _modalScope.maintainState = maintainState;\n  }\n\n  @override\n  void changedExternalState() {\n    super.changedExternalState();\n    _modalBarrier.markNeedsBuild();\n    if (_scopeKey.currentState != null) {\n      _scopeKey.currentState!._forceRebuildPage();\n    }\n  }\n\n  /// Whether this route can be popped.\n  ///\n  /// A route can be popped if there is at least one active route below it, or\n  /// if [willHandlePopInternally] returns true.\n  ///\n  /// When this changes, if the route is visible, the route will\n  /// rebuild, and any widgets that used [ModalRoute.of] will be\n  /// notified.\n  bool get canPop => hasActiveRouteBelow || willHandlePopInternally;\n\n  /// Whether an [AppBar] in the route should automatically add a back button or\n  /// close button.\n  ///\n  /// This getter returns true if there is at least one active route below it,\n  /// or there is at least one [LocalHistoryEntry] with [impliesAppBarDismissal]\n  /// set to true\n  bool get impliesAppBarDismissal => hasActiveRouteBelow || _entriesImpliesAppBarDismissal > 0;\n\n  // Internals\n\n  final GlobalKey<_ModalScopeState<T>> _scopeKey = GlobalKey<_ModalScopeState<T>>();\n  final GlobalKey _subtreeKey = GlobalKey();\n  final PageStorageBucket _storageBucket = PageStorageBucket();\n\n  // one of the builders\n  late OverlayEntry _modalBarrier;\n  Widget _buildModalBarrier(BuildContext context) {\n    Widget barrier = buildModalBarrier();\n    if (filter != null) {\n      barrier = BackdropFilter(filter: filter!, child: barrier);\n    }\n    barrier = IgnorePointer(\n      ignoring:\n          !animation!\n              .isForwardOrCompleted, // changedInternalState is called when animation.status updates\n      child: barrier, // dismissed is possible when doing a manual pop gesture\n    );\n    if (semanticsDismissible && barrierDismissible) {\n      // To be sorted after the _modalScope.\n      barrier = Semantics(sortKey: const OrdinalSortKey(1.0), child: barrier);\n    }\n    return barrier;\n  }\n\n  /// Build the barrier for this [ModalRoute], subclasses can override\n  /// this method to create their own barrier with customized features such as\n  /// color or accessibility focus size.\n  ///\n  /// See also:\n  /// * [ModalBarrier], which is typically used to build a barrier.\n  /// * [ModalBottomSheetRoute], which overrides this method to build a\n  ///   customized barrier.\n  Widget buildModalBarrier() {\n    Widget barrier;\n    if (barrierColor != null && barrierColor!.alpha != 0 && !offstage) {\n      // changedInternalState is called if barrierColor or offstage updates\n      assert(barrierColor != barrierColor!.withOpacity(0.0));\n      final Animation<Color?> color = animation!.drive(\n        ColorTween(\n          begin: barrierColor!.withOpacity(0.0),\n          end: barrierColor, // changedInternalState is called if barrierColor updates\n        ).chain(\n          CurveTween(curve: barrierCurve),\n        ), // changedInternalState is called if barrierCurve updates\n      );\n      barrier = AnimatedModalBarrier(\n        color: color,\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    } else {\n      barrier = ModalBarrier(\n        dismissible:\n            barrierDismissible, // changedInternalState is called if barrierDismissible updates\n        semanticsLabel: barrierLabel, // changedInternalState is called if barrierLabel updates\n        barrierSemanticsDismissible: semanticsDismissible,\n      );\n    }\n\n    return barrier;\n  }\n\n  // We cache the part of the modal scope that doesn't change from frame to\n  // frame so that we minimize the amount of building that happens.\n  Widget? _modalScopeCache;\n\n  // one of the builders\n  Widget _buildModalScope(BuildContext context) {\n    // To be sorted before the _modalBarrier.\n    return _modalScopeCache ??= Semantics(\n      sortKey: const OrdinalSortKey(0.0),\n      child: _ModalScope<T>(\n        key: _scopeKey,\n        route: this,\n        // _ModalScope calls buildTransitions() and buildChild(), defined above\n      ),\n    );\n  }\n\n  late OverlayEntry _modalScope;\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() {\n    return <OverlayEntry>[\n      _modalBarrier = OverlayEntry(builder: _buildModalBarrier),\n      _modalScope = OverlayEntry(\n        builder: _buildModalScope,\n        maintainState: maintainState,\n        canSizeOverlay: opaque,\n      ),\n    ];\n  }\n\n  @override\n  String toString() =>\n      '${objectRuntimeType(this, 'ModalRoute')}($settings, animation: $_animation)';\n}\n\n/// A modal route that overlays a widget over the current route.\n///\n/// {@macro flutter.widgets.ModalRoute.barrierDismissible}\n///\n/// {@tool dartpad}\n/// This example shows how to create a dialog box that is dismissible.\n///\n/// ** See code in examples/api/lib/widgets/routes/popup_route.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///   * [ModalRoute], which is the base class for this class.\n///   * [Navigator.pop], which is used to dismiss the route.\nabstract class PopupRoute<T> extends ModalRoute<T> {\n  /// Initializes the [PopupRoute].\n  PopupRoute({super.settings, super.requestFocus, super.filter, super.traversalEdgeBehavior});\n\n  @override\n  bool get opaque => false;\n\n  @override\n  bool get maintainState => true;\n\n  @override\n  bool get allowSnapshotting => false;\n}\n\n/// A [Navigator] observer that notifies [RouteAware]s of changes to the\n/// state of their [Route].\n///\n/// [RouteObserver] informs subscribers whenever a route of type `R` is pushed\n/// on top of their own route of type `R` or popped from it. This is for example\n/// useful to keep track of page transitions, e.g. a `RouteObserver<PageRoute>`\n/// will inform subscribed [RouteAware]s whenever the user navigates away from\n/// the current page route to another page route.\n///\n/// To be informed about route changes of any type, consider instantiating a\n/// `RouteObserver<Route>`.\n///\n/// ## Type arguments\n///\n/// When using more aggressive [lints](https://dart.dev/lints),\n/// in particular lints such as `always_specify_types`,\n/// the Dart analyzer will require that certain types\n/// be given with their type arguments. Since the [Route] class and its\n/// subclasses have a type argument, this includes the arguments passed to this\n/// class. Consider using `dynamic` to specify the entire class of routes rather\n/// than only specific subtypes. For example, to watch for all [ModalRoute]\n/// variants, the `RouteObserver<ModalRoute<dynamic>>` type may be used.\n///\n/// {@tool dartpad}\n/// This example demonstrates how to implement a [RouteObserver] that notifies\n/// [RouteAware] widget of changes to the state of their [Route].\n///\n/// ** See code in examples/api/lib/widgets/routes/route_observer.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///  * [RouteAware], this is used with [RouteObserver] to make a widget aware\n///   of changes to the [Navigator]'s session history.\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Whether this observer is managing changes for the specified route.\n  ///\n  /// If asserts are disabled, this method will throw an exception.\n  @visibleForTesting\n  bool debugObservingRoute(R route) {\n    late bool contained;\n    assert(() {\n      contained = _listeners.containsKey(route);\n      return true;\n    }());\n    return contained;\n  }\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  ///\n  /// Going forward, [routeAware] will be informed about qualifying changes\n  /// to [route], e.g. when [route] is covered by another route or when [route]\n  /// is popped off the [Navigator] stack.\n  void subscribe(RouteAware routeAware, R route) {\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    if (subscribers.add(routeAware)) {\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  ///\n  /// [routeAware] is no longer informed about changes to its route. If the given argument was\n  /// subscribed to multiple types, this will unregister it (once) from each type.\n  void unsubscribe(RouteAware routeAware) {\n    final List<R> routes = _listeners.keys.toList();\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        subscribers.remove(routeAware);\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    if (route is R && previousRoute is R) {\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n    }\n  }\n}\n\n/// An interface for objects that are aware of their current [Route].\n///\n/// This is used with [RouteObserver] to make a widget aware of changes to the\n/// [Navigator]'s session history.\nabstract mixin class RouteAware {\n  /// Called when the top route has been popped off, and the current route\n  /// shows up.\n  void didPopNext() {}\n\n  /// Called when the current route has been pushed.\n  void didPush() {}\n\n  /// Called when the current route has been popped off.\n  void didPop() {}\n\n  /// Called when a new route has been pushed, and the current route is no\n  /// longer visible.\n  void didPushNext() {}\n}\n\n/// A general dialog route which allows for customization of the dialog popup.\n///\n/// It is used internally by [showGeneralDialog] or can be directly pushed\n/// onto the [Navigator] stack to enable state restoration. See\n/// [showGeneralDialog] for a state restoration app example.\n///\n/// This function takes a `pageBuilder`, which typically builds a dialog.\n/// Content below the dialog is dimmed with a [ModalBarrier]. The widget\n/// returned by the `builder` does not share a context with the location that\n/// `showDialog` is originally called from. Use a [StatefulBuilder] or a\n/// custom [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `barrierDismissible` argument is used to indicate whether tapping on the\n/// barrier will dismiss the dialog. It is `true` by default and cannot be `null`.\n///\n/// The `barrierColor` argument is used to specify the color of the modal\n/// barrier that darkens everything below the dialog. If `null`, the default\n/// color `Colors.black54` is used.\n///\n/// The `settings` argument define the settings for this route. See\n/// [RouteSettings] for details.\n///\n/// {@template flutter.widgets.RawDialogRoute}\n/// A [DisplayFeature] can split the screen into sub-screens. The closest one to\n/// [anchorPoint] is used to render the content.\n///\n/// If no [anchorPoint] is provided, then [Directionality] is used:\n///\n///   * for [TextDirection.ltr], [anchorPoint] is `Offset.zero`, which will\n///     cause the content to appear in the top-left sub-screen.\n///   * for [TextDirection.rtl], [anchorPoint] is `Offset(double.maxFinite, 0)`,\n///     which will cause the content to appear in the top-right sub-screen.\n///\n/// If no [anchorPoint] is provided, and there is no [Directionality] ancestor\n/// widget in the tree, then the widget asserts during build in debug mode.\n/// {@endtemplate}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showGeneralDialog], which is a way to display a RawDialogRoute.\n///  * [showDialog], which is a way to display a DialogRoute.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nclass RawDialogRoute<T> extends PopupRoute<T> {\n  /// A general dialog route which allows for customization of the dialog popup.\n  RawDialogRoute({\n    required RoutePageBuilder pageBuilder,\n    bool barrierDismissible = true,\n    Color? barrierColor = const Color(0x80000000),\n    String? barrierLabel,\n    Duration transitionDuration = const Duration(milliseconds: 200),\n    RouteTransitionsBuilder? transitionBuilder,\n    super.settings,\n    super.requestFocus,\n    this.anchorPoint,\n    super.traversalEdgeBehavior,\n  }) : _pageBuilder = pageBuilder,\n       _barrierDismissible = barrierDismissible,\n       _barrierLabel = barrierLabel,\n       _barrierColor = barrierColor,\n       _transitionDuration = transitionDuration,\n       _transitionBuilder = transitionBuilder;\n\n  final RoutePageBuilder _pageBuilder;\n\n  @override\n  bool get barrierDismissible => _barrierDismissible;\n  final bool _barrierDismissible;\n\n  @override\n  String? get barrierLabel => _barrierLabel;\n  final String? _barrierLabel;\n\n  @override\n  Color? get barrierColor => _barrierColor;\n  final Color? _barrierColor;\n\n  @override\n  Duration get transitionDuration => _transitionDuration;\n  final Duration _transitionDuration;\n\n  final RouteTransitionsBuilder? _transitionBuilder;\n\n  /// {@macro flutter.widgets.DisplayFeatureSubScreen.anchorPoint}\n  final Offset? anchorPoint;\n\n  @override\n  Widget buildPage(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n  ) {\n    return Semantics(\n      scopesRoute: true,\n      explicitChildNodes: true,\n      child: DisplayFeatureSubScreen(\n        anchorPoint: anchorPoint,\n        child: _pageBuilder(context, animation, secondaryAnimation),\n      ),\n    );\n  }\n\n  @override\n  Widget buildTransitions(\n    BuildContext context,\n    Animation<double> animation,\n    Animation<double> secondaryAnimation,\n    Widget child,\n  ) {\n    if (_transitionBuilder == null) {\n      // Some default transition.\n      return FadeTransition(opacity: animation, child: child);\n    }\n    return _transitionBuilder(context, animation, secondaryAnimation, child);\n  }\n}\n\n/// Displays a dialog above the current contents of the app.\n///\n/// This function allows for customization of aspects of the dialog popup.\n///\n/// This function takes a `pageBuilder` which is used to build the primary\n/// content of the route (typically a dialog widget). Content below the dialog\n/// is dimmed with a [ModalBarrier]. The widget returned by the `pageBuilder`\n/// does not share a context with the location that [showGeneralDialog] is\n/// originally called from. Use a [StatefulBuilder] or a custom\n/// [StatefulWidget] if the dialog needs to update dynamically.\n///\n/// The `context` argument is used to look up the [Navigator] for the\n/// dialog. It is only used when the method is called. Its corresponding widget\n/// can be safely removed from the tree before the dialog is closed.\n///\n/// The `useRootNavigator` argument is used to determine whether to push the\n/// dialog to the [Navigator] furthest from or nearest to the given `context`.\n/// By default, `useRootNavigator` is `true` and the dialog route created by\n/// this method is pushed to the root navigator.\n///\n/// If the application has multiple [Navigator] objects, it may be necessary to\n/// call `Navigator.of(context, rootNavigator: true).pop(result)` to close the\n/// dialog rather than just `Navigator.pop(context, result)`.\n///\n/// The `barrierDismissible` argument is used to determine whether this route\n/// can be dismissed by tapping the modal barrier. This argument defaults\n/// to false. If `barrierDismissible` is true, a non-null `barrierLabel` must be\n/// provided.\n///\n/// The `barrierLabel` argument is the semantic label used for a dismissible\n/// barrier. This argument defaults to `null`.\n///\n/// The `barrierColor` argument is the color used for the modal barrier. This\n/// argument defaults to `Color(0x80000000)`.\n///\n/// The `transitionDuration` argument is used to determine how long it takes\n/// for the route to arrive on or leave off the screen. This argument defaults\n/// to 200 milliseconds.\n///\n/// The `transitionBuilder` argument is used to define how the route arrives on\n/// and leaves off the screen. By default, the transition is a linear fade of\n/// the page's contents.\n///\n/// The `routeSettings` will be used in the construction of the dialog's route.\n/// See [RouteSettings] for more details.\n///\n/// {@macro flutter.widgets.RawDialogRoute}\n///\n/// Returns a [Future] that resolves to the value (if any) that was passed to\n/// [Navigator.pop] when the dialog was closed.\n///\n/// ### State Restoration in Dialogs\n///\n/// Using this method will not enable state restoration for the dialog. In order\n/// to enable state restoration for a dialog, use [Navigator.restorablePush]\n/// or [Navigator.restorablePushNamed] with [RawDialogRoute].\n///\n/// For more information about state restoration, see [RestorationManager].\n///\n/// {@tool sample}\n/// This sample demonstrates how to create a restorable dialog. This is\n/// accomplished by enabling state restoration by specifying\n/// [WidgetsApp.restorationScopeId] and using [Navigator.restorablePush] to\n/// push [RawDialogRoute] when the button is tapped.\n///\n/// {@macro flutter.widgets.RestorationManager}\n///\n/// ** See code in examples/api/lib/widgets/routes/show_general_dialog.0.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [DisplayFeatureSubScreen], which documents the specifics of how\n///    [DisplayFeature]s can split the screen into sub-screens.\n///  * [showDialog], which displays a Material-style dialog.\n///  * [showCupertinoDialog], which displays an iOS-style dialog.\nFuture<T?> showGeneralDialog<T extends Object?>({\n  required BuildContext context,\n  required RoutePageBuilder pageBuilder,\n  bool barrierDismissible = false,\n  String? barrierLabel,\n  Color barrierColor = const Color(0x80000000),\n  Duration transitionDuration = const Duration(milliseconds: 200),\n  RouteTransitionsBuilder? transitionBuilder,\n  bool useRootNavigator = true,\n  RouteSettings? routeSettings,\n  Offset? anchorPoint,\n}) {\n  assert(!barrierDismissible || barrierLabel != null);\n  return Navigator.of(context, rootNavigator: useRootNavigator).push<T>(\n    RawDialogRoute<T>(\n      pageBuilder: pageBuilder,\n      barrierDismissible: barrierDismissible,\n      barrierLabel: barrierLabel,\n      barrierColor: barrierColor,\n      transitionDuration: transitionDuration,\n      transitionBuilder: transitionBuilder,\n      settings: routeSettings,\n      anchorPoint: anchorPoint,\n    ),\n  );\n}\n\n/// Signature for the function that builds a route's primary contents.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildPage] for complete definition of the parameters.\ntypedef RoutePageBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n    );\n\n/// Signature for the function that builds a route's transitions.\n/// Used in [PageRouteBuilder] and [showGeneralDialog].\n///\n/// See [ModalRoute.buildTransitions] for complete definition of the parameters.\ntypedef RouteTransitionsBuilder =\n    Widget Function(\n      BuildContext context,\n      Animation<double> animation,\n      Animation<double> secondaryAnimation,\n      Widget child,\n    );\n\n/// A callback type for informing that a navigation pop has been invoked,\n/// whether or not it was handled successfully.\n///\n/// Accepts a didPop boolean indicating whether or not back navigation\n/// succeeded.\n///\n/// The `result` contains the pop result.\ntypedef PopInvokedWithResultCallback<T> = void Function(bool didPop, T? result);\n\n/// Allows listening to and preventing pops.\n///\n/// Can be registered in [ModalRoute] to listen to pops with [onPopInvokedWithResult] or\n/// to enable/disable them with [canPopNotifier].\n///\n/// See also:\n///\n///  * [PopScope], which provides similar functionality in a widget.\n///  * [ModalRoute.registerPopEntry], which unregisters instances of this.\n///  * [ModalRoute.unregisterPopEntry], which unregisters instances of this.\nabstract class PopEntry<T> {\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  @Deprecated(\n    'Use onPopInvokedWithResult instead. '\n    'This feature was deprecated after v3.22.0-12.0.pre.',\n  )\n  void onPopInvoked(bool didPop) {}\n\n  /// {@macro flutter.widgets.PopScope.onPopInvokedWithResult}\n  void onPopInvokedWithResult(bool didPop, T? result) => onPopInvoked(didPop);\n\n  /// {@macro flutter.widgets.PopScope.canPop}\n  ValueListenable<bool> get canPopNotifier;\n\n  @override\n  String toString() {\n    return 'PopEntry canPop: ${canPopNotifier.value}, onPopInvoked: $onPopInvokedWithResult';\n  }\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 10: RouteObserver\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 10: RouteObserver\n\nWelcome back! In our previous chapter, [Chapter 9: RouteAware](09_routeaware_.md), we learned about `RouteAware`, a mixin that lets individual widgets listen for signals about their screen's visibility changing. We saw how a widget could know if its screen was covered or uncovered by another route.\n\nBut how do those signals get sent? How does the navigation system know *which* `RouteAware` widgets are interested in *which* routes? That's the job of the `RouteObserver`!\n\n### What is a RouteObserver?\n\nImagine a librarian who keeps a list of people (your `RouteAware` widgets) currently reading specific books (your [Route](01_route_.md)s). When someone puts a new book on the table (pushes a new route) or takes a book away (pops a route), the librarian checks their list and tells the affected readers what happened (\"Someone just put a new book on top of yours!\", \"The book on top was just taken away, yours is visible again!\").\n\nA `RouteObserver` is just like that librarian. It:\n\n1.  Sits and watches the [Navigator](03_overlayroute_.md)'s stack of routes.\n2.  Keeps a list of `RouteAware` objects that have \"subscribed\" to specific routes.\n3.  When a navigation event happens (push, pop, etc.), it figures out which routes are affected.\n4.  For the affected routes, it looks up which `RouteAware` objects are subscribed to them.\n5.  It then calls the appropriate `RouteAware` methods (`didPush`, `didPop`, `didPushNext`, `didPopNext`) on those subscribed objects.\n\nYou typically create **one** `RouteObserver` instance for your entire app and provide it to your main [Navigator](03_overlayroute_.md) (usually through `MaterialApp` or `CupertinoApp`). Then, any `RouteAware` widget in your app can subscribe to it.\n\n### Why Use RouteObserver?\n\n`RouteObserver` acts as the central hub for `RouteAware` notifications. Without it, the [Navigator](03_overlayroute_.md) wouldn't know about individual widgets wanting to listen to route changes.\n\n*   **Decoupling:** It keeps the [Navigator](03_overlayroute_.md) clean. The [Navigator](03_overlayroute_.md) just needs to tell its observers what happened. The observers handle finding and notifying the interested widgets.\n*   **Scalability:** You can have many `RouteAware` widgets throughout your app, all using the same `RouteObserver` instance to get notified.\n*   **Clear Communication:** It provides a standard mechanism for widgets to react to navigation lifecycle events.\n\nYou won't usually inherit from `RouteObserver`. You just create an instance of it and use it.\n\n### Key Concepts of RouteObserver\n\n*   **Extends `NavigatorObserver`:** `RouteObserver` gets its \"watchful\" ability by extending `NavigatorObserver`. `NavigatorObserver` is a class that the [Navigator](03_overlayroute_.md) calls methods on whenever navigation events happen. `RouteObserver` implements these `NavigatorObserver` methods (like `didPush`, `didPop`) and uses them as triggers to notify its subscribers.\n*   **Subscription:** `RouteAware` objects (specifically, the `State` objects that mix in `RouteAware`) call `routeObserver.subscribe(this, route)` to start receiving notifications for a particular route.\n*   **Unsubscription:** `RouteAware` objects **must** call `routeObserver.unsubscribe(this)` when they are no longer needed (usually in their `dispose` method) to prevent memory leaks.\n*   **Mapping:** `RouteObserver` uses an internal map (`_listeners`) to keep track of which subscribers (`RouteAware` objects) are interested in which routes.\n\n### How RouteObserver Works (Conceptual)\n\nLet's revisit the push sequence from the [RouteAware](09_routeaware_.md) chapter, focusing on the `RouteObserver`'s role.\n\n```mermaid\nsequenceDiagram\n    participant Navigator as Navigator\n    participant RouteObserver as Route Observer\n    participant OldPageRoute as Old Page Route\n    participant NewPageRoute as New Page Route\n    participant OldWidget as Old Widget (RouteAware)\n    participant NewWidget as New Widget (RouteAware)\n\n    Setup->>RouteObserver: RouteObserver added to Navigator.navigatorObservers\n\n    WidgetLifecycle->>OldWidget: OldWidget initState/didChangeDependencies\n    OldWidget->>RouteObserver: subscribe(OldWidget, OldPageRoute)\n    RouteObserver->>OldWidget: Calls didPush() (initial screen)\n\n    Navigation->>Navigator: Navigator.push(NewPageRoute)\n    Navigator->>RouteObserver: Calls didPush(NewPageRoute, OldPageRoute)\n\n    RouteObserver->>RouteObserver: Looks up subscribers for OldPageRoute (_listeners[OldPageRoute])\n    RouteObserver->>OldWidget: Calls didPushNext()\n\n    RouteObserver->>RouteObserver: Looks up subscribers for NewPageRoute (_listeners[NewPageRoute]) - empty list initially\n    WidgetLifecycle->>NewWidget: NewWidget initState/didChangeDependencies\n    NewWidget->>RouteObserver: subscribe(NewWidget, NewPageRoute)\n    RouteObserver->>NewWidget: Calls didPush() (new screen)\n\n    User->>Navigator: Press Back Btn (Navigator.pop())\n    Navigator->>RouteObserver: Calls didPop(NewPageRoute, OldPageRoute)\n\n    RouteObserver->>RouteObserver: Looks up subscribers for NewPageRoute (_listeners[NewPageRoute])\n    RouteObserver->>NewWidget: Calls didPop()\n\n    RouteObserver->>RouteObserver: Looks up subscribers for OldPageRoute (_listeners[OldPageRoute])\n    RouteObserver->>OldWidget: Calls didPopNext()\n\n    WidgetLifecycle->>NewWidget: NewWidget dispose\n    NewWidget->>RouteObserver: unsubscribe(NewWidget)\n```\n\n1.  The `RouteObserver` is created and given to the `Navigator`.\n2.  When a `RouteAware` widget initializes, it finds its route and the `RouteObserver` (via `InheritedWidget`s not explicitly shown here, like `Navigator`), and calls `subscribe(this, route)`. The observer adds the widget to its internal map keyed by the route. For the very first route, the observer calls `didPush` on subscription.\n3.  When `Navigator.push` is called:\n    *   The `Navigator` calls `didPush` on its observers, including our `RouteObserver`.\n    *   Our `RouteObserver` receives the `newRoute` and `previousRoute`.\n    *   It finds all subscribers for the `previousRoute` and calls `didPushNext()` on them, because their route is now covered.\n    *   It finds all subscribers for the `newRoute` (there shouldn't be any yet, as the widgets haven't built/subscribed).\n4.  The new screen's widgets build, including the `RouteAware` ones.\n5.  When the new `RouteAware` widget initializes (`didChangeDependencies`), it subscribes to the observer for the `newRoute`. When `subscribe` is called, the observer sees this is the currently active route and immediately calls `didPush()` on the new subscriber.\n6.  When `Navigator.pop` is called:\n    *   The `Navigator` calls `didPop` on its observers.\n    *   Our `RouteObserver` receives the `poppedRoute` and the `routeBelow` (which is the `previousRoute` from the push).\n    *   It finds all subscribers for the `poppedRoute` and calls `didPop()`.\n    *   It finds all subscribers for the `routeBelow` and calls `didPopNext()`, as their route is now the top one again.\n7.  When the popped screen's widget is disposed, its `RouteAware` state calls `unsubscribe`.\n\nThe `RouteObserver` acts as the intermediary, relaying events from the `Navigator` to the specific `RouteAware` widgets that signed up to listen.\n\n### Looking at the Code\n\nLet's look at the definition of the `RouteObserver` class.\n\n```dart\nclass RouteObserver<R extends Route<dynamic>> extends NavigatorObserver {\n  // Stores the subscribers for each route. Map is from Route -> Set of RouteAware objects.\n  final Map<R, Set<RouteAware>> _listeners = <R, Set<RouteAware>>{};\n\n  /// Subscribe [routeAware] to be informed about changes to [route].\n  void subscribe(RouteAware routeAware, R route) {\n    // Get or create the set of subscribers for this route.\n    final Set<RouteAware> subscribers = _listeners.putIfAbsent(route, () => <RouteAware>{});\n    // Add the routeAware object to the set.\n    if (subscribers.add(routeAware)) {\n      // Immediately notify the newly subscribed widget IF its route is the current one.\n      // This handles the case where the widget is built on the currently visible screen.\n      // (Although subscribing in didChangeDependencies after push handles this too).\n      routeAware.didPush();\n    }\n  }\n\n  /// Unsubscribe [routeAware].\n  void unsubscribe(RouteAware routeAware) {\n    // Iterate through all routes being observed\n    final List<R> routes = _listeners.keys.toList(); // Copy keys to avoid modifying during iteration\n    for (final R route in routes) {\n      final Set<RouteAware>? subscribers = _listeners[route];\n      if (subscribers != null) {\n        // Remove the routeAware object from the set for this route.\n        subscribers.remove(routeAware);\n        // If the set becomes empty, remove the route from the map.\n        if (subscribers.isEmpty) {\n          _listeners.remove(route);\n        }\n      }\n    }\n  }\n\n  @override\n  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    // Called by the Navigator when a route is popped.\n    // Check if the popped route and the route below are of the generic type R we are observing.\n    if (route is R && previousRoute is R) {\n      // Get subscribers for the route *below* the popped one.\n      final List<RouteAware>? previousSubscribers = _listeners[previousRoute]?.toList();\n\n      if (previousSubscribers != null) {\n        // Notify those subscribers that the route above them was popped.\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPopNext();\n        }\n      }\n\n      // Get subscribers for the popped route.\n      final List<RouteAware>? subscribers = _listeners[route]?.toList();\n\n      if (subscribers != null) {\n        // Notify those subscribers that their route was popped.\n        for (final RouteAware routeAware in subscribers) {\n          routeAware.didPop();\n        }\n        // We might expect the route to be removed from _listeners later via unsubscribe\n        // from the disposed widgets, but explicitly removing it here is also an option\n        // if there are no more expected subscribers. The current implementation relies\n        // on explicit unsubscribe.\n      }\n    }\n  }\n\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {\n    // Called by the Navigator when a route is pushed.\n     // Check if the new route and the route below are of the generic type R we are observing.\n    if (route is R && previousRoute is R) {\n      // Get subscribers for the route *below* the new one.\n      final Set<RouteAware>? previousSubscribers = _listeners[previousRoute];\n\n      if (previousSubscribers != null) {\n        // Notify those subscribers that a new route was pushed on top of theirs.\n        for (final RouteAware routeAware in previousSubscribers) {\n          routeAware.didPushNext();\n        }\n      }\n       // Note: Subscribers for the 'route' just pushed aren't notified via didPush here.\n       // They are notified inside the subscribe method when they register themselves\n       // in their didChangeDependencies. This is because didPush happens early\n       // in the route's lifecycle, before widgets are fully built and can subscribe.\n    }\n  }\n}\n```\n\nKey parts:\n\n*   `extends NavigatorObserver`: This is where it gets the `didPop` and `didPush` methods that the `Navigator` calls.\n*   `Map<R, Set<RouteAware>> _listeners`: The heart of the observer \u2013 a map storing sets of `RouteAware` objects, keyed by the `Route` objects they are interested in. `R` is a generic type parameter, allowing you to observe specific route types (like `PageRoute` or `ModalRoute`) or all routes (`Route<dynamic>`).\n*   `subscribe(RouteAware routeAware, R route)`: Adds a `RouteAware` object to the set associated with a specific `route`. If the route is the current one, it immediately calls `didPush`.\n*   `unsubscribe(RouteAware routeAware)`: Removes a `RouteAware` object from any set it is in across all\n  routes being observed. This is critical for cleanup.\n*   `didPop(Route route, Route previousRoute)`: When notified of a pop, it finds the subscribers for the `previousRoute` (the one *below* the popped one) and calls `didPopNext()`. It finds subscribers for the popped `route` and calls `didPop()`.\n*   `didPush(Route route, Route previousRoute)`: When notified of a push, it finds the subscribers for the `previousRoute` (the one *below* the new one) and calls `didPushNext()`.\n\n### Example: Connecting RouteAware and RouteObserver\n\nWe already saw the `RouteAwareWidget` in the previous chapter. The missing piece to make it work was providing the `RouteObserver` to the `Navigator` and passing it down (or accessing it via a method like `Navigator.of(context)` if the observer was retrieved elsewhere, though passing it explicitly is often clearer for beginner examples).\n\nHere's how you set up the `MaterialApp` to provide the observer:\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter/widgets.dart'; // Needed for RouteAware\n\n// The RouteObserver instance your widgets will subscribe to.\n// It's usually global or provided via a dependency injection system.\nfinal RouteObserver<ModalRoute<dynamic>> routeObserver = RouteObserver<ModalRoute<dynamic>>();\n\n// (Code for TrackedScreen and RouteAwareWidget from Chapter 9 goes here)\n// ... copy/paste TrackedScreen and RouteAwareWidget (including the mixin state and methods) ...\n\nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'RouteObserver Example',\n      // This is where you give the Navigator your RouteObserver!\n      navigatorObservers: [routeObserver],\n      home: const TrackedScreen(screenName: 'Home'),\n    );\n  }\n}\n\nvoid main() {\n  runApp(const MyApp());\n}\n```\n\nIn this setup:\n\n1.  We create the `routeObserver` instance. We specify `<ModalRoute<dynamic>>` to observe changes for any type of `ModalRoute` (which includes full-screen pages like those created by `MaterialPageRoute`).\n2.  In `MaterialApp`, we use the `navigatorObservers` parameter and pass our `routeObserver` instance in a list. The `MaterialApp`'s internal `Navigator` will now notify this observer about navigation events.\n3.  Our `RouteAwareWidget` (from the previous chapter) receives this observer and uses its `subscribe`/`unsubscribe` methods.\n\nNow, when you run this application and navigate between the `TrackedScreen`s, the `RouteAwareWidget` instances will receive the `didPush`, `didPop`, `didPushNext`, and `didPopNext` notifications because:\n\n*   Navigation events happen on the `Navigator`.\n*   The `Navigator` calls `didPush`/`didPop` on the `routeObserver`.\n*   The `routeObserver` looks up which `RouteAwareWidgetState` instances are subscribed to the affected routes and calls the corresponding `RouteAware` methods on them.\n*   The `RouteAwareWidgetState` then updates its internal status and rebuilds.\n\nThis clearly shows the flow: `Navigator` -> `RouteObserver` -> `RouteAware`.\n\n### Conclusion\n\nIn this chapter, we learned about `RouteObserver`, the crucial component that tracks navigation events within the `Navigator` and dispatches notifications to interested `RouteAware` objects. We saw that it extends `NavigatorObserver` to receive notifications from the `Navigator` and maintains a mapping of routes to their subscribed `RouteAware` widgets. By providing a `RouteObserver` to your app's `Navigator` and having widgets mix in `RouteAware` and subscribe/unsubscribe, you enable them to react gracefully to navigation lifecycle changes.\n\nThis concludes our series on Flutter navigation core concepts! We started with the basic [Route](01_route_.md) stack and ended with how individual widgets can become aware of their route's state, covering animations, overlays, predictive back, and local history along the way. Understanding these concepts provides a solid foundation for building robust navigation in your Flutter applications."}