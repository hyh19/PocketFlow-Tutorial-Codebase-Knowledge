{"\nFor the project `flutter`:\n\nCodebase Context:\n--- File Index 0: packages/flutter/lib/src/foundation/change_notifier.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\n\n\nAnalyze the codebase context.\nIdentify the top 5-10 core most important abstractions to help those new to the codebase.\n\nFor each abstraction, provide:\n1. A concise `name`.\n2. A beginner-friendly `description` explaining what it is with a simple analogy, in around 100 words.\n3. A list of relevant `file_indices` (integers) using the format `idx # path/comment`.\n\nList of file indices and paths present in the context:\n- 0 # packages/flutter/lib/src/foundation/change_notifier.dart\n\nFormat the output as a YAML list of dictionaries:\n\n```yaml\n- name: |\n    Query Processing\n  description: |\n    Explains what the abstraction does.\n    It's like a central dispatcher routing requests.\n  file_indices:\n    - 0 # path/to/file1.py\n    - 3 # path/to/related.py\n- name: |\n    Query Optimization\n  description: |\n    Another core concept, similar to a blueprint for objects.\n  file_indices:\n    - 5 # path/to/another.js\n# ... up to 10 abstractions\n```": "```yaml\n- name: |\n    Listenable\n  description: |\n    Imagine you have a list of people who are interested in knowing when something specific changes. The `Listenable` is like the thing that can be watched. It doesn't hold any data itself, but it has a way for folks to \"sign up\" to be notified when it changes, and a way for them to \"unsubscribe\". Any object that wants to let others know about its changes without revealing its internal details can implement this interface.\n  file_indices:\n    - 0 # packages/flutter/lib/src/foundation/change_notifier.dart\n- name: |\n    ValueListenable\n  description: |\n    Building on the `Listenable` concept, a `ValueListenable` is like a special sign-up sheet for things that have a specific value that can change. Not only can you subscribe to be notified when it changes, but you can also immediately ask for its current value. Think of it as a box with a window: you can see what's inside (the value) and get a ping when the thing inside is replaced with something else.\n  file_indices:\n    - 0 # packages/flutter/lib/src/foundation/change_notifier.dart\n- name: |\n    ChangeNotifier\n  description: |\n    The `ChangeNotifier` is a concrete tool you can use to create objects that act as `Listenable`s. It's like a manager for that list of interested people. You can add and remove listeners easily, and when something needs to change, you just tell the `ChangeNotifier` to \"notify its listeners,\" and it goes through its list and tells everyone who signed up. It handles the complexity of managing the listener list for you.\n  file_indices:\n    - 0 # packages/flutter/lib/src/foundation/change_notifier.dart\n- name: |\n    ValueNotifier\n  description: |\n    This is a specific type of `ChangeNotifier` that's designed to hold and manage a _single_ value. It's like a simple counter or a status indicator that everyone is watching. When the value inside changes (and is different from the old value), it automatically uses the `ChangeNotifier`'s mechanism to tell all the listeners. It's a convenient way to make a single piece of data observable.\n  file_indices:\n    - 0 # packages/flutter/lib/src/foundation/change_notifier.dart\n```", "\nBased on the following abstractions and relevant code snippets from the project `flutter`:\n\nList of Abstraction Indices and Names:\n0 # Listenable\n\n1 # ValueListenable\n\n2 # ChangeNotifier\n\n3 # ValueNotifier\n\n\nContext (Abstractions, Descriptions, Code):\nIdentified Abstractions:\\n- Index 0: Listenable\n (Relevant file indices: [0])\\n  Description: Imagine you have a list of people who are interested in knowing when something specific changes. The `Listenable` is like the thing that can be watched. It doesn't hold any data itself, but it has a way for folks to \"sign up\" to be notified when it changes, and a way for them to \"unsubscribe\". Any object that wants to let others know about its changes without revealing its internal details can implement this interface.\n\\n- Index 1: ValueListenable\n (Relevant file indices: [0])\\n  Description: Building on the `Listenable` concept, a `ValueListenable` is like a special sign-up sheet for things that have a specific value that can change. Not only can you subscribe to be notified when it changes, but you can also immediately ask for its current value. Think of it as a box with a window: you can see what's inside (the value) and get a ping when the thing inside is replaced with something else.\n\\n- Index 2: ChangeNotifier\n (Relevant file indices: [0])\\n  Description: The `ChangeNotifier` is a concrete tool you can use to create objects that act as `Listenable`s. It's like a manager for that list of interested people. You can add and remove listeners easily, and when something needs to change, you just tell the `ChangeNotifier` to \"notify its listeners,\" and it goes through its list and tells everyone who signed up. It handles the complexity of managing the listener list for you.\n\\n- Index 3: ValueNotifier\n (Relevant file indices: [0])\\n  Description: This is a specific type of `ChangeNotifier` that's designed to hold and manage a _single_ value. It's like a simple counter or a status indicator that everyone is watching. When the value inside changes (and is different from the old value), it automatically uses the `ChangeNotifier`'s mechanism to tell all the listeners. It's a convenient way to make a single piece of data observable.\n\\n\\nRelevant File Snippets (Referenced by Index and Path):\\n--- File: 0 # packages/flutter/lib/src/foundation/change_notifier.dart ---\\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\nPlease provide:\n1. A high-level `summary` of the project's main purpose and functionality in a few beginner-friendly sentences. Use markdown formatting with **bold** and *italic* text to highlight important concepts.\n2. A list (`relationships`) describing the key interactions between these abstractions. For each relationship, specify:\n    - `from_abstraction`: Index of the source abstraction (e.g., `0 # AbstractionName1`)\n    - `to_abstraction`: Index of the target abstraction (e.g., `1 # AbstractionName2`)\n    - `label`: A brief label for the interaction **in just a few words** (e.g., \"Manages\", \"Inherits\", \"Uses\").\n    Ideally the relationship should be backed by one abstraction calling or passing parameters to another.\n    Simplify the relationship and exclude those non-important ones.\n\nIMPORTANT: Make sure EVERY abstraction is involved in at least ONE relationship (either as source or target). Each abstraction index must appear at least once across all relationships.\n\nFormat the output as YAML:\n\n```yaml\nsummary: |\n  A brief, simple explanation of the project.\n  Can span multiple lines with **bold** and *italic* for emphasis.\nrelationships:\n  - from_abstraction: 0 # AbstractionName1\n    to_abstraction: 1 # AbstractionName2\n    label: \"Manages\"\n  - from_abstraction: 2 # AbstractionName3\n    to_abstraction: 0 # AbstractionName1\n    label: \"Provides config\"\n  # ... other relationships\n```\n\nNow, provide the YAML output:\n": "```yaml\nsummary: |\n  This part of the Flutter framework provides core tools for **managing and notifying listeners about changes**.\n  It allows objects to be *watched* and provides convenient ways to handle single changing values or more complex scenarios\n  where multiple parts of your application need to react to updates.\nrelationships:\n  - from_abstraction: 1 # ValueListenable\n    to_abstraction: 0 # Listenable\n    label: \"Extends\"\n  - from_abstraction: 2 # ChangeNotifier\n    to_abstraction: 0 # Listenable\n    label: \"Implements\"\n  - from_abstraction: 3 # ValueNotifier\n    to_abstraction: 2 # ChangeNotifier\n    label: \"Extends\"\n  - from_abstraction: 3 # ValueNotifier\n    to_abstraction: 1 # ValueListenable\n    label: \"Implements\"\n```", "\nGiven the following project abstractions and their relationships for the project ```` flutter ````:\n\nAbstractions (Index # Name):\n- 0 # Listenable\n\n- 1 # ValueListenable\n\n- 2 # ChangeNotifier\n\n- 3 # ValueNotifier\n\n\nContext about relationships and project summary:\nProject Summary:\nThis part of the Flutter framework provides core tools for **managing and notifying listeners about changes**.\nIt allows objects to be *watched* and provides convenient ways to handle single changing values or more complex scenarios\nwhere multiple parts of your application need to react to updates.\n\n\nRelationships (Indices refer to abstractions above):\n- From 1 (ValueListenable\n) to 0 (Listenable\n): Extends\n- From 2 (ChangeNotifier\n) to 0 (Listenable\n): Implements\n- From 3 (ValueNotifier\n) to 2 (ChangeNotifier\n): Extends\n- From 3 (ValueNotifier\n) to 1 (ValueListenable\n): Implements\n\n\nIf you are going to make a tutorial for ```` flutter ````, what is the best order to explain these abstractions, from first to last?\nIdeally, first explain those that are the most important or foundational, perhaps user-facing concepts or entry points. Then move to more detailed, lower-level implementation details or supporting concepts.\n\nOutput the ordered list of abstraction indices, including the name in a comment for clarity. Use the format `idx # AbstractionName`.\n\n```yaml\n- 2 # FoundationalConcept\n- 0 # CoreClassA\n- 1 # CoreClassB (uses CoreClassA)\n- ...\n```\n\nNow, provide the YAML output:\n": "```yaml\n- 2 # ChangeNotifier\n- 0 # Listenable\n- 3 # ValueNotifier\n- 1 # ValueListenable\n```", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"ChangeNotifier\n\". This is Chapter 1.\n\nConcept Details:\n- Name: ChangeNotifier\n\n- Description:\nThe `ChangeNotifier` is a concrete tool you can use to create objects that act as `Listenable`s. It's like a manager for that list of interested people. You can add and remove listeners easily, and when something needs to change, you just tell the `ChangeNotifier` to \"notify its listeners,\" and it goes through its list and tells everyone who signed up. It handles the complexity of managing the listener list for you.\n\n\nComplete Tutorial Structure:\n1. [ChangeNotifier\n](01_changenotifier_.md)\n2. [Listenable\n](02_listenable_.md)\n3. [ValueNotifier\n](03_valuenotifier_.md)\n4. [ValueListenable\n](04_valuelistenable_.md)\n\nContext from previous chapters:\nThis is the first chapter.\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/foundation/change_notifier.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 1: ChangeNotifier\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 1: ChangeNotifier\n\nWelcome to the Flutter foundation concepts! In this chapter, we're going to explore a really useful tool called `ChangeNotifier`. Imagine you have different parts of your app that need to know when something important happens in another part. How do you tell them? That's where `ChangeNotifier` comes in!\n\n### Why do we need `ChangeNotifier`?\n\nLet's say you have a simple app with a counter. You have a button that increases the count, and you want a text widget to show the current count. When you press the button and increase the count, how does the text widget know to update itself?\n\nYou could try passing the counter value around everywhere, but that gets messy quickly. What if multiple widgets need to know the count? What if the count changes in multiple places?\n\nWe need a way for the object holding the counter value to announce to anyone interested that its value has changed. This is where `ChangeNotifier` helps us.\n\n### What is `ChangeNotifier`?\n\nThink of `ChangeNotifier` as a little manager for a list of interested parties. The \"interested parties\" are called **listeners**. These listeners are basically pieces of code that want to know when something changes in the `ChangeNotifier`.\n\nWhen something *does* change in the object that uses a `ChangeNotifier`, we tell the `ChangeNotifier` to \"notify its listeners\". The `ChangeNotifier` then goes through its list of listeners and tells each one, \"Hey, something changed! You might want to update yourself.\"\n\nIt handles the tricky business of keeping track of who wants to listen and making sure they get the message.\n\n### How does it work?\n\nTo use `ChangeNotifier`, you typically create a class that holds the data you want to track (like our counter). Your class will either **extend** or **mix in** `ChangeNotifier`. Mixing in is like adding extra abilities to your class.\n\nHere's a simple example of a counter class that uses `ChangeNotifier`:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier {\n  int _count = 0; // Our private counter value\n\n  int get count => _count; // A cleaner way to get the count\n\n  void increment() {\n    _count++; // Increase the count\n    notifyListeners(); // Announce that the count has changed\n  }\n}\n```\n\nIn this code:\n\n1. We import `flutter/foundation.dart` which contains `ChangeNotifier`.\n2. We create a class `MyCounter` and add the `ChangeNotifier` capabilities to it using `with ChangeNotifier`.\n3. We have a private variable `_count` to hold our counter value. We use the `_` prefix to indicate it's internal to this class.\n4. We provide a `get` method to access `count` from outside the class.\n5. We have an `increment` method that increases the `_count`.\n6. The important part is `notifyListeners()`. When we call this method, `ChangeNotifier` tells all the listeners that the `count` has changed.\n\n### Becoming a Listener\n\nNow that we have an object that can announce changes (`MyCounter`), we need a way for other parts of the app (like our text widget) to *listen* for those announcements. We'll learn more about *how* other parts of the UI listen in later chapters when we talk about widgets that are designed to work with objects that can announce changes.\n\nFor now, let's just focus on the core idea of adding and removing listeners on the `ChangeNotifier` itself. The `ChangeNotifier` class has methods for this:\n\n```dart\nvoid addListener(VoidCallback listener);\nvoid removeListener(VoidCallback listener);\n```\n\n*   `addListener`: This method takes a function (a `VoidCallback`) as input. This function is the 'listener' code that will be run when `notifyListeners()` is called.\n*   `removeListener`: This method also takes a `VoidCallback`. It removes a listener that was previously added.\n\nYou can see these methods in the `ChangeNotifier` code snippet:\n\n```dart\n/// Register a closure to be called when the object notifies its listeners.\nvoid addListener(VoidCallback listener);\n\n/// Remove a previously registered closure from the list of closures that the\n/// object notifies.\nvoid removeListener(VoidCallback listener);\n```\n\nUsually, you won't call these methods directly yourself when building a Flutter app with widgets. Flutter provides special widgets that handle adding and removing listeners for you, making it much easier. But understanding that this is happening under the hood is important!\n\n### Inside `ChangeNotifier` (Simplified)\n\nHow does `ChangeNotifier` keep track of listeners and notify them? Looking at the code, we can see it manages a list of `VoidCallback?` (which are functions that take no arguments and return nothing and can also be null):\n\n```dart\nList<VoidCallback?> _listeners = _emptyListeners;\nint _count = 0;\n```\n\n*   `_listeners`: This is the internal list where `ChangeNotifier` stores all the functions (listeners) that have been added.\n*   `_count`: This keeps track of how many active listeners are currently in the list.\n\nWhen you call `addListener(someFunction)`, `ChangeNotifier` adds `someFunction` to this `_listeners` list and increases `_count`.\n\nWhen you call `removeListener(someFunction)`, `ChangeNotifier` finds `someFunction` in the list and removes it (or marks it for removal if notifications are currently happening).\n\nWhen you call `notifyListeners()`, `ChangeNotifier` loops through its `_listeners` list and calls each function (listener) one by one:\n\n```dart\nvoid notifyListeners() {\n  // ... other code ...\n  final int end = _count;\n  for (int i = 0; i < end; i++) {\n    try {\n      _listeners[i]?.call(); // Calls the listener function\n    } catch (exception, stack) {\n      // Handles any errors that happen in a listener\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis loop is the core of how `ChangeNotifier` works \u2013 it simply goes through its list and calls every listener function.\n\nHere's a super simple sequence diagram to visualize the process when `notifyListeners()` is called:\n\n```mermaid\nsequenceDiagram\n    participant ObjectWithChangeNotifier\n    participant ChangeNotifierInstance\n    participant Listener1\n    participant Listener2\n\n    ObjectWithChangeNotifier->>ChangeNotifierInstance: notifyListeners()\n    ChangeNotifierInstance->>Listener1: Call listener function\n    ChangeNotifierInstance->>Listener2: Call listener function\n    Note over ChangeNotifierInstance: Done notifying listeners\n```\n\nThis diagram shows that when `notifyListeners()` is called on the `ChangeNotifier`, it then calls the functions registered by `Listener1` and `Listener2`.\n\n### Conclusion\n\nIn this chapter, we learned about `ChangeNotifier`, a fundamental building block in Flutter for creating objects that can announce changes to interested parts of your application. We saw how it manages a list of listeners and how you call `notifyListeners()` to trigger an update.\n\nWhile we touched on `addListener` and `removeListener`, we also noted that in a typical Flutter app, you'll use specialized widgets to handle the listening part. In the next chapter, we will dive deeper into the concept of a `Listenable`, which is the interface that `ChangeNotifier` implements and which other parts of Flutter interact with.\n\n[Next Chapter: Listenable](02_listenable_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"Listenable\n\". This is Chapter 2.\n\nConcept Details:\n- Name: Listenable\n\n- Description:\nImagine you have a list of people who are interested in knowing when something specific changes. The `Listenable` is like the thing that can be watched. It doesn't hold any data itself, but it has a way for folks to \"sign up\" to be notified when it changes, and a way for them to \"unsubscribe\". Any object that wants to let others know about its changes without revealing its internal details can implement this interface.\n\n\nComplete Tutorial Structure:\n1. [ChangeNotifier\n](01_changenotifier_.md)\n2. [Listenable\n](02_listenable_.md)\n3. [ValueNotifier\n](03_valuenotifier_.md)\n4. [ValueListenable\n](04_valuelistenable_.md)\n\nContext from previous chapters:\n# Chapter 1: ChangeNotifier\n\nWelcome to the Flutter foundation concepts! In this chapter, we're going to explore a really useful tool called `ChangeNotifier`. Imagine you have different parts of your app that need to know when something important happens in another part. How do you tell them? That's where `ChangeNotifier` comes in!\n\n### Why do we need `ChangeNotifier`?\n\nLet's say you have a simple app with a counter. You have a button that increases the count, and you want a text widget to show the current count. When you press the button and increase the count, how does the text widget know to update itself?\n\nYou could try passing the counter value around everywhere, but that gets messy quickly. What if multiple widgets need to know the count? What if the count changes in multiple places?\n\nWe need a way for the object holding the counter value to announce to anyone interested that its value has changed. This is where `ChangeNotifier` helps us.\n\n### What is `ChangeNotifier`?\n\nThink of `ChangeNotifier` as a little manager for a list of interested parties. The \"interested parties\" are called **listeners**. These listeners are basically pieces of code that want to know when something changes in the `ChangeNotifier`.\n\nWhen something *does* change in the object that uses a `ChangeNotifier`, we tell the `ChangeNotifier` to \"notify its listeners\". The `ChangeNotifier` then goes through its list of listeners and tells each one, \"Hey, something changed! You might want to update yourself.\"\n\nIt handles the tricky business of keeping track of who wants to listen and making sure they get the message.\n\n### How does it work?\n\nTo use `ChangeNotifier`, you typically create a class that holds the data you want to track (like our counter). Your class will either **extend** or **mix in** `ChangeNotifier`. Mixing in is like adding extra abilities to your class.\n\nHere's a simple example of a counter class that uses `ChangeNotifier`:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier {\n  int _count = 0; // Our private counter value\n\n  int get count => _count; // A cleaner way to get the count\n\n  void increment() {\n    _count++; // Increase the count\n    notifyListeners(); // Announce that the count has changed\n  }\n}\n```\n\nIn this code:\n\n1. We import `flutter/foundation.dart` which contains `ChangeNotifier`.\n2. We create a class `MyCounter` and add the `ChangeNotifier` capabilities to it using `with ChangeNotifier`.\n3. We have a private variable `_count` to hold our counter value. We use the `_` prefix to indicate it's internal to this class.\n4. We provide a `get` method to access `count` from outside the class.\n5. We have an `increment` method that increases the `_count`.\n6. The important part is `notifyListeners()`. When we call this method, `ChangeNotifier` tells all the listeners that the `count` has changed.\n\n### Becoming a Listener\n\nNow that we have an object that can announce changes (`MyCounter`), we need a way for other parts of the app (like our text widget) to *listen* for those announcements. We'll learn more about *how* other parts of the UI listen in later chapters when we talk about widgets that are designed to work with objects that can announce changes.\n\nFor now, let's just focus on the core idea of adding and removing listeners on the `ChangeNotifier` itself. The `ChangeNotifier` class has methods for this:\n\n```dart\nvoid addListener(VoidCallback listener);\nvoid removeListener(VoidCallback listener);\n```\n\n*   `addListener`: This method takes a function (a `VoidCallback`) as input. This function is the 'listener' code that will be run when `notifyListeners()` is called.\n*   `removeListener`: This method also takes a `VoidCallback`. It removes a listener that was previously added.\n\nYou can see these methods in the `ChangeNotifier` code snippet:\n\n```dart\n/// Register a closure to be called when the object notifies its listeners.\nvoid addListener(VoidCallback listener);\n\n/// Remove a previously registered closure from the list of closures that the\n/// object notifies.\nvoid removeListener(VoidCallback listener);\n```\n\nUsually, you won't call these methods directly yourself when building a Flutter app with widgets. Flutter provides special widgets that handle adding and removing listeners for you, making it much easier. But understanding that this is happening under the hood is important!\n\n### Inside `ChangeNotifier` (Simplified)\n\nHow does `ChangeNotifier` keep track of listeners and notify them? Looking at the code, we can see it manages a list of `VoidCallback?` (which are functions that take no arguments and return nothing and can also be null):\n\n```dart\nList<VoidCallback?> _listeners = _emptyListeners;\nint _count = 0;\n```\n\n*   `_listeners`: This is the internal list where `ChangeNotifier` stores all the functions (listeners) that have been added.\n*   `_count`: This keeps track of how many active listeners are currently in the list.\n\nWhen you call `addListener(someFunction)`, `ChangeNotifier` adds `someFunction` to this `_listeners` list and increases `_count`.\n\nWhen you call `removeListener(someFunction)`, `ChangeNotifier` finds `someFunction` in the list and removes it (or marks it for removal if notifications are currently happening).\n\nWhen you call `notifyListeners()`, `ChangeNotifier` loops through its `_listeners` list and calls each function (listener) one by one:\n\n```dart\nvoid notifyListeners() {\n  // ... other code ...\n  final int end = _count;\n  for (int i = 0; i < end; i++) {\n    try {\n      _listeners[i]?.call(); // Calls the listener function\n    } catch (exception, stack) {\n      // Handles any errors that happen in a listener\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis loop is the core of how `ChangeNotifier` works \u2013 it simply goes through its list and calls every listener function.\n\nHere's a super simple sequence diagram to visualize the process when `notifyListeners()` is called:\n\n```mermaid\nsequenceDiagram\n    participant ObjectWithChangeNotifier\n    participant ChangeNotifierInstance\n    participant Listener1\n    participant Listener2\n\n    ObjectWithChangeNotifier->>ChangeNotifierInstance: notifyListeners()\n    ChangeNotifierInstance->>Listener1: Call listener function\n    ChangeNotifierInstance->>Listener2: Call listener function\n    Note over ChangeNotifierInstance: Done notifying listeners\n```\n\nThis diagram shows that when `notifyListeners()` is called on the `ChangeNotifier`, it then calls the functions registered by `Listener1` and `Listener2`.\n\n### Conclusion\n\nIn this chapter, we learned about `ChangeNotifier`, a fundamental building block in Flutter for creating objects that can announce changes to interested parts of your application. We saw how it manages a list of listeners and how you call `notifyListeners()` to trigger an update.\n\nWhile we touched on `addListener` and `removeListener`, we also noted that in a typical Flutter app, you'll use specialized widgets to handle the listening part. In the next chapter, we will dive deeper into the concept of a `Listenable`, which is the interface that `ChangeNotifier` implements and which other parts of Flutter interact with.\n\n[Next Chapter: Listenable](02_listenable_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/foundation/change_notifier.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 2: Listenable\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 2: Listenable\n\nIn the first chapter, we learned about [ChangeNotifier](01_changenotifier_.md), a powerful helper for letting other parts of your app know when something changes. `ChangeNotifier` is great because it manages who wants to listen and calls them when you say `notifyListeners()`.\n\nNow, let's talk about a more fundamental concept that `ChangeNotifier` builds upon: the `Listenable`.\n\n### What is a Listenable?\n\nImagine you have a broadcasting system. `ChangeNotifier` is like the specific radio station that plays music and tells everyone when a new song starts. The `Listenable` is like the *idea* of a broadcasting system itself. It's the fundamental capability to \"be listened to\".\n\nA `Listenable` is an object that simply has the ability to:\n\n1.  Allow someone to **start listening** for changes.\n2.  Allow someone to **stop listening** for changes.\n\nThat's it! It doesn't care *what* changed, or *how* it changed, or even hold any data itself. It's just the blueprint for an object that can be observed by others.\n\n### Why do we need Listenable?\n\nThink back to our counter example from Chapter 1. Our `MyCounter` class used `ChangeNotifier` to announce when the count changed.\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier { // MyCounter is a Listenable!\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners(); // Announces the change\n  }\n}\n```\n\nHere, `MyCounter` is not just a `ChangeNotifier`; it *is* also a `Listenable`. Because `ChangeNotifier` *implements* the `Listenable` interface, anything that works with a `ChangeNotifier` can also work with any other object that implements `Listenable`.\n\nThis is super useful because it allows different types of objects to participate in the same \"notification system.\" For example, Flutter has other objects that implement `Listenable`, like `Animation` objects which notify listeners when animation values change. Widgets in Flutter that need to react to changes (like `AnimatedBuilder` which we'll see later) can work with *any* `Listenable`, whether it's a `ChangeNotifier`, an `Animation`, or something else!\n\nIt makes our code more flexible and reusable.\n\n### How does Listenable work?\n\nThe `Listenable` itself is an abstract class (or an interface in some programming terms). This means you can't create a `Listenable` object directly (`new Listenable()` doesn't work). Instead, other classes *implement* or *extend* `Listenable` to gain its \"listenable\" abilities.\n\nThe `Listenable` interface defines the two core methods we mentioned:\n\n```dart\nabstract class Listenable {\n  // ... other factory methods ...\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\n*   `addListener`: This is how you tell the `Listenable` \"Hey, when you change, run this function for me!\". The `listener` is a `VoidCallback`, which is just a fancy name for a function that takes no arguments and returns nothing.\n*   `removeListener`: This is how you tell the `Listenable` \"Okay, I don't need to be notified anymore. Please stop calling my function.\"\n\nRemember how `ChangeNotifier` had `addListener` and `removeListener`? That's because `ChangeNotifier` implements the `Listenable` interface! It provides the *actual* code behind those methods to manage the list of listeners.\n\n### Adding and Removing Listeners (Manual Example)\n\nWhile you'll typically use Flutter widgets to handle adding and removing listeners on `Listenable`s, understanding how it works manually helps solidify the concept.\n\nLet's imagine our `MyCounter` object from Chapter 1 (which is a `Listenable` because it uses `ChangeNotifier`).\n\n```dart\n// Assume MyCounter class from Chapter 1 is defined\n\nvoid main() {\n  final counter = MyCounter(); // Our Listenable object\n\n  // Define a listener function\n  void counterChangedListener() {\n    print('Counter changed! New value: ${counter.count}');\n  }\n\n  // Add the listener\n  print('Adding listener...');\n  counter.addListener(counterChangedListener);\n\n  // Simulate a change (calling increment)\n  print('Incrementing counter...');\n  counter.increment(); // This will trigger notifyListeners(), which calls our listener!\n\n  // Simulate another change\n  print('Incrementing counter again...');\n  counter.increment(); // The listener is called again!\n\n  // Remove the listener\n  print('Removing listener...');\n  counter.removeListener(counterChangedListener);\n\n  // Simulate a change again\n  print('Incrementing counter one last time...');\n  counter.increment(); // The listener is NOT called this time\n\n  print('Done!');\n}\n```\n\nIf you run this code, you would see output like:\n\n```\nAdding listener...\nIncrementing counter...\nCounter changed! New value: 1\nIncrementing counter again...\nCounter changed! New value: 2\nRemoving listener...\nIncrementing counter one last time...\nDone!\n```\n\nSee how the `counterChangedListener` function is called when `increment()` is called (because `increment()` calls `notifyListeners()`), but only *after* we've added the listener and *before* we've removed it?\n\nThis manual process demonstrates the core \"listenable\" behavior promised by the `Listenable` interface: you can add and remove notification callbacks.\n\n### Listenable.merge\n\nThe `Listenable` interface also provides a handy factory constructor called `Listenable.merge`. This allows you to combine multiple `Listenable` objects into a single new `Listenable`. This new merged `Listenable` will notify its listeners whenever *any* of the original `Listenable`s notify *their* listeners.\n\n```dart\n// Imagine you have two Listenables (like two ChangeNotifiers)\nfinal listenableA = MyCounter(); // Let's reuse MyCounter\nfinal listenableB = MyCounter(); // Another counter\n\n// Merge them into one Listenable\nfinal mergedListenable = Listenable.merge([listenableA, listenableB]);\n\n// Now you can add a single listener to the merged listenable\nmergedListenable.addListener(() {\n  print('Either Listenable A or Listenable B changed!');\n});\n\n// If listenableA changes, the merged listener is called:\nlistenableA.increment();\n\n// If listenableB changes, the merged listener is also called:\nlistenableB.increment();\n\n// If both change (unlikely in simple examples, but possible),\n// the merged listener might be called multiple times depending on\n// how the underlying Listenables notify.\n```\n\nThis is useful when a widget needs to react to changes from several different sources.\n\n### Listenable Interface (Code Deep Drive)\n\nLooking at the actual Flutter code file for `change_notifier.dart`, you'll see the `Listenable` class defined:\n\n```dart\nabstract class Listenable {\n  // Abstract const constructor. This constructor enables subclasses to provide\n  // const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  // Return a [Listenable] that triggers when any of the given [Listenable]s\n  // themselves trigger.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\nAs we saw, it's an `abstract` class, meaning you can't create direct instances. It defines the `addListener` and `removeListener` methods that any class implementing `Listenable` *must* provide code for. The `factory Listenable.merge` is a special constructor that creates and returns a specific type of `Listenable` (`_MergingListenable`) when you call `Listenable.merge(...)`.\n\nThe `_MergingListenable` class (part of the same code) is a concrete implementation of `Listenable` that handles calling the `addListener` and `removeListener` on all the children it was given:\n\n```dart\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener); // Calls addListener on each child!\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener); // Calls removeListener on each child!\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis simple implementation shows that the `_MergingListenable` doesn't do much on its own; it just forwards the `addListener` and `removeListener` calls to the list of `Listenable`s it's wrapping. When any of those wrapped `Listenable`s notify their listeners, the listener you added to the `mergedListenable` will be among the functions called.\n\n### Analogy Recap\n\n*   **The Change:** The specific event that happens (e.g., the counter value goes from 1 to 2).\n*   **The Listenable:** The object that *can* be watched for changes. It has the capability to manage a list of people who care (`addListener`, `removeListener`). It's the blueprint.\n*   **The Listener (VoidCallback):** The function you provide that should be run when a change happens. It's the person who cares.\n*   **ChangeNotifier:** A specific implementation of `Listenable` that provides the actual mechanics of storing listeners and notifying them when *you* tell it to using `notifyListeners()`. It's the radio station using the broadcasting blueprint.\n*   **notifyListeners():** The action of telling the `Listenable` (or `ChangeNotifier`) to go through its list and call every listener function. It's the radio station announcing the new song.\n\n### Conclusion\n\nIn summary, the `Listenable` interface defines the core contract for objects that can be observed for changes. It's a simple but powerful concept that allows different types of objects to participate in shared notification mechanisms. `ChangeNotifier`, which we discussed in the previous chapter, is one prominent implementation of `Listenable`.\n\nUnderstanding `Listenable` helps us appreciate the flexibility in Flutter's architecture, where many widgets and systems are designed to work with any object that provides this basic listening capability.\n\nIn the next chapter, we'll look at another important concept: [ValueNotifier](03_valuenotifier_.md), which builds on `ChangeNotifier` and introduces the idea of a changing *value*.\n\n[Next Chapter: ValueNotifier](03_valuenotifier_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"ValueNotifier\n\". This is Chapter 3.\n\nConcept Details:\n- Name: ValueNotifier\n\n- Description:\nThis is a specific type of `ChangeNotifier` that's designed to hold and manage a _single_ value. It's like a simple counter or a status indicator that everyone is watching. When the value inside changes (and is different from the old value), it automatically uses the `ChangeNotifier`'s mechanism to tell all the listeners. It's a convenient way to make a single piece of data observable.\n\n\nComplete Tutorial Structure:\n1. [ChangeNotifier\n](01_changenotifier_.md)\n2. [Listenable\n](02_listenable_.md)\n3. [ValueNotifier\n](03_valuenotifier_.md)\n4. [ValueListenable\n](04_valuelistenable_.md)\n\nContext from previous chapters:\n# Chapter 1: ChangeNotifier\n\nWelcome to the Flutter foundation concepts! In this chapter, we're going to explore a really useful tool called `ChangeNotifier`. Imagine you have different parts of your app that need to know when something important happens in another part. How do you tell them? That's where `ChangeNotifier` comes in!\n\n### Why do we need `ChangeNotifier`?\n\nLet's say you have a simple app with a counter. You have a button that increases the count, and you want a text widget to show the current count. When you press the button and increase the count, how does the text widget know to update itself?\n\nYou could try passing the counter value around everywhere, but that gets messy quickly. What if multiple widgets need to know the count? What if the count changes in multiple places?\n\nWe need a way for the object holding the counter value to announce to anyone interested that its value has changed. This is where `ChangeNotifier` helps us.\n\n### What is `ChangeNotifier`?\n\nThink of `ChangeNotifier` as a little manager for a list of interested parties. The \"interested parties\" are called **listeners**. These listeners are basically pieces of code that want to know when something changes in the `ChangeNotifier`.\n\nWhen something *does* change in the object that uses a `ChangeNotifier`, we tell the `ChangeNotifier` to \"notify its listeners\". The `ChangeNotifier` then goes through its list of listeners and tells each one, \"Hey, something changed! You might want to update yourself.\"\n\nIt handles the tricky business of keeping track of who wants to listen and making sure they get the message.\n\n### How does it work?\n\nTo use `ChangeNotifier`, you typically create a class that holds the data you want to track (like our counter). Your class will either **extend** or **mix in** `ChangeNotifier`. Mixing in is like adding extra abilities to your class.\n\nHere's a simple example of a counter class that uses `ChangeNotifier`:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier {\n  int _count = 0; // Our private counter value\n\n  int get count => _count; // A cleaner way to get the count\n\n  void increment() {\n    _count++; // Increase the count\n    notifyListeners(); // Announce that the count has changed\n  }\n}\n```\n\nIn this code:\n\n1. We import `flutter/foundation.dart` which contains `ChangeNotifier`.\n2. We create a class `MyCounter` and add the `ChangeNotifier` capabilities to it using `with ChangeNotifier`.\n3. We have a private variable `_count` to hold our counter value. We use the `_` prefix to indicate it's internal to this class.\n4. We provide a `get` method to access `count` from outside the class.\n5. We have an `increment` method that increases the `_count`.\n6. The important part is `notifyListeners()`. When we call this method, `ChangeNotifier` tells all the listeners that the `count` has changed.\n\n### Becoming a Listener\n\nNow that we have an object that can announce changes (`MyCounter`), we need a way for other parts of the app (like our text widget) to *listen* for those announcements. We'll learn more about *how* other parts of the UI listen in later chapters when we talk about widgets that are designed to work with objects that can announce changes.\n\nFor now, let's just focus on the core idea of adding and removing listeners on the `ChangeNotifier` itself. The `ChangeNotifier` class has methods for this:\n\n```dart\nvoid addListener(VoidCallback listener);\nvoid removeListener(VoidCallback listener);\n```\n\n*   `addListener`: This method takes a function (a `VoidCallback`) as input. This function is the 'listener' code that will be run when `notifyListeners()` is called.\n*   `removeListener`: This method also takes a `VoidCallback`. It removes a listener that was previously added.\n\nYou can see these methods in the `ChangeNotifier` code snippet:\n\n```dart\n/// Register a closure to be called when the object notifies its listeners.\nvoid addListener(VoidCallback listener);\n\n/// Remove a previously registered closure from the list of closures that the\n/// object notifies.\nvoid removeListener(VoidCallback listener);\n```\n\nUsually, you won't call these methods directly yourself when building a Flutter app with widgets. Flutter provides special widgets that handle adding and removing listeners for you, making it much easier. But understanding that this is happening under the hood is important!\n\n### Inside `ChangeNotifier` (Simplified)\n\nHow does `ChangeNotifier` keep track of listeners and notify them? Looking at the code, we can see it manages a list of `VoidCallback?` (which are functions that take no arguments and return nothing and can also be null):\n\n```dart\nList<VoidCallback?> _listeners = _emptyListeners;\nint _count = 0;\n```\n\n*   `_listeners`: This is the internal list where `ChangeNotifier` stores all the functions (listeners) that have been added.\n*   `_count`: This keeps track of how many active listeners are currently in the list.\n\nWhen you call `addListener(someFunction)`, `ChangeNotifier` adds `someFunction` to this `_listeners` list and increases `_count`.\n\nWhen you call `removeListener(someFunction)`, `ChangeNotifier` finds `someFunction` in the list and removes it (or marks it for removal if notifications are currently happening).\n\nWhen you call `notifyListeners()`, `ChangeNotifier` loops through its `_listeners` list and calls each function (listener) one by one:\n\n```dart\nvoid notifyListeners() {\n  // ... other code ...\n  final int end = _count;\n  for (int i = 0; i < end; i++) {\n    try {\n      _listeners[i]?.call(); // Calls the listener function\n    } catch (exception, stack) {\n      // Handles any errors that happen in a listener\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis loop is the core of how `ChangeNotifier` works \u2013 it simply goes through its list and calls every listener function.\n\nHere's a super simple sequence diagram to visualize the process when `notifyListeners()` is called:\n\n```mermaid\nsequenceDiagram\n    participant ObjectWithChangeNotifier\n    participant ChangeNotifierInstance\n    participant Listener1\n    participant Listener2\n\n    ObjectWithChangeNotifier->>ChangeNotifierInstance: notifyListeners()\n    ChangeNotifierInstance->>Listener1: Call listener function\n    ChangeNotifierInstance->>Listener2: Call listener function\n    Note over ChangeNotifierInstance: Done notifying listeners\n```\n\nThis diagram shows that when `notifyListeners()` is called on the `ChangeNotifier`, it then calls the functions registered by `Listener1` and `Listener2`.\n\n### Conclusion\n\nIn this chapter, we learned about `ChangeNotifier`, a fundamental building block in Flutter for creating objects that can announce changes to interested parts of your application. We saw how it manages a list of listeners and how you call `notifyListeners()` to trigger an update.\n\nWhile we touched on `addListener` and `removeListener`, we also noted that in a typical Flutter app, you'll use specialized widgets to handle the listening part. In the next chapter, we will dive deeper into the concept of a `Listenable`, which is the interface that `ChangeNotifier` implements and which other parts of Flutter interact with.\n\n[Next Chapter: Listenable](02_listenable_.md)\n---\n# Chapter 2: Listenable\n\nIn the first chapter, we learned about [ChangeNotifier](01_changenotifier_.md), a powerful helper for letting other parts of your app know when something changes. `ChangeNotifier` is great because it manages who wants to listen and calls them when you say `notifyListeners()`.\n\nNow, let's talk about a more fundamental concept that `ChangeNotifier` builds upon: the `Listenable`.\n\n### What is a Listenable?\n\nImagine you have a broadcasting system. `ChangeNotifier` is like the specific radio station that plays music and tells everyone when a new song starts. The `Listenable` is like the *idea* of a broadcasting system itself. It's the fundamental capability to \"be listened to\".\n\nA `Listenable` is an object that simply has the ability to:\n\n1.  Allow someone to **start listening** for changes.\n2.  Allow someone to **stop listening** for changes.\n\nThat's it! It doesn't care *what* changed, or *how* it changed, or even hold any data itself. It's just the blueprint for an object that can be observed by others.\n\n### Why do we need Listenable?\n\nThink back to our counter example from Chapter 1. Our `MyCounter` class used `ChangeNotifier` to announce when the count changed.\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier { // MyCounter is a Listenable!\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners(); // Announces the change\n  }\n}\n```\n\nHere, `MyCounter` is not just a `ChangeNotifier`; it *is* also a `Listenable`. Because `ChangeNotifier` *implements* the `Listenable` interface, anything that works with a `ChangeNotifier` can also work with any other object that implements `Listenable`.\n\nThis is super useful because it allows different types of objects to participate in the same \"notification system.\" For example, Flutter has other objects that implement `Listenable`, like `Animation` objects which notify listeners when animation values change. Widgets in Flutter that need to react to changes (like `AnimatedBuilder` which we'll see later) can work with *any* `Listenable`, whether it's a `ChangeNotifier`, an `Animation`, or something else!\n\nIt makes our code more flexible and reusable.\n\n### How does Listenable work?\n\nThe `Listenable` itself is an abstract class (or an interface in some programming terms). This means you can't create a `Listenable` object directly (`new Listenable()` doesn't work). Instead, other classes *implement* or *extend* `Listenable` to gain its \"listenable\" abilities.\n\nThe `Listenable` interface defines the two core methods we mentioned:\n\n```dart\nabstract class Listenable {\n  // ... other factory methods ...\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\n*   `addListener`: This is how you tell the `Listenable` \"Hey, when you change, run this function for me!\". The `listener` is a `VoidCallback`, which is just a fancy name for a function that takes no arguments and returns nothing.\n*   `removeListener`: This is how you tell the `Listenable` \"Okay, I don't need to be notified anymore. Please stop calling my function.\"\n\nRemember how `ChangeNotifier` had `addListener` and `removeListener`? That's because `ChangeNotifier` implements the `Listenable` interface! It provides the *actual* code behind those methods to manage the list of listeners.\n\n### Adding and Removing Listeners (Manual Example)\n\nWhile you'll typically use Flutter widgets to handle adding and removing listeners on `Listenable`s, understanding how it works manually helps solidify the concept.\n\nLet's imagine our `MyCounter` object from Chapter 1 (which is a `Listenable` because it uses `ChangeNotifier`).\n\n```dart\n// Assume MyCounter class from Chapter 1 is defined\n\nvoid main() {\n  final counter = MyCounter(); // Our Listenable object\n\n  // Define a listener function\n  void counterChangedListener() {\n    print('Counter changed! New value: ${counter.count}');\n  }\n\n  // Add the listener\n  print('Adding listener...');\n  counter.addListener(counterChangedListener);\n\n  // Simulate a change (calling increment)\n  print('Incrementing counter...');\n  counter.increment(); // This will trigger notifyListeners(), which calls our listener!\n\n  // Simulate another change\n  print('Incrementing counter again...');\n  counter.increment(); // The listener is called again!\n\n  // Remove the listener\n  print('Removing listener...');\n  counter.removeListener(counterChangedListener);\n\n  // Simulate a change again\n  print('Incrementing counter one last time...');\n  counter.increment(); // The listener is NOT called this time\n\n  print('Done!');\n}\n```\n\nIf you run this code, you would see output like:\n\n```\nAdding listener...\nIncrementing counter...\nCounter changed! New value: 1\nIncrementing counter again...\nCounter changed! New value: 2\nRemoving listener...\nIncrementing counter one last time...\nDone!\n```\n\nSee how the `counterChangedListener` function is called when `increment()` is called (because `increment()` calls `notifyListeners()`), but only *after* we've added the listener and *before* we've removed it?\n\nThis manual process demonstrates the core \"listenable\" behavior promised by the `Listenable` interface: you can add and remove notification callbacks.\n\n### Listenable.merge\n\nThe `Listenable` interface also provides a handy factory constructor called `Listenable.merge`. This allows you to combine multiple `Listenable` objects into a single new `Listenable`. This new merged `Listenable` will notify its listeners whenever *any* of the original `Listenable`s notify *their* listeners.\n\n```dart\n// Imagine you have two Listenables (like two ChangeNotifiers)\nfinal listenableA = MyCounter(); // Let's reuse MyCounter\nfinal listenableB = MyCounter(); // Another counter\n\n// Merge them into one Listenable\nfinal mergedListenable = Listenable.merge([listenableA, listenableB]);\n\n// Now you can add a single listener to the merged listenable\nmergedListenable.addListener(() {\n  print('Either Listenable A or Listenable B changed!');\n});\n\n// If listenableA changes, the merged listener is called:\nlistenableA.increment();\n\n// If listenableB changes, the merged listener is also called:\nlistenableB.increment();\n\n// If both change (unlikely in simple examples, but possible),\n// the merged listener might be called multiple times depending on\n// how the underlying Listenables notify.\n```\n\nThis is useful when a widget needs to react to changes from several different sources.\n\n### Listenable Interface (Code Deep Drive)\n\nLooking at the actual Flutter code file for `change_notifier.dart`, you'll see the `Listenable` class defined:\n\n```dart\nabstract class Listenable {\n  // Abstract const constructor. This constructor enables subclasses to provide\n  // const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  // Return a [Listenable] that triggers when any of the given [Listenable]s\n  // themselves trigger.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\nAs we saw, it's an `abstract` class, meaning you can't create direct instances. It defines the `addListener` and `removeListener` methods that any class implementing `Listenable` *must* provide code for. The `factory Listenable.merge` is a special constructor that creates and returns a specific type of `Listenable` (`_MergingListenable`) when you call `Listenable.merge(...)`.\n\nThe `_MergingListenable` class (part of the same code) is a concrete implementation of `Listenable` that handles calling the `addListener` and `removeListener` on all the children it was given:\n\n```dart\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener); // Calls addListener on each child!\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener); // Calls removeListener on each child!\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis simple implementation shows that the `_MergingListenable` doesn't do much on its own; it just forwards the `addListener` and `removeListener` calls to the list of `Listenable`s it's wrapping. When any of those wrapped `Listenable`s notify their listeners, the listener you added to the `mergedListenable` will be among the functions called.\n\n### Analogy Recap\n\n*   **The Change:** The specific event that happens (e.g., the counter value goes from 1 to 2).\n*   **The Listenable:** The object that *can* be watched for changes. It has the capability to manage a list of people who care (`addListener`, `removeListener`). It's the blueprint.\n*   **The Listener (VoidCallback):** The function you provide that should be run when a change happens. It's the person who cares.\n*   **ChangeNotifier:** A specific implementation of `Listenable` that provides the actual mechanics of storing listeners and notifying them when *you* tell it to using `notifyListeners()`. It's the radio station using the broadcasting blueprint.\n*   **notifyListeners():** The action of telling the `Listenable` (or `ChangeNotifier`) to go through its list and call every listener function. It's the radio station announcing the new song.\n\n### Conclusion\n\nIn summary, the `Listenable` interface defines the core contract for objects that can be observed for changes. It's a simple but powerful concept that allows different types of objects to participate in shared notification mechanisms. `ChangeNotifier`, which we discussed in the previous chapter, is one prominent implementation of `Listenable`.\n\nUnderstanding `Listenable` helps us appreciate the flexibility in Flutter's architecture, where many widgets and systems are designed to work with any object that provides this basic listening capability.\n\nIn the next chapter, we'll look at another important concept: [ValueNotifier](03_valuenotifier_.md), which builds on `ChangeNotifier` and introduces the idea of a changing *value*.\n\n[Next Chapter: ValueNotifier](03_valuenotifier_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/foundation/change_notifier.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 3: ValueNotifier\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 3: ValueNotifier\n\nWelcome back! In our previous chapters, we learned about the fundamental building blocks for observation in Flutter: [ChangeNotifier](01_changenotifier_.md) (the manager that tells everyone something changed) and [Listenable](02_listenable_.md) (the general idea of an object that can be listened to).\n\nToday, we're going to look at a really convenient helper class that builds directly on [ChangeNotifier](01_changenotifier_.md) and [Listenable](02_listenable_.md): the `ValueNotifier`.\n\n### What is a ValueNotifier?\n\nImagine you have a single number you want to display in your app, like the temperature or a score. This number changes over time, and you want your display to update automatically whenever it changes.\n\nYou *could* create a custom class that uses [ChangeNotifier](01_changenotifier_.md) like we did in Chapter 1:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass TemperatureDisplay with ChangeNotifier {\n  double _degrees = 20.0; // Our temperature\n\n  double get degrees => _degrees;\n\n  void setTemperature(double newTemp) {\n    if (_degrees != newTemp) { // Only update if it's actually different\n      _degrees = newTemp;\n      notifyListeners(); // Tell everyone it changed!\n    }\n  }\n}\n```\n\nThis works perfectly fine! But what if you *only* care about managing this *single* value and notifying listeners when *that specific value* changes? Writing this little extra code just to hold and manage one value can feel a bit repetitive.\n\nThis is where `ValueNotifier` comes in handy!\n\nA `ValueNotifier` is specifically designed to wrap and manage a *single* piece of data. It combines the ability to hold a value *with* the ability to notify listeners when that value changes. It does all the heavy lifting of the `setTemperature` logic for you.\n\nThink of it like a little box that holds one item. When you replace the item inside the box with a *different* item, the box automatically sends out a signal to everyone who is watching it.\n\n### Why use ValueNotifier?\n\n`ValueNotifier` simplifies common tasks where you need to make a single variable or property observable.\n\n1.  **Simplicity:** It's less code than creating a custom [ChangeNotifier](01_changenotifier_.md) just to manage one value.\n2.  **Focus:** It clearly indicates that the primary thing being observed is a specific value.\n3.  **Convenience:** It provides a direct way to access the current value using its `value` property.\n\nIt's ideal for simple state like:\n*   A loading status (true/false)\n*   The currently selected item in a list\n*   A simple counter (like our Chapter 1 example!)\n*   A text field's current input\n\n### How to use ValueNotifier\n\nUsing `ValueNotifier` is straightforward. You create an instance of it, giving it an initial value. You can then access and change the value directly using the `.value` property.\n\nHere's how we could use a `ValueNotifier` for our temperature example:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\n// Create a ValueNotifier holding a double value, starting at 20.0\nfinal ValueNotifier<double> temperatureNotifier = ValueNotifier<double>(20.0);\n\nvoid updateTemperature(double newTemp) {\n  // Change the value directly using the .value property\n  // ValueNotifier automatically checks if it's different and, if so,\n  // calls notifyListeners() internally.\n  temperatureNotifier.value = newTemp;\n}\n\nvoid main() {\n  // Add a listener manually (usually done by widgets in Flutter)\n  temperatureNotifier.addListener(() {\n    print('Temperature changed to: ${temperatureNotifier.value} degrees');\n  });\n\n  print('Initial temperature: ${temperatureNotifier.value}'); // Output: 20.0\n\n  // Update the temperature\n  print('Setting temperature to 25.0...');\n  updateTemperature(25.0); // This will call the listener\n\n  // Update with the same value (listener is NOT called)\n  print('Setting temperature to 25.0 again...');\n  updateTemperature(25.0); // No output from listener this time\n\n  // Update to a different value\n  print('Setting temperature to 18.5...');\n  updateTemperature(18.5); // This will call the listener\n\n  // Don't forget to dispose of notifiers when done (important in real apps!)\n  // temperatureNotifier.dispose(); // Covered in later chapters\n}\n```\n\nIf you run this code, the output would look like this:\n\n```\nInitial temperature: 20.0\nSetting temperature to 25.0...\nTemperature changed to: 25.0 degrees\nSetting temperature to 25.0 again...\nSetting temperature to 18.5...\nTemperature changed to: 18.5 degrees\n```\n\nNotice that the listener function (`print('Temperature changed...')`) is only called when we set the value to `25.0` (because it was `20.0`) and when we set it to `18.5` (because it was `25.0`). Setting it to `25.0` again when it was already `25.0` does *not* trigger a notification. This is a key feature of `ValueNotifier` \u2013 it only notifies if the *value has actually changed* (based on the `==` operator).\n\nTo make a `ValueNotifier`, you simply call its constructor with the initial value:\n\n```dart\nValueNotifier<int> score = ValueNotifier<int>(0);\n```\n\nTo get the value:\n\n```dart\nint currentScore = score.value;\n```\n\nTo change the value and potentially trigger notifications:\n\n```dart\nscore.value = 100; // If score was not 100, listeners are notified\n```\n\n### Inside ValueNotifier\n\nHow does `ValueNotifier` achieve this? It extends [ChangeNotifier](01_changenotifier_.md)!\n\nThis means a `ValueNotifier` *is* a [ChangeNotifier](01_changenotifier_.md), so it automatically inherits the ability to manage listeners (`addListener`, `removeListener`, `notifyListeners`).\n\nHere's a simplified look at its core structure (from the `change_notifier.dart` file you saw previously):\n\n```dart\n/// A [ChangeNotifier] that holds a single value.\n/// ... explanation ...\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) { /* ... startup code ... */ }\n\n  /// The current value stored in this notifier.\n  /// ... explanation ...\n  @override\n  T get value => _value;\n  T _value; // Holds the single value\n\n  set value(T newValue) {\n    // This is automatically called when you do `myNotifier.value = someValue;`\n    if (_value == newValue) {\n      return; // If the new value is the same, do nothing\n    }\n    _value = newValue; // Update the internal value\n    notifyListeners(); // Inherited from ChangeNotifier, tells everyone!\n  }\n\n  // ... other methods ...\n}\n```\n\nIn this code:\n\n1.  It `extends ChangeNotifier` and `implements ValueListenable<T>` (we'll cover `ValueListenable` in the next chapter!).\n2.  It has an internal variable `_value` of type `T` to hold the data.\n3.  The `value` property has both a `get` (to read the value) and a `set` (to change the value).\n4.  The crucial part is the `set value`. When you assign a new value to `value`, this `set` method is executed.\n5.  Inside the `set` method, it first checks `if (_value == newValue)`. This prevents unnecessary notifications if you set the value to what it already is.\n6.  If the values are different, it updates `_value` to `newValue`.\n7.  Finally, it calls `notifyListeners()`, which is the method inherited from [ChangeNotifier](01_changenotifier_.md), triggering all registered listeners just like we saw in Chapter 1.\n\nHere's a quick sequence diagram showing what happens when you set the `value` property:\n\n```mermaid\nsequenceDiagram\n    participant YourCode /* In a Widget or function */\n    participant ValueNotifierInstance\n    participant ChangeNotifierLogic /* Inherited from ChangeNotifier */\n    participant Listener1\n    participant Listener2\n\n    YourCode->>ValueNotifierInstance: set value = newValue\n    ValueNotifierInstance->>ValueNotifierInstance: Check if _value == newValue\n    alt Value is different\n        ValueNotifierInstance->>ValueNotifierInstance: Update _value = newValue\n        ValueNotifierInstance->>ChangeNotifierLogic: notifyListeners()\n        ChangeNotifierLogic->>Listener1: Call listener function\n        ChangeNotifierLogic->>Listener2: Call listener function\n    else Value is the same\n        ValueNotifierInstance->>YourCode: Return (do nothing)\n    end\n```\n\nThis diagram illustrates how your code setting the value first triggers the `ValueNotifier`'s internal check, and if the value is different, it uses the inherited [ChangeNotifier](01_changenotifier_.md) logic to notify listeners.\n\n### Analogy Recap\n\n*   `ValueNotifier`: The specialized box that holds *one* item. It checks if you replace the item with something *different* before telling anyone.\n*   `value`: The item currently inside the box.\n*   `set value = ...`: Replacing the item in the box.\n*   Inherited [ChangeNotifier](01_changenotifier_.md): The underlying mechanism the box uses to manage its list of watchers and send out signals.\n*   `notifyListeners()` (called internally by `set value`): The act of the box sending a signal (\"Hey, my item changed!\") to everyone watching.\n*   Listeners: The people watching the box, waiting for a signal.\n\n### Conclusion\n\n`ValueNotifier` is a powerful and convenient class in Flutter for managing and observing changes to a single value. It saves you from writing boilerplate code by extending [ChangeNotifier](01_changenotifier_.md) and providing a simple `value` property that automatically handles updating the internal state and notifying listeners when the value changes.\n\nIt's a specific type of [ChangeNotifier](01_changenotifier_.md) focused on a single value and is often used for simple, localized state.\n\nIn the next chapter, we'll explore [ValueListenable](04_valuelistenable_.md), the interface that `ValueNotifier` implements, which is the *blueprint* for any object that exposes a `value` that can be listened to for changes.\n\n[Next Chapter: ValueListenable](04_valuelistenable_.md)", "\nWrite a very beginner-friendly tutorial chapter (in Markdown format) for the project `flutter` about the concept: \"ValueListenable\n\". This is Chapter 4.\n\nConcept Details:\n- Name: ValueListenable\n\n- Description:\nBuilding on the `Listenable` concept, a `ValueListenable` is like a special sign-up sheet for things that have a specific value that can change. Not only can you subscribe to be notified when it changes, but you can also immediately ask for its current value. Think of it as a box with a window: you can see what's inside (the value) and get a ping when the thing inside is replaced with something else.\n\n\nComplete Tutorial Structure:\n1. [ChangeNotifier\n](01_changenotifier_.md)\n2. [Listenable\n](02_listenable_.md)\n3. [ValueNotifier\n](03_valuenotifier_.md)\n4. [ValueListenable\n](04_valuelistenable_.md)\n\nContext from previous chapters:\n# Chapter 1: ChangeNotifier\n\nWelcome to the Flutter foundation concepts! In this chapter, we're going to explore a really useful tool called `ChangeNotifier`. Imagine you have different parts of your app that need to know when something important happens in another part. How do you tell them? That's where `ChangeNotifier` comes in!\n\n### Why do we need `ChangeNotifier`?\n\nLet's say you have a simple app with a counter. You have a button that increases the count, and you want a text widget to show the current count. When you press the button and increase the count, how does the text widget know to update itself?\n\nYou could try passing the counter value around everywhere, but that gets messy quickly. What if multiple widgets need to know the count? What if the count changes in multiple places?\n\nWe need a way for the object holding the counter value to announce to anyone interested that its value has changed. This is where `ChangeNotifier` helps us.\n\n### What is `ChangeNotifier`?\n\nThink of `ChangeNotifier` as a little manager for a list of interested parties. The \"interested parties\" are called **listeners**. These listeners are basically pieces of code that want to know when something changes in the `ChangeNotifier`.\n\nWhen something *does* change in the object that uses a `ChangeNotifier`, we tell the `ChangeNotifier` to \"notify its listeners\". The `ChangeNotifier` then goes through its list of listeners and tells each one, \"Hey, something changed! You might want to update yourself.\"\n\nIt handles the tricky business of keeping track of who wants to listen and making sure they get the message.\n\n### How does it work?\n\nTo use `ChangeNotifier`, you typically create a class that holds the data you want to track (like our counter). Your class will either **extend** or **mix in** `ChangeNotifier`. Mixing in is like adding extra abilities to your class.\n\nHere's a simple example of a counter class that uses `ChangeNotifier`:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier {\n  int _count = 0; // Our private counter value\n\n  int get count => _count; // A cleaner way to get the count\n\n  void increment() {\n    _count++; // Increase the count\n    notifyListeners(); // Announce that the count has changed\n  }\n}\n```\n\nIn this code:\n\n1. We import `flutter/foundation.dart` which contains `ChangeNotifier`.\n2. We create a class `MyCounter` and add the `ChangeNotifier` capabilities to it using `with ChangeNotifier`.\n3. We have a private variable `_count` to hold our counter value. We use the `_` prefix to indicate it's internal to this class.\n4. We provide a `get` method to access `count` from outside the class.\n5. We have an `increment` method that increases the `_count`.\n6. The important part is `notifyListeners()`. When we call this method, `ChangeNotifier` tells all the listeners that the `count` has changed.\n\n### Becoming a Listener\n\nNow that we have an object that can announce changes (`MyCounter`), we need a way for other parts of the app (like our text widget) to *listen* for those announcements. We'll learn more about *how* other parts of the UI listen in later chapters when we talk about widgets that are designed to work with objects that can announce changes.\n\nFor now, let's just focus on the core idea of adding and removing listeners on the `ChangeNotifier` itself. The `ChangeNotifier` class has methods for this:\n\n```dart\nvoid addListener(VoidCallback listener);\nvoid removeListener(VoidCallback listener);\n```\n\n*   `addListener`: This method takes a function (a `VoidCallback`) as input. This function is the 'listener' code that will be run when `notifyListeners()` is called.\n*   `removeListener`: This method also takes a `VoidCallback`. It removes a listener that was previously added.\n\nYou can see these methods in the `ChangeNotifier` code snippet:\n\n```dart\n/// Register a closure to be called when the object notifies its listeners.\nvoid addListener(VoidCallback listener);\n\n/// Remove a previously registered closure from the list of closures that the\n/// object notifies.\nvoid removeListener(VoidCallback listener);\n```\n\nUsually, you won't call these methods directly yourself when building a Flutter app with widgets. Flutter provides special widgets that handle adding and removing listeners for you, making it much easier. But understanding that this is happening under the hood is important!\n\n### Inside `ChangeNotifier` (Simplified)\n\nHow does `ChangeNotifier` keep track of listeners and notify them? Looking at the code, we can see it manages a list of `VoidCallback?` (which are functions that take no arguments and return nothing and can also be null):\n\n```dart\nList<VoidCallback?> _listeners = _emptyListeners;\nint _count = 0;\n```\n\n*   `_listeners`: This is the internal list where `ChangeNotifier` stores all the functions (listeners) that have been added.\n*   `_count`: This keeps track of how many active listeners are currently in the list.\n\nWhen you call `addListener(someFunction)`, `ChangeNotifier` adds `someFunction` to this `_listeners` list and increases `_count`.\n\nWhen you call `removeListener(someFunction)`, `ChangeNotifier` finds `someFunction` in the list and removes it (or marks it for removal if notifications are currently happening).\n\nWhen you call `notifyListeners()`, `ChangeNotifier` loops through its `_listeners` list and calls each function (listener) one by one:\n\n```dart\nvoid notifyListeners() {\n  // ... other code ...\n  final int end = _count;\n  for (int i = 0; i < end; i++) {\n    try {\n      _listeners[i]?.call(); // Calls the listener function\n    } catch (exception, stack) {\n      // Handles any errors that happen in a listener\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis loop is the core of how `ChangeNotifier` works \u2013 it simply goes through its list and calls every listener function.\n\nHere's a super simple sequence diagram to visualize the process when `notifyListeners()` is called:\n\n```mermaid\nsequenceDiagram\n    participant ObjectWithChangeNotifier\n    participant ChangeNotifierInstance\n    participant Listener1\n    participant Listener2\n\n    ObjectWithChangeNotifier->>ChangeNotifierInstance: notifyListeners()\n    ChangeNotifierInstance->>Listener1: Call listener function\n    ChangeNotifierInstance->>Listener2: Call listener function\n    Note over ChangeNotifierInstance: Done notifying listeners\n```\n\nThis diagram shows that when `notifyListeners()` is called on the `ChangeNotifier`, it then calls the functions registered by `Listener1` and `Listener2`.\n\n### Conclusion\n\nIn this chapter, we learned about `ChangeNotifier`, a fundamental building block in Flutter for creating objects that can announce changes to interested parts of your application. We saw how it manages a list of listeners and how you call `notifyListeners()` to trigger an update.\n\nWhile we touched on `addListener` and `removeListener`, we also noted that in a typical Flutter app, you'll use specialized widgets to handle the listening part. In the next chapter, we will dive deeper into the concept of a `Listenable`, which is the interface that `ChangeNotifier` implements and which other parts of Flutter interact with.\n\n[Next Chapter: Listenable](02_listenable_.md)\n---\n# Chapter 2: Listenable\n\nIn the first chapter, we learned about [ChangeNotifier](01_changenotifier_.md), a powerful helper for letting other parts of your app know when something changes. `ChangeNotifier` is great because it manages who wants to listen and calls them when you say `notifyListeners()`.\n\nNow, let's talk about a more fundamental concept that `ChangeNotifier` builds upon: the `Listenable`.\n\n### What is a Listenable?\n\nImagine you have a broadcasting system. `ChangeNotifier` is like the specific radio station that plays music and tells everyone when a new song starts. The `Listenable` is like the *idea* of a broadcasting system itself. It's the fundamental capability to \"be listened to\".\n\nA `Listenable` is an object that simply has the ability to:\n\n1.  Allow someone to **start listening** for changes.\n2.  Allow someone to **stop listening** for changes.\n\nThat's it! It doesn't care *what* changed, or *how* it changed, or even hold any data itself. It's just the blueprint for an object that can be observed by others.\n\n### Why do we need Listenable?\n\nThink back to our counter example from Chapter 1. Our `MyCounter` class used `ChangeNotifier` to announce when the count changed.\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass MyCounter with ChangeNotifier { // MyCounter is a Listenable!\n  int _count = 0;\n\n  int get count => _count;\n\n  void increment() {\n    _count++;\n    notifyListeners(); // Announces the change\n  }\n}\n```\n\nHere, `MyCounter` is not just a `ChangeNotifier`; it *is* also a `Listenable`. Because `ChangeNotifier` *implements* the `Listenable` interface, anything that works with a `ChangeNotifier` can also work with any other object that implements `Listenable`.\n\nThis is super useful because it allows different types of objects to participate in the same \"notification system.\" For example, Flutter has other objects that implement `Listenable`, like `Animation` objects which notify listeners when animation values change. Widgets in Flutter that need to react to changes (like `AnimatedBuilder` which we'll see later) can work with *any* `Listenable`, whether it's a `ChangeNotifier`, an `Animation`, or something else!\n\nIt makes our code more flexible and reusable.\n\n### How does Listenable work?\n\nThe `Listenable` itself is an abstract class (or an interface in some programming terms). This means you can't create a `Listenable` object directly (`new Listenable()` doesn't work). Instead, other classes *implement* or *extend* `Listenable` to gain its \"listenable\" abilities.\n\nThe `Listenable` interface defines the two core methods we mentioned:\n\n```dart\nabstract class Listenable {\n  // ... other factory methods ...\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\n*   `addListener`: This is how you tell the `Listenable` \"Hey, when you change, run this function for me!\". The `listener` is a `VoidCallback`, which is just a fancy name for a function that takes no arguments and returns nothing.\n*   `removeListener`: This is how you tell the `Listenable` \"Okay, I don't need to be notified anymore. Please stop calling my function.\"\n\nRemember how `ChangeNotifier` had `addListener` and `removeListener`? That's because `ChangeNotifier` implements the `Listenable` interface! It provides the *actual* code behind those methods to manage the list of listeners.\n\n### Adding and Removing Listeners (Manual Example)\n\nWhile you'll typically use Flutter widgets to handle adding and removing listeners on `Listenable`s, understanding how it works manually helps solidify the concept.\n\nLet's imagine our `MyCounter` object from Chapter 1 (which is a `Listenable` because it uses `ChangeNotifier`).\n\n```dart\n// Assume MyCounter class from Chapter 1 is defined\n\nvoid main() {\n  final counter = MyCounter(); // Our Listenable object\n\n  // Define a listener function\n  void counterChangedListener() {\n    print('Counter changed! New value: ${counter.count}');\n  }\n\n  // Add the listener\n  print('Adding listener...');\n  counter.addListener(counterChangedListener);\n\n  // Simulate a change (calling increment)\n  print('Incrementing counter...');\n  counter.increment(); // This will trigger notifyListeners(), which calls our listener!\n\n  // Simulate another change\n  print('Incrementing counter again...');\n  counter.increment(); // The listener is called again!\n\n  // Remove the listener\n  print('Removing listener...');\n  counter.removeListener(counterChangedListener);\n\n  // Simulate a change again\n  print('Incrementing counter one last time...');\n  counter.increment(); // The listener is NOT called this time\n\n  print('Done!');\n}\n```\n\nIf you run this code, you would see output like:\n\n```\nAdding listener...\nIncrementing counter...\nCounter changed! New value: 1\nIncrementing counter again...\nCounter changed! New value: 2\nRemoving listener...\nIncrementing counter one last time...\nDone!\n```\n\nSee how the `counterChangedListener` function is called when `increment()` is called (because `increment()` calls `notifyListeners()`), but only *after* we've added the listener and *before* we've removed it?\n\nThis manual process demonstrates the core \"listenable\" behavior promised by the `Listenable` interface: you can add and remove notification callbacks.\n\n### Listenable.merge\n\nThe `Listenable` interface also provides a handy factory constructor called `Listenable.merge`. This allows you to combine multiple `Listenable` objects into a single new `Listenable`. This new merged `Listenable` will notify its listeners whenever *any* of the original `Listenable`s notify *their* listeners.\n\n```dart\n// Imagine you have two Listenables (like two ChangeNotifiers)\nfinal listenableA = MyCounter(); // Let's reuse MyCounter\nfinal listenableB = MyCounter(); // Another counter\n\n// Merge them into one Listenable\nfinal mergedListenable = Listenable.merge([listenableA, listenableB]);\n\n// Now you can add a single listener to the merged listenable\nmergedListenable.addListener(() {\n  print('Either Listenable A or Listenable B changed!');\n});\n\n// If listenableA changes, the merged listener is called:\nlistenableA.increment();\n\n// If listenableB changes, the merged listener is also called:\nlistenableB.increment();\n\n// If both change (unlikely in simple examples, but possible),\n// the merged listener might be called multiple times depending on\n// how the underlying Listenables notify.\n```\n\nThis is useful when a widget needs to react to changes from several different sources.\n\n### Listenable Interface (Code Deep Drive)\n\nLooking at the actual Flutter code file for `change_notifier.dart`, you'll see the `Listenable` class defined:\n\n```dart\nabstract class Listenable {\n  // Abstract const constructor. This constructor enables subclasses to provide\n  // const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  // Return a [Listenable] that triggers when any of the given [Listenable]s\n  // themselves trigger.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n```\n\nAs we saw, it's an `abstract` class, meaning you can't create direct instances. It defines the `addListener` and `removeListener` methods that any class implementing `Listenable` *must* provide code for. The `factory Listenable.merge` is a special constructor that creates and returns a specific type of `Listenable` (`_MergingListenable`) when you call `Listenable.merge(...)`.\n\nThe `_MergingListenable` class (part of the same code) is a concrete implementation of `Listenable` that handles calling the `addListener` and `removeListener` on all the children it was given:\n\n```dart\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener); // Calls addListener on each child!\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener); // Calls removeListener on each child!\n    }\n  }\n  // ... other code ...\n}\n```\n\nThis simple implementation shows that the `_MergingListenable` doesn't do much on its own; it just forwards the `addListener` and `removeListener` calls to the list of `Listenable`s it's wrapping. When any of those wrapped `Listenable`s notify their listeners, the listener you added to the `mergedListenable` will be among the functions called.\n\n### Analogy Recap\n\n*   **The Change:** The specific event that happens (e.g., the counter value goes from 1 to 2).\n*   **The Listenable:** The object that *can* be watched for changes. It has the capability to manage a list of people who care (`addListener`, `removeListener`). It's the blueprint.\n*   **The Listener (VoidCallback):** The function you provide that should be run when a change happens. It's the person who cares.\n*   **ChangeNotifier:** A specific implementation of `Listenable` that provides the actual mechanics of storing listeners and notifying them when *you* tell it to using `notifyListeners()`. It's the radio station using the broadcasting blueprint.\n*   **notifyListeners():** The action of telling the `Listenable` (or `ChangeNotifier`) to go through its list and call every listener function. It's the radio station announcing the new song.\n\n### Conclusion\n\nIn summary, the `Listenable` interface defines the core contract for objects that can be observed for changes. It's a simple but powerful concept that allows different types of objects to participate in shared notification mechanisms. `ChangeNotifier`, which we discussed in the previous chapter, is one prominent implementation of `Listenable`.\n\nUnderstanding `Listenable` helps us appreciate the flexibility in Flutter's architecture, where many widgets and systems are designed to work with any object that provides this basic listening capability.\n\nIn the next chapter, we'll look at another important concept: [ValueNotifier](03_valuenotifier_.md), which builds on `ChangeNotifier` and introduces the idea of a changing *value*.\n\n[Next Chapter: ValueNotifier](03_valuenotifier_.md)\n---\n# Chapter 3: ValueNotifier\n\nWelcome back! In our previous chapters, we learned about the fundamental building blocks for observation in Flutter: [ChangeNotifier](01_changenotifier_.md) (the manager that tells everyone something changed) and [Listenable](02_listenable_.md) (the general idea of an object that can be listened to).\n\nToday, we're going to look at a really convenient helper class that builds directly on [ChangeNotifier](01_changenotifier_.md) and [Listenable](02_listenable_.md): the `ValueNotifier`.\n\n### What is a ValueNotifier?\n\nImagine you have a single number you want to display in your app, like the temperature or a score. This number changes over time, and you want your display to update automatically whenever it changes.\n\nYou *could* create a custom class that uses [ChangeNotifier](01_changenotifier_.md) like we did in Chapter 1:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\nclass TemperatureDisplay with ChangeNotifier {\n  double _degrees = 20.0; // Our temperature\n\n  double get degrees => _degrees;\n\n  void setTemperature(double newTemp) {\n    if (_degrees != newTemp) { // Only update if it's actually different\n      _degrees = newTemp;\n      notifyListeners(); // Tell everyone it changed!\n    }\n  }\n}\n```\n\nThis works perfectly fine! But what if you *only* care about managing this *single* value and notifying listeners when *that specific value* changes? Writing this little extra code just to hold and manage one value can feel a bit repetitive.\n\nThis is where `ValueNotifier` comes in handy!\n\nA `ValueNotifier` is specifically designed to wrap and manage a *single* piece of data. It combines the ability to hold a value *with* the ability to notify listeners when that value changes. It does all the heavy lifting of the `setTemperature` logic for you.\n\nThink of it like a little box that holds one item. When you replace the item inside the box with a *different* item, the box automatically sends out a signal to everyone who is watching it.\n\n### Why use ValueNotifier?\n\n`ValueNotifier` simplifies common tasks where you need to make a single variable or property observable.\n\n1.  **Simplicity:** It's less code than creating a custom [ChangeNotifier](01_changenotifier_.md) just to manage one value.\n2.  **Focus:** It clearly indicates that the primary thing being observed is a specific value.\n3.  **Convenience:** It provides a direct way to access the current value using its `value` property.\n\nIt's ideal for simple state like:\n*   A loading status (true/false)\n*   The currently selected item in a list\n*   A simple counter (like our Chapter 1 example!)\n*   A text field's current input\n\n### How to use ValueNotifier\n\nUsing `ValueNotifier` is straightforward. You create an instance of it, giving it an initial value. You can then access and change the value directly using the `.value` property.\n\nHere's how we could use a `ValueNotifier` for our temperature example:\n\n```dart\nimport 'package:flutter/foundation.dart';\n\n// Create a ValueNotifier holding a double value, starting at 20.0\nfinal ValueNotifier<double> temperatureNotifier = ValueNotifier<double>(20.0);\n\nvoid updateTemperature(double newTemp) {\n  // Change the value directly using the .value property\n  // ValueNotifier automatically checks if it's different and, if so,\n  // calls notifyListeners() internally.\n  temperatureNotifier.value = newTemp;\n}\n\nvoid main() {\n  // Add a listener manually (usually done by widgets in Flutter)\n  temperatureNotifier.addListener(() {\n    print('Temperature changed to: ${temperatureNotifier.value} degrees');\n  });\n\n  print('Initial temperature: ${temperatureNotifier.value}'); // Output: 20.0\n\n  // Update the temperature\n  print('Setting temperature to 25.0...');\n  updateTemperature(25.0); // This will call the listener\n\n  // Update with the same value (listener is NOT called)\n  print('Setting temperature to 25.0 again...');\n  updateTemperature(25.0); // No output from listener this time\n\n  // Update to a different value\n  print('Setting temperature to 18.5...');\n  updateTemperature(18.5); // This will call the listener\n\n  // Don't forget to dispose of notifiers when done (important in real apps!)\n  // temperatureNotifier.dispose(); // Covered in later chapters\n}\n```\n\nIf you run this code, the output would look like this:\n\n```\nInitial temperature: 20.0\nSetting temperature to 25.0...\nTemperature changed to: 25.0 degrees\nSetting temperature to 25.0 again...\nSetting temperature to 18.5...\nTemperature changed to: 18.5 degrees\n```\n\nNotice that the listener function (`print('Temperature changed...')`) is only called when we set the value to `25.0` (because it was `20.0`) and when we set it to `18.5` (because it was `25.0`). Setting it to `25.0` again when it was already `25.0` does *not* trigger a notification. This is a key feature of `ValueNotifier` \u2013 it only notifies if the *value has actually changed* (based on the `==` operator).\n\nTo make a `ValueNotifier`, you simply call its constructor with the initial value:\n\n```dart\nValueNotifier<int> score = ValueNotifier<int>(0);\n```\n\nTo get the value:\n\n```dart\nint currentScore = score.value;\n```\n\nTo change the value and potentially trigger notifications:\n\n```dart\nscore.value = 100; // If score was not 100, listeners are notified\n```\n\n### Inside ValueNotifier\n\nHow does `ValueNotifier` achieve this? It extends [ChangeNotifier](01_changenotifier_.md)!\n\nThis means a `ValueNotifier` *is* a [ChangeNotifier](01_changenotifier_.md), so it automatically inherits the ability to manage listeners (`addListener`, `removeListener`, `notifyListeners`).\n\nHere's a simplified look at its core structure (from the `change_notifier.dart` file you saw previously):\n\n```dart\n/// A [ChangeNotifier] that holds a single value.\n/// ... explanation ...\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) { /* ... startup code ... */ }\n\n  /// The current value stored in this notifier.\n  /// ... explanation ...\n  @override\n  T get value => _value;\n  T _value; // Holds the single value\n\n  set value(T newValue) {\n    // This is automatically called when you do `myNotifier.value = someValue;`\n    if (_value == newValue) {\n      return; // If the new value is the same, do nothing\n    }\n    _value = newValue; // Update the internal value\n    notifyListeners(); // Inherited from ChangeNotifier, tells everyone!\n  }\n\n  // ... other methods ...\n}\n```\n\nIn this code:\n\n1.  It `extends ChangeNotifier` and `implements ValueListenable<T>` (we'll cover `ValueListenable` in the next chapter!).\n2.  It has an internal variable `_value` of type `T` to hold the data.\n3.  The `value` property has both a `get` (to read the value) and a `set` (to change the value).\n4.  The crucial part is the `set value`. When you assign a new value to `value`, this `set` method is executed.\n5.  Inside the `set` method, it first checks `if (_value == newValue)`. This prevents unnecessary notifications if you set the value to what it already is.\n6.  If the values are different, it updates `_value` to `newValue`.\n7.  Finally, it calls `notifyListeners()`, which is the method inherited from [ChangeNotifier](01_changenotifier_.md), triggering all registered listeners just like we saw in Chapter 1.\n\nHere's a quick sequence diagram showing what happens when you set the `value` property:\n\n```mermaid\nsequenceDiagram\n    participant YourCode /* In a Widget or function */\n    participant ValueNotifierInstance\n    participant ChangeNotifierLogic /* Inherited from ChangeNotifier */\n    participant Listener1\n    participant Listener2\n\n    YourCode->>ValueNotifierInstance: set value = newValue\n    ValueNotifierInstance->>ValueNotifierInstance: Check if _value == newValue\n    alt Value is different\n        ValueNotifierInstance->>ValueNotifierInstance: Update _value = newValue\n        ValueNotifierInstance->>ChangeNotifierLogic: notifyListeners()\n        ChangeNotifierLogic->>Listener1: Call listener function\n        ChangeNotifierLogic->>Listener2: Call listener function\n    else Value is the same\n        ValueNotifierInstance->>YourCode: Return (do nothing)\n    end\n```\n\nThis diagram illustrates how your code setting the value first triggers the `ValueNotifier`'s internal check, and if the value is different, it uses the inherited [ChangeNotifier](01_changenotifier_.md) logic to notify listeners.\n\n### Analogy Recap\n\n*   `ValueNotifier`: The specialized box that holds *one* item. It checks if you replace the item with something *different* before telling anyone.\n*   `value`: The item currently inside the box.\n*   `set value = ...`: Replacing the item in the box.\n*   Inherited [ChangeNotifier](01_changenotifier_.md): The underlying mechanism the box uses to manage its list of watchers and send out signals.\n*   `notifyListeners()` (called internally by `set value`): The act of the box sending a signal (\"Hey, my item changed!\") to everyone watching.\n*   Listeners: The people watching the box, waiting for a signal.\n\n### Conclusion\n\n`ValueNotifier` is a powerful and convenient class in Flutter for managing and observing changes to a single value. It saves you from writing boilerplate code by extending [ChangeNotifier](01_changenotifier_.md) and providing a simple `value` property that automatically handles updating the internal state and notifying listeners when the value changes.\n\nIt's a specific type of [ChangeNotifier](01_changenotifier_.md) focused on a single value and is often used for simple, localized state.\n\nIn the next chapter, we'll explore [ValueListenable](04_valuelistenable_.md), the interface that `ValueNotifier` implements, which is the *blueprint* for any object that exposes a `value` that can be listened to for changes.\n\n[Next Chapter: ValueListenable](04_valuelistenable_.md)\n\nRelevant Code Snippets (Code itself remains unchanged):\n--- File: packages/flutter/lib/src/foundation/change_notifier.dart ---\n// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @docImport 'package:flutter/animation.dart';\n/// @docImport 'package:flutter/widgets.dart';\nlibrary;\n\nimport 'dart:ui' show VoidCallback;\n\nimport 'package:meta/meta.dart';\n\nimport 'assertions.dart';\nimport 'diagnostics.dart';\nimport 'memory_allocations.dart';\n\nexport 'dart:ui' show VoidCallback;\n\n/// An object that maintains a list of listeners.\n///\n/// The listeners are typically used to notify clients that the object has been\n/// updated.\n///\n/// There are two variants of this interface:\n///\n///  * [ValueListenable], an interface that augments the [Listenable] interface\n///    with the concept of a _current value_.\n///\n///  * [Animation], an interface that augments the [ValueListenable] interface\n///    to add the concept of direction (forward or reverse).\n///\n/// Many classes in the Flutter API use or implement these interfaces. The\n/// following subclasses are especially relevant:\n///\n///  * [ChangeNotifier], which can be subclassed or mixed in to create objects\n///    that implement the [Listenable] interface.\n///\n///  * [ValueNotifier], which implements the [ValueListenable] interface with\n///    a mutable value that triggers the notifications when modified.\n///\n/// The terms \"notify clients\", \"send notifications\", \"trigger notifications\",\n/// and \"fire notifications\" are used interchangeably.\n///\n/// See also:\n///\n///  * [AnimatedBuilder], a widget that uses a builder callback to rebuild\n///    whenever a given [Listenable] triggers its notifications. This widget is\n///    commonly used with [Animation] subclasses, hence its name, but is by no\n///    means limited to animations, as it can be used with any [Listenable]. It\n///    is a subclass of [AnimatedWidget], which can be used to create widgets\n///    that are driven from a [Listenable].\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\n///  * [InheritedNotifier], an abstract superclass for widgets that use a\n///    [Listenable]'s notifications to trigger rebuilds in descendant widgets\n///    that declare a dependency on them, using the [InheritedWidget] mechanism.\n///  * [Listenable.merge], which creates a [Listenable] that triggers\n///    notifications whenever any of a list of other [Listenable]s trigger their\n///    notifications.\nabstract class Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const Listenable();\n\n  /// Return a [Listenable] that triggers when any of the given [Listenable]s\n  /// themselves trigger.\n  ///\n  /// Once the factory is called, items must not be added or removed from the iterable.\n  /// Doing so will lead to memory leaks or exceptions.\n  ///\n  /// The iterable may contain nulls; they are ignored.\n  factory Listenable.merge(Iterable<Listenable?> listenables) = _MergingListenable;\n\n  /// Register a closure to be called when the object notifies its listeners.\n  void addListener(VoidCallback listener);\n\n  /// Remove a previously registered closure from the list of closures that the\n  /// object notifies.\n  void removeListener(VoidCallback listener);\n}\n\n/// An interface for subclasses of [Listenable] that expose a [value].\n///\n/// This interface is implemented by [ValueNotifier<T>] and [Animation<T>], and\n/// allows other APIs to accept either of those implementations interchangeably.\n///\n/// See also:\n///\n///  * [ValueListenableBuilder], a widget that uses a builder callback to\n///    rebuild whenever a [ValueListenable] object triggers its notifications,\n///    providing the builder with the value of the object.\nabstract class ValueListenable<T> extends Listenable {\n  /// Abstract const constructor. This constructor enables subclasses to provide\n  /// const constructors so that they can be used in const expressions.\n  const ValueListenable();\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n\nconst String _flutterFoundationLibrary = 'package:flutter/foundation.dart';\n\n/// A class that can be extended or mixed in that provides a change notification\n/// API using [VoidCallback] for notifications.\n///\n/// It is O(1) for adding listeners and O(N) for removing listeners and dispatching\n/// notifications (where N is the number of listeners).\n///\n/// ## Using ChangeNotifier subclasses for data models\n///\n/// A data structure can extend or mix in [ChangeNotifier] to implement the\n/// [Listenable] interface and thus become usable with widgets that listen for\n/// changes to [Listenable]s, such as [ListenableBuilder].\n///\n/// {@tool dartpad}\n/// The following example implements a simple counter that utilizes a\n/// [ListenableBuilder] to limit rebuilds to only the [Text] widget containing\n/// the count. The current count is stored in a [ChangeNotifier] subclass, which\n/// rebuilds the [ListenableBuilder]'s contents when its value is changed.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.2.dart **\n/// {@end-tool}\n///\n/// {@tool dartpad}\n/// In this case, the [ChangeNotifier] subclass encapsulates a list, and notifies\n/// the clients any time an item is added to the list. This example only supports\n/// adding items; as an exercise, consider adding buttons to remove items from\n/// the list as well.\n///\n/// ** See code in examples/api/lib/widgets/transitions/listenable_builder.3.dart **\n/// {@end-tool}\n///\n/// See also:\n///\n///  * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value.\nmixin class ChangeNotifier implements Listenable {\n  int _count = 0;\n  // The _listeners is intentionally set to a fixed-length _GrowableList instead\n  // of const [].\n  //\n  // The const [] creates an instance of _ImmutableList which would be\n  // different from fixed-length _GrowableList used elsewhere in this class.\n  // keeping runtime type the same during the lifetime of this class lets the\n  // compiler to infer concrete type for this property, and thus improves\n  // performance.\n  static final List<VoidCallback?> _emptyListeners = List<VoidCallback?>.filled(0, null);\n  List<VoidCallback?> _listeners = _emptyListeners;\n  int _notificationCallStackDepth = 0;\n  int _reentrantlyRemovedListeners = 0;\n  bool _debugDisposed = false;\n\n  /// If true, the event [ObjectCreated] for this instance was dispatched to\n  /// [FlutterMemoryAllocations].\n  ///\n  /// As [ChangeNotifier] is used as mixin, it does not have constructor,\n  /// so we use [addListener] to dispatch the event.\n  bool _creationDispatched = false;\n\n  /// Used by subclasses to assert that the [ChangeNotifier] has not yet been\n  /// disposed.\n  ///\n  /// {@tool snippet}\n  /// The [debugAssertNotDisposed] function should only be called inside of an\n  /// assert, as in this example.\n  ///\n  /// ```dart\n  /// class MyNotifier with ChangeNotifier {\n  ///   void doUpdate() {\n  ///     assert(ChangeNotifier.debugAssertNotDisposed(this));\n  ///     // ...\n  ///   }\n  /// }\n  /// ```\n  /// {@end-tool}\n  // This is static and not an instance method because too many people try to\n  // implement ChangeNotifier instead of extending it (and so it is too breaking\n  // to add a method, especially for debug).\n  static bool debugAssertNotDisposed(ChangeNotifier notifier) {\n    assert(() {\n      if (notifier._debugDisposed) {\n        throw FlutterError(\n          'A ${notifier.runtimeType} was used after being disposed.\\n'\n          'Once you have called dispose() on a ${notifier.runtimeType}, it '\n          'can no longer be used.',\n        );\n      }\n      return true;\n    }());\n    return true;\n  }\n\n  /// Whether any listeners are currently registered.\n  ///\n  /// Clients should not depend on this value for their behavior, because having\n  /// one listener's logic change when another listener happens to start or stop\n  /// listening will lead to extremely hard-to-track bugs. Subclasses might use\n  /// this information to determine whether to do any work when there are no\n  /// listeners, however; for example, resuming a [Stream] when a listener is\n  /// added and pausing it when a listener is removed.\n  ///\n  /// Typically this is used by overriding [addListener], checking if\n  /// [hasListeners] is false before calling `super.addListener()`, and if so,\n  /// starting whatever work is needed to determine when to call\n  /// [notifyListeners]; and similarly, by overriding [removeListener], checking\n  /// if [hasListeners] is false after calling `super.removeListener()`, and if\n  /// so, stopping that same work.\n  ///\n  /// This method returns false if [dispose] has been called.\n  @protected\n  bool get hasListeners => _count > 0;\n\n  /// Dispatches event of the [object] creation to [FlutterMemoryAllocations.instance].\n  ///\n  /// If the event was already dispatched or [kFlutterMemoryAllocationsEnabled]\n  /// is false, the method is noop.\n  ///\n  /// Tools like leak_tracker use the event of object creation to help\n  /// developers identify the owner of the object, for troubleshooting purposes,\n  /// by taking stack trace at the moment of the event.\n  ///\n  /// But, as [ChangeNotifier] is mixin, it does not have its own constructor. So, it\n  /// communicates object creation in first `addListener`, that results\n  /// in the stack trace pointing to `addListener`, not to constructor.\n  ///\n  /// To make debugging easier, invoke [ChangeNotifier.maybeDispatchObjectCreation]\n  /// in constructor of the class. It will help\n  /// to identify the owner.\n  ///\n  /// Make sure to invoke it with condition `if (kFlutterMemoryAllocationsEnabled) ...`\n  /// so that the method is tree-shaken away when the flag is false.\n  @protected\n  static void maybeDispatchObjectCreation(ChangeNotifier object) {\n    // Tree shaker does not include this method and the class MemoryAllocations\n    // if kFlutterMemoryAllocationsEnabled is false.\n    if (kFlutterMemoryAllocationsEnabled && !object._creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectCreated(\n        library: _flutterFoundationLibrary,\n        className: '$ChangeNotifier',\n        object: object,\n      );\n      object._creationDispatched = true;\n    }\n  }\n\n  /// Register a closure to be called when the object changes.\n  ///\n  /// If the given closure is already registered, an additional instance is\n  /// added, and must be removed the same number of times it is added before it\n  /// will stop being called.\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// {@template flutter.foundation.ChangeNotifier.addListener}\n  /// If a listener is added twice, and is removed once during an iteration\n  /// (e.g. in response to a notification), it will still be called again. If,\n  /// on the other hand, it is removed as many times as it was registered, then\n  /// it will no longer be called. This odd behavior is the result of the\n  /// [ChangeNotifier] not being able to determine which listener is being\n  /// removed, since they are identical, therefore it will conservatively still\n  /// call all the listeners when it knows that any are still registered.\n  ///\n  /// This surprising behavior can be unexpectedly observed when registering a\n  /// listener on two separate objects which are both forwarding all\n  /// registrations to a common upstream object.\n  /// {@endtemplate}\n  ///\n  /// See also:\n  ///\n  ///  * [removeListener], which removes a previously registered closure from\n  ///    the list of closures that are notified when the object changes.\n  @override\n  void addListener(VoidCallback listener) {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n\n    if (kFlutterMemoryAllocationsEnabled) {\n      maybeDispatchObjectCreation(this);\n    }\n\n    if (_count == _listeners.length) {\n      if (_count == 0) {\n        _listeners = List<VoidCallback?>.filled(1, null);\n      } else {\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(\n          _listeners.length * 2,\n          null,\n        );\n        for (int i = 0; i < _count; i++) {\n          newListeners[i] = _listeners[i];\n        }\n        _listeners = newListeners;\n      }\n    }\n    _listeners[_count++] = listener;\n  }\n\n  void _removeAt(int index) {\n    // The list holding the listeners is not growable for performances reasons.\n    // We still want to shrink this list if a lot of listeners have been added\n    // and then removed outside a notifyListeners iteration.\n    // We do this only when the real number of listeners is half the length\n    // of our list.\n    _count -= 1;\n    if (_count * 2 <= _listeners.length) {\n      final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(_count, null);\n\n      // Listeners before the index are at the same place.\n      for (int i = 0; i < index; i++) {\n        newListeners[i] = _listeners[i];\n      }\n\n      // Listeners after the index move towards the start of the list.\n      for (int i = index; i < _count; i++) {\n        newListeners[i] = _listeners[i + 1];\n      }\n\n      _listeners = newListeners;\n    } else {\n      // When there are more listeners than half the length of the list, we only\n      // shift our listeners, so that we avoid to reallocate memory for the\n      // whole list.\n      for (int i = index; i < _count; i++) {\n        _listeners[i] = _listeners[i + 1];\n      }\n      _listeners[_count] = null;\n    }\n  }\n\n  /// Remove a previously registered closure from the list of closures that are\n  /// notified when the object changes.\n  ///\n  /// If the given listener is not registered, the call is ignored.\n  ///\n  /// This method returns immediately if [dispose] has been called.\n  ///\n  /// {@macro flutter.foundation.ChangeNotifier.addListener}\n  ///\n  /// See also:\n  ///\n  ///  * [addListener], which registers a closure to be called when the object\n  ///    changes.\n  @override\n  void removeListener(VoidCallback listener) {\n    // This method is allowed to be called on disposed instances for usability\n    // reasons. Due to how our frame scheduling logic between render objects and\n    // overlays, it is common that the owner of this instance would be disposed a\n    // frame earlier than the listeners. Allowing calls to this method after it\n    // is disposed makes it easier for listeners to properly clean up.\n    for (int i = 0; i < _count; i++) {\n      final VoidCallback? listenerAtIndex = _listeners[i];\n      if (listenerAtIndex == listener) {\n        if (_notificationCallStackDepth > 0) {\n          // We don't resize the list during notifyListeners iterations\n          // but we set to null, the listeners we want to remove. We will\n          // effectively resize the list at the end of all notifyListeners\n          // iterations.\n          _listeners[i] = null;\n          _reentrantlyRemovedListeners++;\n        } else {\n          // When we are outside the notifyListeners iterations we can\n          // effectively shrink the list.\n          _removeAt(i);\n        }\n        break;\n      }\n    }\n  }\n\n  /// Discards any resources used by the object. After this is called, the\n  /// object is not in a usable state and should be discarded (calls to\n  /// [addListener] will throw after the object is disposed).\n  ///\n  /// This method should only be called by the object's owner.\n  ///\n  /// This method does not notify listeners, and clears the listener list once\n  /// it is called. Consumers of this class must decide on whether to notify\n  /// listeners or not immediately before disposal.\n  @mustCallSuper\n  void dispose() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    assert(\n      _notificationCallStackDepth == 0,\n      'The \"dispose()\" method on $this was called during the call to '\n      '\"notifyListeners()\". This is likely to cause errors since it modifies '\n      'the list of listeners while the list is being used.',\n    );\n    assert(() {\n      _debugDisposed = true;\n      return true;\n    }());\n    if (kFlutterMemoryAllocationsEnabled && _creationDispatched) {\n      FlutterMemoryAllocations.instance.dispatchObjectDisposed(object: this);\n    }\n    _listeners = _emptyListeners;\n    _count = 0;\n  }\n\n  /// Call all the registered listeners.\n  ///\n  /// Call this method whenever the object changes, to notify any clients the\n  /// object may have changed. Listeners that are added during this iteration\n  /// will not be visited. Listeners that are removed during this iteration will\n  /// not be visited after they are removed.\n  ///\n  /// Exceptions thrown by listeners will be caught and reported using\n  /// [FlutterError.reportError].\n  ///\n  /// This method must not be called after [dispose] has been called.\n  ///\n  /// Surprising behavior can result when reentrantly removing a listener (e.g.\n  /// in response to a notification) that has been registered multiple times.\n  /// See the discussion at [removeListener].\n  @protected\n  @visibleForTesting\n  @pragma('vm:notify-debugger-on-exception')\n  void notifyListeners() {\n    assert(ChangeNotifier.debugAssertNotDisposed(this));\n    if (_count == 0) {\n      return;\n    }\n\n    // To make sure that listeners removed during this iteration are not called,\n    // we set them to null, but we don't shrink the list right away.\n    // By doing this, we can continue to iterate on our list until it reaches\n    // the last listener added before the call to this method.\n\n    // To allow potential listeners to recursively call notifyListener, we track\n    // the number of times this method is called in _notificationCallStackDepth.\n    // Once every recursive iteration is finished (i.e. when _notificationCallStackDepth == 0),\n    // we can safely shrink our list so that it will only contain not null\n    // listeners.\n\n    _notificationCallStackDepth++;\n\n    final int end = _count;\n    for (int i = 0; i < end; i++) {\n      try {\n        _listeners[i]?.call();\n      } catch (exception, stack) {\n        FlutterError.reportError(\n          FlutterErrorDetails(\n            exception: exception,\n            stack: stack,\n            library: 'foundation library',\n            context: ErrorDescription('while dispatching notifications for $runtimeType'),\n            informationCollector:\n                () => <DiagnosticsNode>[\n                  DiagnosticsProperty<ChangeNotifier>(\n                    'The $runtimeType sending notification was',\n                    this,\n                    style: DiagnosticsTreeStyle.errorProperty,\n                  ),\n                ],\n          ),\n        );\n      }\n    }\n\n    _notificationCallStackDepth--;\n\n    if (_notificationCallStackDepth == 0 && _reentrantlyRemovedListeners > 0) {\n      // We really remove the listeners when all notifications are done.\n      final int newLength = _count - _reentrantlyRemovedListeners;\n      if (newLength * 2 <= _listeners.length) {\n        // As in _removeAt, we only shrink the list when the real number of\n        // listeners is half the length of our list.\n        final List<VoidCallback?> newListeners = List<VoidCallback?>.filled(newLength, null);\n\n        int newIndex = 0;\n        for (int i = 0; i < _count; i++) {\n          final VoidCallback? listener = _listeners[i];\n          if (listener != null) {\n            newListeners[newIndex++] = listener;\n          }\n        }\n\n        _listeners = newListeners;\n      } else {\n        // Otherwise we put all the null references at the end.\n        for (int i = 0; i < newLength; i += 1) {\n          if (_listeners[i] == null) {\n            // We swap this item with the next not null item.\n            int swapIndex = i + 1;\n            while (_listeners[swapIndex] == null) {\n              swapIndex += 1;\n            }\n            _listeners[i] = _listeners[swapIndex];\n            _listeners[swapIndex] = null;\n          }\n        }\n      }\n\n      _reentrantlyRemovedListeners = 0;\n      _count = newLength;\n    }\n  }\n}\n\nclass _MergingListenable extends Listenable {\n  _MergingListenable(this._children);\n\n  final Iterable<Listenable?> _children;\n\n  @override\n  void addListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.addListener(listener);\n    }\n  }\n\n  @override\n  void removeListener(VoidCallback listener) {\n    for (final Listenable? child in _children) {\n      child?.removeListener(listener);\n    }\n  }\n\n  @override\n  String toString() {\n    return 'Listenable.merge([${_children.join(\", \")}])';\n  }\n}\n\n/// A [ChangeNotifier] that holds a single value.\n///\n/// When [value] is replaced with something that is not equal to the old\n/// value as evaluated by the equality operator ==, this class notifies its\n/// listeners.\n///\n/// ## Limitations\n///\n/// Because this class only notifies listeners when the [value]'s _identity_\n/// changes, listeners will not be notified when mutable state within the\n/// value itself changes.\n///\n/// For example, a `ValueNotifier<List<int>>` will not notify its listeners\n/// when the _contents_ of the list are changed.\n///\n/// As a result, this class is best used with only immutable data types.\n///\n/// For mutable data types, consider extending [ChangeNotifier] directly.\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  /// Creates a [ChangeNotifier] that wraps this value.\n  ValueNotifier(this._value) {\n    if (kFlutterMemoryAllocationsEnabled) {\n      ChangeNotifier.maybeDispatchObjectCreation(this);\n    }\n  }\n\n  /// The current value stored in this notifier.\n  ///\n  /// When the value is replaced with something that is not equal to the old\n  /// value as evaluated by the equality operator ==, this class notifies its\n  /// listeners.\n  @override\n  T get value => _value;\n  T _value;\n  set value(T newValue) {\n    if (_value == newValue) {\n      return;\n    }\n    _value = newValue;\n    notifyListeners();\n  }\n\n  @override\n  String toString() => '${describeIdentity(this)}($value)';\n}\n\n\nInstructions for the chapter (Generate content in English unless specified otherwise):\n- Start with a clear heading (e.g., `# Chapter 4: ValueListenable\n`). Use the provided concept name.\n\n- If this is not the first chapter, begin with a brief transition from the previous chapter, referencing it with a proper Markdown link using its name.\n\n- Begin with a high-level motivation explaining what problem this abstraction solves. Start with a central use case as a concrete example. The whole chapter should guide the reader to understand how to solve this use case. Make it very minimal and friendly to beginners.\n\n- If the abstraction is complex, break it down into key concepts. Explain each concept one-by-one in a very beginner-friendly way.\n\n- Explain how to use this abstraction to solve the use case. Give example inputs and outputs for code snippets (if the output isn't values, describe at a high level what will happen).\n\n- Each code block should be BELOW 10 lines! If longer code blocks are needed, break them down into smaller pieces and walk through them one-by-one. Aggresively simplify the code to make it minimal. Use comments to skip non-important implementation details. Each code block should have a beginner friendly explanation right after it.\n\n- Describe the internal implementation to help understand what's under the hood. First provide a non-code or code-light walkthrough on what happens step-by-step when the abstraction is called. It's recommended to use a simple sequenceDiagram with a dummy example - keep it minimal with at most 5 participants to ensure clarity. If participant name has space, use: `participant QP as Query Processing`. .\n\n- Then dive deeper into code for the internal implementation with references to files. Provide example code blocks, but make them similarly simple and beginner-friendly. Explain.\n\n- IMPORTANT: When you need to refer to other core abstractions covered in other chapters, ALWAYS use proper Markdown links like this: [Chapter Title](filename.md). Use the Complete Tutorial Structure above to find the correct filename and the chapter title. Translate the surrounding text.\n\n- Use mermaid diagrams to illustrate complex concepts (```mermaid``` format). .\n\n- Heavily use analogies and examples throughout to help beginners understand.\n\n- End the chapter with a brief conclusion that summarizes what was learned and provides a transition to the next chapter. If there is a next chapter, use a proper Markdown link: [Next Chapter Title](next_chapter_filename).\n\n- Ensure the tone is welcoming and easy for a newcomer to understand.\n\n- Output *only* the Markdown content for this chapter.\n\nNow, directly provide a super beginner-friendly Markdown output (DON'T need ```markdown``` tags):\n": "# Chapter 4: ValueListenable\n\nWelcome back! We've been building up our understanding of how objects in Flutter can announce changes. We started with [ChangeNotifier](01_changenotifier_.md), the general concept of managing listeners, and then looked at [Listenable](02_listenable_.md), the interface that defines the ability to be listened to. In our last chapter, we saw [ValueNotifier](03_valuelistenable_.md), a convenient class that wraps a single value and extends [ChangeNotifier](01_changenotifier_.md).\n\nNow, let's explore the idea that [ValueNotifier](03_valuelistenable_.md) *implements*: the `ValueListenable`.\n\n### What is a ValueListenable?\n\nRemember how a [Listenable](02_listenable_.md) is the blueprint for *any* object that can be listened to? A `ValueListenable` is a more specific kind of blueprint. It's for objects that not only can be listened to, but also hold a *specific* value that can change.\n\nThink of it like this:\n\n*   A [Listenable](02_listenable_.md) is a \"can be watched\" sign.\n*   A `ValueListenable` is a \"can be watched, *and* I have a value you can look at\" sign.\n\nSo, a `ValueListenable` is an object that:\n\n1.  Implements the [Listenable](02_listenable_.md) interface (meaning you can add and remove listeners).\n2.  Exposes a `.value` property that gives you the current value it holds.\n3.  Notifies its listeners whenever that `.value` changes.\n\nOur [ValueNotifier](03_valuelistenable_.md) from the last chapter is a perfect example of a `ValueListenable`. It holds a value (like the temperature) and tells you when it changes.\n\n### Why do we need ValueListenable?\n\nYou might be thinking, \"Okay, so [ValueNotifier](03_valuelistenable_.md) does this. Why do I need a separate term `ValueListenable`?\"\n\nThe `ValueListenable` is an *interface*. This means it's a contract or a set of rules that any class can choose to follow. By defining the `ValueListenable` interface, Flutter allows different classes to provide the same \"has a value that can change and be listened to\" capability.\n\nThis is powerful because widgets and other parts of Flutter can be built to work with *any* `ValueListenable`, not just specifically a [ValueNotifier](03_valuelistenable_.md).\n\nFor example, Flutter has a widget called `ValueListenableBuilder`. This widget knows how to listen to *any* object that follows the `ValueListenable` rules and rebuild itself whenever that object's value changes. It doesn't care if you give it a [ValueNotifier](03_valuelistenable_.md), an `Animation` (which also happens to be a `ValueListenable`), or your own custom class that implements `ValueListenable`.\n\nIt promotes **code reusability and flexibility**.\n\n### How does ValueListenable work?\n\nSince `ValueListenable` is an interface (like [Listenable](02_listenable_.md)), you don't create instances of it directly. You create instances of classes that *implement* the `ValueListenable` interface. The most common one you'll encounter for simple values is [ValueNotifier](03_valuelistenable_.md), which we just learned about.\n\nThe `ValueListenable` interface (found in the same `change_notifier.dart` file we've been looking at) defines two things:\n\n1.  It extends the `Listenable` interface.\n2.  It requires a `get value` getter.\n\nHere's the interface definition:\n\n```dart\nabstract class ValueListenable<T> extends Listenable {\n  // Abstract const constructor ...\n\n  /// The current value of the object. When the value changes, the callbacks\n  /// registered with [addListener] will be invoked.\n  T get value;\n}\n```\n\n*   `abstract class ValueListenable<T>`: This declares the interface. The `<T>` means it works with any type of data (like `int`, `double`, `String`, or your own custom classes).\n*   `extends Listenable`: This confirms that a `ValueListenable` is also a regular [Listenable](02_listenable_.md). It inherits the `addListener` and `removeListener` methods.\n*   `T get value;`: This is the key part. Any class implementing `ValueListenable<T>` *must* provide a way to read its current value, and that way is accessed via a property called `value` which returns data of type `T`.\n\nRemember our [ValueNotifier](03_valuelistenable_.md) from the last chapter? It implements this interface:\n\n```dart\nclass ValueNotifier<T> extends ChangeNotifier implements ValueListenable<T> {\n  // ... (constructor and internal _value) ...\n\n  @override // <-- This annotation reminds us we are fulfilling an interface requirement\n  T get value => _value;\n\n  set value(T newValue) {\n    // ... (checks for equality and calls notifyListeners) ...\n  }\n}\n```\n\nThe `@override` annotation here is helpful because it explicitly shows that `ValueNotifier` is providing the `get value` method as required by the `ValueListenable<T>` interface.\n\n### Using ValueListenable (via ValueListenableBuilder)\n\nThe most common way you'll interact with `ValueListenable` in Flutter UI is through widgets designed to work with them, like `ValueListenableBuilder`.\n\nLet's revisit our counter example, but this time using `ValueListenableBuilder` and a simple `ValueNotifier` (which is a `ValueListenable`):\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: CounterPage(),\n    );\n  }\n}\n\n// Our ValueListenable holds the counter value\nfinal ValueNotifier<int> counter = ValueNotifier<int>(0);\n\n// A simple page with a ValueListenableBuilder and a button.\nclass CounterPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('ValueListenable Example')),\n      body: Center(\n        // ValueListenableBuilder listens to the 'counter' ValueNotifier\n        child: ValueListenableBuilder<int>(\n          valueListenable: counter, // This is our ValueListenable!\n          builder: (context, currentValue, child) {\n            // This builder function is called whenever counter.value changes.\n            // 'currentValue' is the current value from the ValueListenable.\n            return Text(\n              'Counter: $currentValue', // Display the current value\n              style: TextStyle(fontSize: 30),\n            );\n          },\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          // Increment the value of the ValueNotifier\n          counter.value++;\n        },\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n\nWhen you run this app:\n\n1.  The `ValueNotifier<int> counter` is created with an initial value of 0.\n2.  The `ValueListenableBuilder` is built. It's given our `counter` object as its `valueListenable`.\n3.  The `ValueListenableBuilder` immediately calls its `builder` function for the first time, receiving the initial `counter.value` (which is 0). The `Text` widget displays \"Counter: 0\".\n4.  When you tap the `FloatingActionButton`, `counter.value++` is called.\n5.  Because we set `counter.value` to a new value (1), the `ValueNotifier` (which is a `ValueListenable`) calls its `notifyListeners()` method internally.\n6.  The `ValueListenableBuilder` is one of the listeners! It receives the notification.\n7.  The `ValueListenableBuilder` then tells Flutter to rebuild only the part of the UI inside its `builder` function.\n8.  The `builder` function is called *again*, this time receiving the new `counter.value` (which is 1). The `Text` widget updates to \"Counter: 1\".\n9.  This process repeats every time you tap the button.\n\nThe `ValueListenableBuilder` is able to do this because `ValueNotifier` implements the `ValueListenable` interface. The builder widget simply cares that the object it's given adheres to the `ValueListenable` contract (it can be listened to, and it has a `value`).\n\n### ValueListenable + Listenable + ChangeNotifier + ValueNotifier\n\nLet's quickly recap how these four concepts relate using our analogies:\n\n*   **The Change:** The specific event (the counter goes from 0 to 1).\n*   **Listenable (Blueprint):** The general idea of an object that *can* be watched for changes (`addListener`, `removeListener`). Sign: \"Can be watched\".\n*   **ValueListenable (More Specific Blueprint):** The idea of an object that *can* be watched AND holds a `value` that changes. Sign: \"Can be watched, and I have a value you can look at\".\n*   **ChangeNotifier (Implementation):** A class that provides the *actual code* to manage a list of listeners and notify them. Engine: The system that keeps track of watchers and sends messages.\n*   **ValueNotifier (Specific Implementation):** A class that *extends* [ChangeNotifier](01_changenotifier_.md) and *implements* `ValueListenable`. It specifically wraps a single value and notifies listeners *only* when that value changes. It's the specialized box with a window that calls its parent ([ChangeNotifier](01_changenotifier_.md)) when the item inside is replaced with a different one.\n\nHere's a simple diagram showing the relationship between the concepts:\n\n```mermaid\ngraph TD\n    A[Listenable] --> B[ValueListenable];\n    C[ChangeNotifier] --> B;\n    C --> D[ValueNotifier];\n    B --> D;\n```\n\nThis diagram visually represents:\n*   A `ValueListenable` *is a type of* [Listenable](02_listenable_.md).\n*   [ValueNotifier](03_valuenotifier_.md) *is a type of* [ChangeNotifier](01_changenotifier_.md).\n*   [ValueNotifier](03_valuenotifier_.md) *implements* the `ValueListenable` interface.\n*   [ChangeNotifier](01_changenotifier_.md) implements [Listenable](02_listenable_.md) (though not explicitly shown inheriting in this simple diagram, it's part of its definition).\n\nEssentially, `ValueListenable` is the contract that `ValueNotifier` follows, allowing widgets like `ValueListenableBuilder` to work with it without needing to know it's specifically a [ValueNotifier](03_valuelistenable_.md).\n\n### Conclusion\n\nIn this chapter, we learned about the `ValueListenable` interface. We saw that it's a type of [Listenable](02_listenable_.md) that specifically deals with objects that hold a value and notify listeners when that value changes. We understood why having this interface is important for building flexible Flutter widgets like `ValueListenableBuilder`.\n\nWe reinforced that [ValueNotifier](03_valuenotifier_.md) is a common class that implements the `ValueListenable` interface, making it easy to create and use observable single values in your application.\n\nYou now have a solid understanding of the four key concepts: [ChangeNotifier](01_changenotifier_.md), [Listenable](02_listenable_.md), [ValueNotifier](03_valuenotifier_.md), and ValueListenable. These form the bedrock for many Flutter state management approaches!"}